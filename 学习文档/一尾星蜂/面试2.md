# 面试

1. 架构师

   - [JVM](#JVM)
2. 项目经理
3. 产品经理
4. 面试题
   - [BIO/NIO/AIO](#BIO/NIO/AIO)



## 架构师



### JVM

JVM 是每一个开发人员必备的技能，推荐看国内比较经典的 JVM 书籍，里面包含 JVM 的内存接口，类的加载机制等基础知识，是不是觉得这些在面试中似曾相识？所以对于 JVM 方面的知识的巩固与其在网上看一些零零碎碎的文章不如啃一下这本书。

《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第2版）》，当然了如果你的英文好强烈推荐看 Oracle 最新发布的 JAVA 虚拟机规范。

在啃书的时候切记不能图快，***你对知识的积累不是通过看书的数量来决定，而是看书的深度***。所以在看每一章节的时候看到不懂的要配合网上的文章理解，并且需要看几篇文章理解，因为一篇文章很可能是错误的，小编认为文章的可信度顺序：自建域名 > github.io > SF > 简书 = 博客园 > CSDN > 转载。



### 算法

#### Java 集合&工具类

这一个分类是每一个人必须掌握的并熟练使用的，那么为什么我把他们放在一起呢？ 

因为工具和集合类都源于算法，在准备算法复习之前你要理解，为什么要必考算法。正式因为排序算法和我们编程息息相关。举两个“栗子”。

你可以看一下 Collections 中的 mergeSort 和 sort 方法，你会发现 mergeSort 就是归并排序的实现，而 sort 方法结合了归并排序和插入排序，这样使得 sort 方法最差O(NlogN)最好可以达到O(N)的效果。那么只有你自己理解了排序方法的实现，才能更好的使用 JAVA 中的集合类啊？

第二个“栗子”，大家都听闻过 TopN 问题吧，经常在面试中遇到请写一下 TopN 的实现，说到算法它就是一个大顶堆，说到 JAVA 它是一个 PriorityQueue 的实现，那么你理解了 TopN 问题，知道他的时间复杂度，优缺点了，那么是不是就可以熟练运用 JAVA 的工具类写更高效的程序了？

之所以排序算法和 JAVA 集合&工具类 一样重要是因为它们和我们每天的编程息息相关。面试官总是问排序算法也不是在难为你，而是在考察你的编程功底。所以你需要对着排序算法和基本的算法配合 JAVA 的集合类、工具类仔细的研究一番，这样才能更深入的理解他们的关联关系。 

https://leetcode-cn.com/



### 多线程和并发

多线程和并发包，重要性就不累述了，直接说一下学习方法。你首先要理解多线程不仅仅是 Thread 和 Runnable 那么简单，整个并发包下面的工具都是在为多线程服务。对于多线程的学习切不可看几篇面试文章，或者几个关键字 CountDownLatch，Lock 巴拉巴拉就以为理解了多线程的精髓，你需要自己梳理一个大图，对里面的类各个击破，他们的使用场景，优缺点。当然你需要配合源码看，源码就是大图里面的每一个源码，和上面讲的 JVM 一样，不要着急马上看完，而是看懂每一个地方是为什么。看的差不多你就会发现，其实他和 JAVA 集合类、工具类密不可分。那么自然把它列为重要知识点的原因不言而喻。



### 存储

我们平时常用的工具：Redis，MySQL，ElasticSearch。

它的知识点分为两方面，一方面是你平时使用过程中积累的经验，另一方面是你对其的深入理解。所以对这个地方的建议就是通过书籍来巩固技术知识。《Redis设计与实现（数据库技术丛书）》，《高性能 MySQL》，《ElasticSearch 权威指南》这三本书不一定是该领域最好的书籍，但是如果你吃透了，对于你对知识的理解和程序的设计必定有很大帮助。书里面的内容太多，还是举两个“栗子”。

第一个“栗子”，使用 Redis 切不可只用他当做 key-value 缓存数据库。小编了解到它的5种基本类型中一种类型叫做 sorted set。sorted set 里 items 内容大于 64 的时候同时使用了 hash 和 skiplist 两种设计实现。这也会为了排序和查找性能做的优化。添加和删除都需要修改 skiplist，所以复杂度为 O(log(n))。 但是如果仅仅是查找元素的话可以直接使用 hash，其复杂度为 O(1) ，其他的 range 操作复杂度一般为 O(log(n))，当然如果是小于 64 的时候，因为是采用了 ziplist 的设计，其时间复杂度为 O(n)。这样以后查询和更新阅读都变得简单，那是不是可以用其实现 TopN 的需求呢？这样类似的需求就不需要你查数据，再在内存里面计算和操作了。比如我们简单的周排行，月排行都可以考虑使用这个数据结构实现，当然并不一定这是最好的解决方案，而是提供了一种解题思路。 

另一个“栗子”，PriorityQueue 是优先队列我们上文已经了解，那么 ElasticSearch 的 query 也是用的优先队列分别在每一个分片上面获取，然后再合并优先队列你了解吗？这个“栗子”告诉我们其实算法是想通的，你理解一个便可以举一反三触类旁通。



### 框架

Spring，SpringMVC，Spring Boot

一谈框架就想起来 Spring，一说 Spring 就想起来 IOC，AOP。因为大家都在用这个框架，所以对于框架也不需要看一些其他的，直接就深入了解一下 Spring 就可以了。通过上面的叙述你已经了解了小编的思路，看什么都要看他的实现原理，所以直接推荐你一本书《Spring 技术内幕》然后对着自己现有的 Spring 项目 Debug，从请求的流转梳理知识点。Spring 出来这么久大家对基本的知识已经了然于胸，重要的是看其解决问题的思路和原理，栗子又来了。 

比如需要实现在 Bean 刚刚初始化的时候做一些操作，是不是需要使用 InitializingBean？那么具体怎么使用，它的原理是什么，Spring Bean 的生命周期是什么样子，通过具体的使用场景逐步展开说明。这样复习效果会更好一些，然后再逐步的思考每一个知识点里面涉及的更多的知识点，比如 AOP 里面的 Proxy 都是基于什么原理实现，有什么优缺点。



### 分布式



#### Dubbo

这是一个老生常谈的话题，也是这几年比较火的话题，说起分布式就一定和 Dubbo 有关系，但是不能仅仅就理解到 Dubbo。

首先我们需要思考它解决的问题，为什么要引入 Dubbo 这个概念。随着业务的发展、用户量的增长，系统数量增多，调用依赖关系也变得复杂，为了确保系统高可用、高并发的要求，系统的架构也从单体时代慢慢迁移至服务SOA时代，应运而生的 Dubbo 出现了，它作为 RPC 的出现使得我们搭建微服务项目变得简单，但是我们不仅仅要思考 Dubbo 带来的框架支撑。

同时需要思考服务的幂等、分布式事务、服务之间的 Trace 定位、分布式日志、数据对账、重试机制等，与此同时考虑 MQ 对系统的解耦和压力的分担、数据库分布式部署和分库分表、限流、熔断等机制。

所以最终总结是不仅仅要看 Dubbo 的使用、原理同时还要思考上下游和一些系统设计的问题，这块相对的知识点较多，可以针对上面抛出来的点各个击破。



### 设计模式

设计模式很多，但是常用的就几种，这个地方可以分两个地方准备。

1. 学以致用，设计模式不是背出来的，而是用出来了。平时多注意思考当前项目的设计，是否可以套用设计模式，当然必须先理解每一个设计模式存在的意义。 

2. 在现有框架中思考设计模式的体现，上面已经讲过框架怎么学习，用 Spring 举例，它里面一共用了9种设计模式，你都知道用到哪里了吗？如果不知道，试着把他们找出来，同时思考为什么这么设计，全部找到以后，基本的设计模式的用法和原理你也就都理解了。



## 项目经理



## 产品经理





参考：https://mp.weixin.qq.com/s?__biz=MzAwNTMxMzg1MA==&mid=2654082113&idx=1&sn=795c9a6c3b1717531846a4569f07a3d0&chksm=80d83014b7afb90254b3720c76ad93085250d44fe0432c8e6ff95f4b86114a044b01ef2eeb49&mpshare=1&scene=23&srcid=1225cMeyTkQddb1tMHKAwLEb&sharer_sharetime=1608855300953&sharer_shareid=83c85f3c4ddf8afec618435580a94a3e#rd



## 面试题



### BIO/NIO/AIO

想要了解java中的BIO/NIO/AIO，先从Unix网络编程5种I/O模型说起

#### Unix网络编程5种I/O模型

**1. 阻塞式I/O模型**

![x](D:\WorkingDir\Office\Resources\tbms0051.png)

阻塞I/O(blocking I/O）模型，进程调用recvfrom，其系统调用直到数据报到达且被拷贝到应用进程的缓冲区中或者发生错误才返回。进程从调用recvfrom开始到它返回的整段时间内是被阻塞的。

**2. 非阻塞式I/O模型**

![x](D:\WorkingDir\Office\Resources\tbms0052.png)

当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称之为轮询(polling)。应用进程持续轮询内核，以查看某个操作是否就绪。

**3. I/O多路复用（事件驱动）模型**

![x](D:\WorkingDir\Office\Resources\tbms0053.png)

**4. 信号驱动式I/O(SIGIO)**

![x](D:\WorkingDir\Office\Resources\tbms0054.png)

**5. 异步I/O模型**

![x](D:\WorkingDir\Office\Resources\tbms0055.png)

**6. I/O模型的比较**

![x](D:\WorkingDir\Office\Resources\tbms0056.png)

根据上述5种IO模型，前4种模型-阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步I/O模型，因为其中真正的I/O操作（recvfrom）将阻塞进程，在内核数据copy到用户空间时都是阻塞的。

**7. 同步IO、异步IO、阻塞IO、非阻塞IO**

一个IO操作可以分为两个步骤：发起IO请求和实际的IO操作。例如：

1. 操作系统的一次写操作分为两步：将数据从用户空间拷贝到系统空间；从系统空间往网卡写。
2. 一次读操作分为两步：将数据从网卡拷贝到系统空间；将数据从系统空间拷贝到用户空间。

阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。

同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统做完IO两个阶段的操作再将结果返回，那么就是异步IO。

**8. IO多路复用**

IO多路复用，就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

IO多路复用方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。

由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。

IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。

![x](D:\WorkingDir\Office\Resources\tbms0057.png)

上图展示了非阻塞IO如何让你使用一个selector区处理多个连接.

**9. select、poll、epoll**

Linux支持IO多路复用的系统调用有select、poll、epoll，这些调用都是内核级别的。但select、poll、epoll本质上都是同步I/O，先是block住等待就绪的socket，再是block住将数据从内核拷贝到用户内存。

select、poll、epoll之间的区别，如下表：

![x](D:\WorkingDir\Office\Resources\tbms0058.png)

**10. 两种I/O多路复用模式：Reactor和Proactor**

在这两种模式下的事件多路分离器反馈给程序的信息是不一样的：

1. Reactor模式下说明你可以进行读写（收发）操作了。
2. Proactor模式下说明已经完成读写（收发）操作了，具体内容在给定缓冲区中，可以对这些内容进行其他操作了。

Reactor关注的是I/O操作的就绪事件，而Proactor关注的是I/O操作的完成事件

一般地，I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器(Event Handler)。

Reactor模式采用同步IO，而Proactor采用异步IO。

在Reactor中，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。

而在Proactor模式中，处理器或者兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。

比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。

Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.

#### BIO/NIO/AIO

NIO，有人称之为New I/O，因为它相对于之前的I/O类库是新增的，所以被称为New I/O。但是，由于之前老的 I/O 类库是阻塞 I/O，New I/O类库的目标就是要让Java支持非阻塞 I/O，所以，更多的人喜欢称之为非阻塞 I/ O(Non-block I/O)。

**1. 对NIO的非阻塞的理解**

select是阻塞的，无论是通过操作系统的通知(epoll)还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。

NIO采用Reactor模式，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N < 进程可用的最大句柄数）或者M : N (M通常为CPU核数 + 1， N < 进程可用的最大句柄数)。

JAVA NIO 不是同步非阻塞I/O吗，为什么说JAVA NIO提供了基于Selector的异步网络I/O？
java nio的io模型是同步非阻塞，这里的同步异步指的是真正io操作（数据内核态用户态的拷贝）是否需要进程参与。而说java nio提供了异步处理，这个异步应该是指编程模型上的异步。基于reactor模式的事件驱动，事件处理器的注册和处理器的执行是异步的。

AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。

换句话说，BIO里用户最关心“我要读”，NIO里用户最关心"我可以读了"，在AIO模型里用户更需要关注的是“读完了”。

NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步的（消耗CPU但性能非常高）。

**2. 如何结合事件模型使用NIO非阻塞特性**

BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能"傻等"，即使通过各种估算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，没有好的办法利用CPU。

NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接(channel)继续进行读写。

我们大概可以总结出NIO是怎么解决掉线程的瓶颈并处理海量连接的：

NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。

**3. 理解异步非阻塞I/O**

很多人喜欢将JDK1.4提供的NIO框架称为异步非阻塞I/O，但是，如果严格按照UNIX网络编程模型和JDK的实现进行区分，实际上它只能被称为非阻塞I/O，不能叫异步非阻塞I/O。

在早期的JDK1.4和1.5 update10版本之前，JDK的Selector基于select/poll模型实现，它是基于I/O复用技术的非阻塞I/O，不是异步I/O。在JDK1.5 update10和Linux core2.6以上版本，Sun优化了Selctor的实现，它在底层使用epoll替换了select/poll，上层的API并没有变化，可以认为是JDK NIO的一次性能优化，但是它仍旧没有改变I/O的模型。

由JDK1.7提供的NIO2.0，新增了异步的套接字通道，它是真正的异步I/O，在异步I/O操作的时候可以传递信号变量，当操作完成之后会回调相关的方法，异步I/O也被称为AIO。

NIO类库支持非阻塞读和写操作，相比于之前的同步阻塞读和写，它是异步的，因此很多人习惯于称NIO为异步非阻塞I/O，包括很多介绍NIO编程的书籍也沿用了这个说法。为了符合大家的习惯，我们也将NIO称为异步非阻塞I/O或者非阻塞I/O。

![x](D:\WorkingDir\Office\Resources\tbms0059.png)

#### Java NIO的核心组成

**1. 通道(Channel) 和 缓冲区(Buffer)**

基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示：

![x](D:\WorkingDir\Office\Resources\tbms0060.png)

**2. 多路复用器(Selector)**

Selector允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。

这是在一个单线程中使用一个Selector处理3个Channel的图示：

![x](D:\WorkingDir\Office\Resources\tbms0061.png)

要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。

NIO的单线程能处理连接的数量比BIO要高出很多，而为什么单线程能处理更多的连接呢？原因就是**Selector**。

当一个连接建立之后，它有两个步骤要做：

1. 第一步是接收完客户端发过来的全部数据；
2. 第二步是服务端处理完请求业务之后返回response给客户端。

NIO和BIO的区别主要是在第一步：在BIO中，等待客户端发数据这个过程是阻塞的，这样就造成了一个线程只能处理一个请求的情况，而机器能支持的最大线程数是有限的，这就是为什么BIO不能支持高并发的原因。而NIO中，当一个Socket建立好之后，Thread并不会阻塞去接受这个Socket，而是将这个请求交给Selector，Selector会不断的去遍历所有的Socket，一旦有一个Socket建立完成，他会通知Thread，然后Thread处理完数据再返回给客户端——这个过程是不阻塞的，这样就能让一个Thread处理更多的请求了。

下面两张图是基于BIO的处理流程和NIO的处理流程，辅助你理解两种方式的差别：

![x](D:\WorkingDir\Office\Resources\java_async01.png)

![x](D:\WorkingDir\Office\Resources\java_async02.png)

#### 总结

最后总结一下到底NIO给我们带来了些什么：

- 事件驱动模型
- 避免多线程
- 单线程处理多任务
- 非阻塞I/O，I/O读写不再阻塞，而是返回0
- 基于block的传输，通常比基于流的传输更高效
- 更高级的IO函数，zero-copy
- IO多路复用大大提高了Java网络应用的可伸缩性和实用性

从编程语言层面，BIO|NIO|AIO 以Java的角度，理解如下：

- BIO，同步阻塞式IO，简单理解：一个线程处理一个连接，发起和处理IO请求都是同步的
- NIO，同步非阻塞IO，简单理解：一个线程处理多个连接，发起IO请求是非阻塞的但处理IO请求是同步的
- AIO，异步非阻塞IO，简单理解：一个有效请求一个线程，发起和处理IO请求都是异步的

**BIO**

在JDK1.4之前，用Java编写网络请求，都是建立一个ServerSocket，然后，客户端建立Socket时就会询问是否有线程可以处理，如果没有，要么等待，要么被拒绝。即：一个连接，要求Server对应一个处理线程。

**NIO**

在Java里的由来，在JDK1.4及以后版本中提供了一套API来专门操作非阻塞I/O，我们可以在java.nio包及其子包中找到相关的类和接口。由于这套API是JDK新提供的I/O API，因此，也叫New I/O，这就是包名nio的由来。这套API由三个主要的部分组成：缓冲区(Buffers)、通道(Channels)和非阻塞I/O的核心类组成。在理解NIO的时候，需要区分，说的是New I/O还是非阻塞IO，New I/O是Java的包，NIO是非阻塞IO概念。这里讲的是后面一种。

NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。

NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。

**AIO**

与NIO不同，操作系统负责处理内核区/用户区的内存数据迁移和真正的IO操作，应用程序只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。

即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：

- AsynchronousSocketChannel
- AsynchronousServerSocketChannel
- AsynchronousFileChannel
- AsynchronousDatagramChannel

其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。

**实现原理**

说道实现原理，还要从操作系统的IO模型上了解

> 按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，按照POSIX标准来划分只分为两类：同步IO和异步IO。
>
> 如何区分呢？
>
> 首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。
>
> 同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。
>
> 阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。

可以理解的说明是：在Linux 2.6以后，java NIO的实现，是通过epoll来实现的，这点可以通过jdk的源代码发现。而AIO，在windows上是通过IOCP实现的，在linux上通过新的API来实现。

下面简要说明下五种IO模型：

- **BIO：**同步阻塞IO，阻塞整个步骤，如果连接少，它的延迟是最低的，因为一个线程只处理一个连接，适用于少连接且延迟低的场景，比如说数据库连接。
- **NIO：**同步非阻塞IO，阻塞业务处理但不阻塞数据接收，适用于高并发且处理简单的场景，比如聊天软件。
- **多路复用IO：**它的两个步骤处理是分开的，也就是说，一个连接可能他的数据接收是线程a完成的，数据处理是线程b完成的，他比BIO能处理更多请求。
- **信号驱动IO：**这种IO模型主要用在嵌入式开发，不参与讨论。
- **异步IO：**它的数据请求和数据处理都是异步的，数据请求一次返回一次，适用于长连接的业务场景。

参考：

1. https://www.cnblogs.com/diegodu/p/6823855.html
2. [Linux IO模式及 select、poll、epoll详解](https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000003063859)


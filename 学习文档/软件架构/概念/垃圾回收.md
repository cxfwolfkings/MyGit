# 垃圾回收

让应用程序代码负责释放内存是低级高性能的语言使用的技术，例如C++。这种技术很有效，并且一般情况下可以让资源在不需要时就释放，但其最大的缺点是频繁出现错误。请求内存的代码必须显式通知系统它什么时候不再需要该内存，这很容易被遗漏，从而导致内存泄漏。

维护引用计数是COM对象采用的一种技术，其方法是每个COM组件都保留一个计数，记录客户端目前对它的引用数。当这个计数下降到0 时，组件就会删除自己，并释放相关的内存和资源。

.NET运行库采用的方法是**垃圾回收器**，这是一个程序，其目的是清理内存。方法是：

> 所有动态请求的内存都分配到堆上（所有的语言都是这样处理的，但在.NET 中 CLR 维护它自己的托管堆，供 .NET 应用程序使用）。
>
> 每隔一段时间，当.NET 检测到给定进程的托管堆己满，需要清理时，就调用垃圾回收器。
>
> 垃圾回收器处理目前代码中的所有变量，检查对存储在托管堆上的对象的引用，确定哪些对象可以从代码中访问——即哪些对象有引用。没有引用的对象就不再认为可以从代码中访问，因而被删除。
>
> Java 也使用与此类似的垃极回收系统。

在对象创建后，垃圾回收器会从现有的应用程序内存池分配内存，如果有必要，还会增加内存池来满足内存分配。对象在创建后，只有一个引用是指向对象的。

随着代码的执行，垃圾回收器会跟踪对象的引用数量。每增加一个引用，计数器加1。当引用离开作用域后，计数器就减小。当引用计数器达到0 时，就将该对象和对象所占用的内存标记为回收。

为了提供高效的内存管理，垃圾回收(GC)的基本思路是：新创建的对象具有较短的生存期。这些对象会在托管堆的底部创建，随着对象老化，对象在generation阶梯上移。需要回收对象时，垃圾回收器会按照低到高的顺序扫描generation，因此最低的generation即generation 0被扫描的次数最多，而generation 2则扫描得最少。

**完全回收**

在完全回收周期中，程序会停止执行，进而扫描整个托管堆来查找根。

根可以有很多种情况，大部分时候根主要是堆栈变量以及包含对托管堆引用的全局对象。

GC可以自由地移动内存并安排地址而不会影响到正在执行的程序，而且GC会定位所有生存的和已经死亡的对象。将生存的对象上移一个generation，并回收死亡对象。回收的最后过程中有一部分涉及到了对托管堆的压缩与碎片整理。

由此可见，完全回收是很费时的？因此GC实现了一种部分回收的算法来提供最佳的性能。

**部分回收**

部分回收的前提是：generation 0中对象的生存期往往比generation 1中对象的短，generation阶梯上的情况以此类推。

GC会扫描根（对象指针）并判断哪些对象可以到达，哪些对象不可到达。在理想情况下，generation 0中的对象回收的频率要比generation 1中的高。因此，GC扫描generation 0的次数也要比扫描generation 1和2的次数多。

在进行部分回收时，与完全回收一样，都会先遍历根。但是会忽略老的对象，即Gen1或Gen2中的对象，而仅对Gen0中的根进行检查和回收。这里假设所有的老对象仍然是活跃的，因而推迟了完全回收的进行。

**工作方式**

Microsoft 通过对程序的研究分析，断定程度最大的搅拌（即快速分配与解除分配）往往发生在短期对象中，如临时变量、临时字符串、占位符以及小的工具类。简单地说，回收最频繁的是代0对象，并且回收代0对象耗费的时间也最少。

前述工作方式建立在老的对象仍然是活跃着的基础上。如果要精确判断何时对代1或2进行回收，那么就需要了解这些高级别代中的对象何时被修改。

这种“脏”标志的存储是通过名为牌桌(card table)的数据结构来实现的。牌桌就是一个位数组，每一位代表一个特定的内存段。在不同操作系统中，根据垃圾回收器实现方式的不同，每一位监视的内存大小也不同。当写入对象处在受牌桌监视的内存段中时，位标志转换，表示这一块内存被修改。

GC中实际的部分回收与之前讨论的一样，但有一点变化。当G0回收发生后，所有修改过的老对象（根据牌桌指示）将作为根来处理。然后会将这些根当作G0根进行遍历，并且再执行一次回收。

了解了垃圾回收器的工作方式后，就知道了为什么垃圾回收器会变慢。

垃圾回收器变慢最常见的原因是由于分配了太多东西，每次需要遍历的根越多，回收就会越慢。这时，甚至部分回收也不会节约时间，尤其是在代0对象中大量存在分配的时候。

因此在编写代码时要心中有数，将要进行多少分配。创建数组经常会生成不少可有可无的分配，视代码情况而定。

记住，垃圾回收器需要先遍历根来找出未使用的对象。需要检查的根越多，回收器需要的时间就越多。如果创建了一个很大的结构，并包含有大量引用（即指针），这样每一次运行回收时，回收器就需要查看每一个引用来判断哪些对象是活的，哪些对象已经死亡。

对于带有大量指针的大型结构，或需要垃圾回收器花费大量时间进行检查的某些结构，如果这种结构的生存期很长，那么可以使用完全回收。而如果这种大型结构生存期较短，不断回收同一个结构就会使垃圾回收器变慢，从而使程序也变慢。

如果方法中有很多对象指针，那么就要避免这些方法的深度递归。这种方法会生成大量的根（记住，根就是堆栈变量以及全局对象指针），G0回收时需要处理这些根。程序员往往会注意到，深度递归方法的执行时间很长，这是因为垃圾回收器要不断试着维持根分配。

如何保持根数量较少，如何使G1的尺寸不快速扩大？下面是 Microsoft 的几条准则：

- 只分配需要的对象，而且只在需要时进行分配。
- 在创建长生存期的对象时，使对象的尺寸尽可能小。
- 使堆栈中的对象指针尽可能少。

编写代码时尽可能做到：通过分析器运行代码，来显示垃圾回收器的活动。采用之前的建议，使代码对垃圾回收器更为友好。

![x](../../Resources/dotnet1.png)

C#对象，通常也就是`.NET Framework` 对象，与C++ 这类语言的对象之间的基本区别在于，析构函数与终结器的不同。析构函数(destructor)就是对象在销毁时调用的方法，并使用一个关键字，在C++中为delete。终结器(finalizer)则是在回收过程中由垃圾回收器调用的方法。

要注意，使用终结器是有代价的。如果在类中实现了一个终结器，那么将对象设为空，或当对象跳出作用域时，该终结器并不会被调用，而会在接下来合适的回收阶段时才调用。

当垃圾回收器遇到具有终结器的对象时，就会停止回收该对象，然后把该对象放到一个列表中，之后再处理。

这时就有问题了，因为在回收时，终结器中所有的对象引用都会保留下来。对象终结器中引用的所有对象，无论是直接还是间接的，都会继续生存直到对象被回收。如果对象到了G2中，那么就会需要非常长的时间来回收。事实上，根据应用程序运行时间的长短，对象很有机会直到应用程序退出之前都不会被回收。

这里有一个解决办法：如果对象必须使用一个终结器，那么如果对象实现了IDisposable接口就在代码中调用Dispose方法，这样可以让垃圾回收器跳过对该对象的正常回收过程。基本上，这样就可以让对象终结自身，而不会给垃圾回收器增加负担。

IDisposable有不少优点。首先在需要终结的类中实现这个接口可以手动终结，不至于使垃圾回收器因终结操作而变慢。其次是C#中包含了using 关键字，更容易创建使用IDisposable对象的代码块，也更容易阅读。在完成using块中的代码之后，using语句定义的对象都会调用其Dispose方法，甚至当语句块中出现异常时也一样。

由于垃圾回收器在决定何时回收对象和运行析构函数方面可以有很大的选择范围，“符合销毁条件”和“符合回收条件”之间的区别虽然微小，但也许非常重要。例如：

```C#
using System;

class A
{
    ~A()
    {
        Console.WriteLine("Destruct instance of A");
    }

    public void F()
    {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;
    ~B()
    {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main()
    {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;
        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();
        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

在上面的程序中，如果垃圾回收器选择在B的析构函数之前运行A的析构函数，则该程序的输出可能是：

```sh
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

虽然A的实例没有使用，并且A的析构函数已被运行过了，但仍可能从其他析构函数调用A的方法（此例中是指F）。还请注意，运行析构函数可能导致对象再次从主干程序中变得可用。在此例中，运行B的析构函数导致了先前没有被使用的A的实例变得可从当前有效的引用Test.RefA访问。调用WaitForPendingFinalizers后，B的实例符合回收条件，但由于引用Test.RefA的缘故，A的实例不符合回收条件。

为了避免混淆和意外的行为，好的做法通常是让析构函数只对存储在它们对象本身字段中的数据执行清理，而不对它所引用的其他对象或静态字段执行任何操作。

关于GC，经常有围绕**非确定终止**这个话题展开的热门讨论。本质上，非确定终止是指无法确切得知某个对象被回收的时间。乍一看这似乎并不是一个重要的论题？然而，考虑到要处理宝贵的资源如数据库连接、套接字连接及图形资源？这就是个大问题了。

在创建包含重要资源的对象时，比如创建数据库连接，.NET 也可以使用IDisposable的概念。

**垃圾收集的优势**

- 在开发应用程序时，不需要手动释放内存。
- 它还有效地在托管堆上分配对象。
- 当对象不再使用时，它将通过清除内存来回收这些对象，并将内存保留为将来的分配。
- 托管对象自动获得干净的内容，所以它们的构造函数不必初始化每个数据字段。
- 它还通过确保对象不能使用其他对象的内容来提供内存安全性。

**垃圾收集的条件**

- 当系统的物理内存较低时。
- 托管堆上分配的对象使用的内存超过了可接受的阈值。该阈值在流程运行时不断调整。
- GC.Collect方法被调用，在几乎所有情况下，不必调用此方法，因为垃圾收集器连续运行。这种方法主要用于独特的情况和测试。

**阶段过程**

.NET垃圾收集器有3代，每一代都有自己的堆，用于存储分配的对象。有一个基本的原则，判定大多数对象是短暂的还是长期的。

1. 第一代(0)

   在第0代中，首先分配对象。

   在这一代，对象通常不会超越第一代，因为在下一次垃圾收集时，它们不再被使用（超出范围）。

   0代很快收集，因为它相关的堆很小。

2. 第二代(1)

   在第一代，对象有第二个机会空间。

   在第0代收集（通常是基于巧合的时机）下寿命很短的对象会转到第1代。

   第一代集合也很快，因为它的关联堆也很小。

   前两堆仍然很小，因为对象被收集或提升到下一代堆。

3. 第三代(2)

   在第二代，所有的长对象都是活动的，它的堆可以长得很大。

   这一代的对象可以长期存活下去，没有下一代堆积对象可以进一步推广。

垃圾收集器有一个额外的堆，用于称为大对象堆(LOH)的大型对象。它保留85,000字节或更大的对象。大对象并没有分配到代代堆，而是直接分配给了LOH

第二代和LOH收集可能会花费很长时间来处理运行大量数据的程序。已知大型服务器程序在十几个GB中堆积如山。

GC采用各种技术来减少阻止程序执行的时间。主要方法是在后台线程上尽可能多地执行垃圾回收工作，而不会干扰程序执行。

GC还为开发人员提供了一些方法来影响其行为，这对提高性能非常有用。
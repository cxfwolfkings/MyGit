# 并发编程

1. 异步编程
2. 多线程 & 线程安全
3. 一致性、事务
   - 事务ACID特性
   - 事务的隔离级别
   - MVCC
4. [锁](#锁)
   - [并发问题与解决](#并发问题与解决)
   - 公平锁 & 非公平锁
   - 乐观锁 & 悲观锁 & CAS
   - ABA问题
   - CopyOnWrite容器
   - RingBuffer
   - 可重入锁 & 不可重入锁
   - 互斥锁 & 共享锁
   - 死锁
   - 同步类 & 原子类



### 为什么需要并行?

1. 业务要求
2. 性能

反对意见：

- Linus Torvalds：忘掉那该死的并行吧！

- 需要有多么奇葩的想象力才能想象出并行计算的用武之地？
- 并行计算只有在 **图像处理** 和 **服务端编程** 2个领域可以使用，并且它在这2个领域确实有着大量广泛的使用。但是在其它任何地方，并行计算毫无建树！

![x](E:/WorkingDir/Office/Resources/Linus.png)

摩尔定律的失效

- 预计18个月会将芯片的性能提高一倍
- Intel CEO Barret 单膝下跪对取消 4GHz 感到抱歉。在2004年秋季，Intel宣布彻底取消 4GHz 计划。
- 虽然现在已经有了 4GHz 的芯片，但频率极限已经逼近
- 10年过去了，我们还停留在**4GHz**

![x](E:/WorkingDir/Office/Resources/Barret.png)

顶级计算机科学家唐纳德·尔文·克努斯

- 在我看来，这种现象（并发）或多或少是由于硬件设计者已经无计可施了导致的，他们将摩尔定律失效的责任推脱给软件开发者。

![x](E:/WorkingDir/Office/Resources/Donald.png)

并行计算还出于 **业务模型** 的需要。并不是为了提高系统性能，而是确实在业务上需要多个执行单元。比如HTTP服务器，为每一个 Socket 连接新建一个处理线程，让不同线程承担不同的业务工作，简化任务调度！



### 同步、异步、并发、并行概念 

1、同步(synchronous)和异步(asynchronous)

![x](E:/WorkingDir/Office/Resources/sync.png)

2、并发(Concurrency)和并行(Parallelism)

![x](E:/WorkingDir/Office/Resources/parall.png)

3、临界区

临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。

![x](E:/WorkingDir/Office/Resources/limit.png)

4、阻塞(Blocking)和非阻塞(Non-Blocking)

阻塞和非阻塞通常用来形容多线程间的相互影响。

比如一个线程占用了临界区资源，那么其它所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。

非阻塞允许多个线程同时进入临界区

5、死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)

饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。例如：电梯遇人

![x](E:/WorkingDir/Office/Resources/car.png)

6、并行的级别

- 阻塞：当一个线程进入临界区后，其他线程必须等待

- 非阻塞：
  - 障碍(Obstruction-Free)：无障碍是一种最弱的非阻塞调度，自由出入临界区
    无竞争时，有限步内完成操作；有竞争时，回滚数据
  - 无锁(Lock-Free)：是无障碍的，保证有一个线程可以胜出

```
while (!atomicVar.compareAndSet(localVar, localVar+1)) {
    localVar = atomicVar.get();
}
```

- 无等待(Wait-Free)：无锁的，要求所有的线程都必须在有限步内完成，无饥饿的



### 有关并行的2个重要定律

**Amdahl定律（阿姆达尔定律）**

![x](E:/WorkingDir/Office/Resources/Amdahl.jpg)

**Gustafson定律（古斯塔夫森）**

![x](E:/WorkingDir/Office/Resources/Gustafson.jpg)



## 锁

在多线程并发场景下，为了保证共享资源在同一时刻只能被同一个线程操作，需要对共享资源进行互斥控制，即加锁。对单进程应用而言，部分编程语言内置的锁机制便足以保证并发安全，如 Java 语言可用 `synchronized` 和 `Lock` 来实现锁。然而，由于分布式系统多线程、多进程并且分布在不同节点，需要一种 **跨进程** 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。

## 并发问题与解决

**原子性问题：**

所谓原子性，指的是一个操作不可中断，即在多线程并发的环境下，一个操作一旦开始，就会在同一个 CPU 时间片内执行完毕。如果同一个线程的多个操作在不同的 CPU 时间片上执行，由于中间出现停滞，后面的操作在执行时可能因某个共享数据被其它线程修改，而该修改并未同步到当前线程中，导致当前线程操作的数据与实际不符，这种由于执行不连贯导致的数据不一致问题被称作原子性问题。

**可见性问题：**

可见性问题的出现与线程访问共享数据的方式有关。线程访问堆（方法区）中的变量时，先在栈中建立一个变量的副本，修改后再同步到堆中。如果一个线程刚建立副本，这时另一线程修改了变量，尚未同步到堆中，这时就会出现两个线程操作同一变量的同一种状态的现象，比如 i=9，变量 i 的初始值为9，每一个线程的操作都是减1。两个线程 A 与 B 同时访问变量，B 先执行 i-1，在将结果 i=8 同步到堆中前，A 线程也执行 i-1，这时 i=9 的状态就被执行两次，出现线程安全问题。

>线程安全问题产生的原因在于一个线程对共享数据的修改不能立即为其它线程所见。

**有序性问题：**

为了提高执行效率，CPU 会对那些没有依赖关系的指令重新排序，重新排序后的执行结果与顺序执行结果相同。例如，在源代码中：

```java
int a=0;
int b=1;
```

CPU 在执行时可能先执行 `int b=1;`，接着执行 `int a=0;`，执行结果与顺序执行结果相同。指令重排在单线程环境下是安全的，在多线程环境下就可能出现问题。比如下面这个例子。

线程 A：

```java
String str = "hello world!";//指令1
boolean flag = false;//指令2
```

线程 B：

```java
while(flag)
{
    doSome();
}
str.toUpperCase();//指令3
```

如果线程 A 顺序执行，即执行指令1，再执行指令2，线程 B 的执行不会出现问题。指令重排后，假如线程 A 先执行指令2，这时 `flag=false`，切换到线程 B，终止循环，执行指令3，由于 str 对象尚未创建就会出现空指针异常。

上面 3 个问题都是多线程并发场景中的常见问题，其根源在于：**对共享资源的争夺**。

>为了解决这类问题，Java 提供了很多策略，如 `volatile` 关键字，可以 **禁止指令重排**，从而避免有序性的问题；对于原子性问题和可见性问题，在高并发场景下，为了保证共享资源在同一时刻只能被同一个线程执行，需要对公共资源进行 **互斥控制**，即 **加锁**。
>
>Java 提供了两种内置的锁的实现：由 JVM 实现的 `synchronized` 和 JDK 提供的 `Lock`，对于单进程应用来说，使用 `synchronized` 或 `Lock` 来实现锁，足以保证并发安全。
>
>`synchronized` 本质上是通过锁来实现的。对于同一个代码块，为了实现多个线程在一个时刻只能有一个线程执行，需要在某个地方做个标记，每个线程都必须能看到它。当标记不存在时，某个线程可以设置该标记，其余后续线程发现已经有标记了，则等待拥有标记的线程结束同步代码块取消标记后，再去尝试设置标记。这个标记可以理解为锁。
>
>不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如 Java 中 `synchronize` 是在对象头设置标记；`Lock` 接口的实现类的基本思想是，用一个 `volitile` 修饰的 int 型变量，保证每个线程都能拥有对该 int 的可见性和原子修改。

从上面的分析可以看出，Java 提供的两种锁机制有效的前提是：**同一个进程内有效**。但是，随着业务发展，原单机部署的系统被演化成分布式系统后，由于分布式系统多线程、多进程并且分布在不同物理机上，这将使原单机部署情况下的并发控制锁策略失效。为了解决这个问题，就需要一种 **跨进程的互斥机制** 来控制共享资源的访问，这就是分布式锁要解决的问题。

实现分布式锁需要依赖一个第三方系统，此系统需要满足高可用和较强的一致性，同时能应付高并发的请求。常见的分布式锁实现方式有三种：**数据库**、**缓存**、**分布式协调系统**。
# 应用服务器

1. Apache
2. Tomcat
3. [IIS](#IIS)
   - [常见问题](#常见问题)



为什么要安装web服务器，和怎样去了解发送和接受到什么？因为我们浏览器要取的数据是从web服务器获取的。我们可以通过httpwatch工具来获取发送和接收到的数据，用利于我们了解的更加透彻。

- Lighttpd 是一个德国人领导的开源Web服务器软件，其根本的目的是提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的web server环境。具有非常低的内存开销、cpu占用率低、效能好以及丰富的模块等特点。

- Nginx ("engine x")是一个高性能的HTTP和[反向代理](http://baike.baidu.com/view/1165595.htm)服务器，也是一个IMAP/POP3/SMTP[代理服务器](http://baike.baidu.com/view/751.htm)。Nginx 是由Igor Sysoev为[俄罗斯](http://baike.baidu.com/view/2403.htm)访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将[源代码](http://baike.baidu.com/view/60376.htm)以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低[系统资源](http://baike.baidu.com/view/53557.htm)的消耗而闻名。2011年6月1日，Nginx 1.0.4发布，支持50000并发。Nginx摒弃了多线程的方式，采用和Node相同的事件驱动，大有取代Apache之势。

- IIS是微软提供的一种服务器

- JBoss是RedHat的一个开源重量级的Java Web服务器

- WebSphere: IBM公司

- WebLogic: BEA公司

## Apache

**Why**

The Apache HTTP Server Project is an effort to develop and maintain an open-source HTTP server for modern operating systems including UNIX and Windows. The goal of this project is to provide a secure, efficient and extensible server that provides HTTP services in sync with the current HTTP standards.

**What**

The Apache HTTP Server ("httpd") was launched in 1995 and it has been the most popular web server on the Internet since April 1996. It has celebrated its 20th birthday as a project in February 2015.

The Apache HTTP Server is a project of [The Apache Software Foundation](http://www.apache.org/).

**How**

 

**Referance**

- https://httpd.apache.org

- Docker教程：http://www.runoob.com/docker/docker-tutorial.html



### 开源协议

**BSD开源协议**

BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：

- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。

- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。

- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。

BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销 售，因此是对商业集成很友好的协议。很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。

**开源项目**

几种知名富文本框编辑器：

https://www.cnblogs.com/linkstar/p/6858995.html

### 基础介绍 



![x](D:\WorkingDir\Office\Resources\image-20201216082218632.png)

运行机制图：

![x](D:\WorkingDir\Office\Resources\image-20201216082435400.png)

- mpm: mutil processing module 多重处理模块

- apr: 可移植运行库         

**虚拟目录**

Apache安装在C盘，但是C盘没有空间，D盘有更多空间，能不能把D盘的一个文件夹下的网页当做网站管理？看看如何完成这个功能：

**1. 添加虚拟目录的节点**

```xml
# 配置虚拟目录
<IfModule dir_module>
  # direcotory相当于是欢迎页面
  DirectoryIndex index.html index.htm index.php
  # 你的站点别名
  Alias /myblog "D:/myblog"
  <Directory d:/myblog>
    # 这是访问权限设置
    Order allow,deny
    Allow from all
  </Directory>
</IfModule>
```



**2****、注销****documentroot****路径**

\#DocumentRoot "C:/Program Files/Apache Software Foundation/Apache2.2/htdocs"

**3****、测试**

http://localhost/myblog/news.html

**4****、如何设置欢迎页面**

http://localhost/myblog/

DirectoryIndex news.html index.html index.htm index.php

**5****、关于****apache****访问权限的讲解**

 

**虚拟主机**

在httpd.conf文件中配置一台www.sohu.cn的虚拟主机，然后在window系统中注册www.sohu.cn这台主机。

配置虚拟主机的步骤如下:

1、启用httpd-vhosts.conf

在 httpd.conf文件中 

\# Virtual hosts，虚拟主机

Include conf/extra/httpd-vhosts.conf

2、在httpd-vhosts.conf文件中做配置

\#配置我们自己的虚拟主机

<VirtualHost 127.0.0.1:80>

   DocumentRoot "d:/myblog"

   \#这里配置欢迎首页面 

   DirectoryIndex index.html index.htm index.php

   <Directory>

​    Options FollowSymLinks

​      \#不许可别人修改我们的页面

​       AllowOverride None

​    \#设置访问权限

​    Order allow,deny

​    Allow from all

   </Directory>

</VirtualHost>

3、修改hosts文件

127.0.0.1 http://www.sohu.com

 

1 分钟前 上传

[下载附件 (58.29 KB)](http://bbs.itcast.cn/forum.php?mod=attachment&aid=MjQxNXxkNzBhZDUyNnwxMzUwODk1NDc0fDExfDQ3NzI=&nothumb=yes) 

 

 

 

[**Tomcat**](http://www.cnblogs.com/-sixgod/p/5817835.html)

免费、开源的Java Web服务器 

**设置端口号**

<Connector port**=**"**8080**" protocol**=**"HTTP/1.1"

​        connectionTimeout**=**"**20000**"

​        redirectPort**=**"**8443**" URIEncoding**=**"UTF-8" />

**设置域名**

```
    <Engine name="Catalina" defaultHost="localhost">
       <Host name="localhost"  appBase="webapps"
```

​       unpackWARs**=**"true" autoDeploy**=**"true">

   <Engine **name=**"Catalina" defaultHost**=**"nielsenecom.com">

​     <Host **name=**"nielsenecom.com" appBase**=**"webapps"

​      unpackWARs**=**"true" autoDeploy**=**"true">

**设置虚拟主机**

<Engine **name=**"Catalina" defaultHost**=**"ren">

  <Host **name=**"www.baidu.com" appBase**=**"webapps/ren"/>

  <Host **name=**"www.google.com" appBase**=**"webapps/stimpy"/> 

</Engine>

 

 

 

**远程访问设置**

前提是你已经配好了tomcat_user.xml,server.xml,context.xml

那么要配置远程访问的manager

tomat_home/conf/Catalina/localhost/下  添加manager.xml

<Context privileged="true" antiResourceLocking="false" 

​     docBase="${catalina.home}/webapps/manager"> 

​       <Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="^.*$" /> 

</Context>

属性allow是ip限制，可以改成这样 allow="127.0.0.1,192.168.1.*"

意思是只允许本机和192.168.1.*的IP访问。

另外，host-manager/META-INF/context.xml默认只可以本机访问。需要修改allow属性值其他地址才可以访问。

**并发设置**

url： http://blog.sina.com.cn/s/blog_605f5b4f01012ljj.html

tomcat 的Connector配置如下

<Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443"

maxThreads="800" acceptCount="1000"/>

  其中最后两个参数意义如下：

**maxThreads**：tomcat起动的最大线程数，即同时处理的任务个数，默认值为200

**acceptCount**：当tomcat起动的线程数达到最大时，接受排队的请求个数，默认值为100

  **这两个值如何起作用，请看下面三种情况**

情况1：接受一个请求，此时tomcat起动的线程数没有到达maxThreads，tomcat会起动一个线程来处理此请求。

情况2：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，tomcat会把此请求放入等待队列，等待空闲线程。

情况3：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，等待队列中的请求个数也达到了acceptCount，此时tomcat会直接拒绝此次请求，返回connection refused

**maxThreads****如何配置**

一般的服务器操作都包括量方面：1计算（主要消耗cpu），2等待（io、数据库等）

第一种极端情况，如果我们的操作是纯粹的计算，**那么系统响应时间的主要限制就是****cpu****的运算能力，此时****maxThreads****应该尽量设的小，降低同一时间内争抢****cpu****的线程个数，**可以提高计算效率，提高系统的整体处理能力。

第二种极端情况，**如果我们的操作纯粹是****IO****或者数据库，那么响应时间的主要限制就变为等待外部资源，此时****maxThreads****应该尽量设的大，这样** **才能提高同时处理请求的个数，从而提高系统整体的处理能力。**此情况下因为tomcat同时处理的请求量会比较大，所以需要关注一下tomcat的虚拟机内存设置和linux的open file限制。

我在测试时遇到一个问题，**maxThreads**我设置的比较大比如3000，当服务的线程数大到一定程度时，一般是2000出头，单次请求的响应时间就会急剧的增加，

百思不得其解这是为什么，四处寻求答案无果，最后我总结的原因可能是**cpu****在线程切换时消耗的时间随着线程数量的增加越来越大，**

cpu把大多数时间都用来在这2000多个线程直接切换上了，当然cpu就没有时间来处理我们的程序了。

以前一直简单的认为多线程=高效率。。其实多线程本身并不能提高cpu效率，线程过多反而会降低cpu效率。

当cpu核心数<线程数时，cpu就需要在多个线程直接来回切换，以保证每个线程都会获得cpu时间，即通常我们说的并发执行。

所以**maxThreads**的配置绝对不是越大越好。

现实应用中，我们的操作都会包含以上两种类型（计算、等待），所以maxThreads的配置并没有一个最优值，一定要根据具体情况来配置。

最好的做法是：在不断测试的基础上，不断调整、优化，才能得到最合理的配置。

**acceptCount****的配置**，我一般是设置的跟maxThreads一样大，这个值应该是主要根据应用的访问峰值与平均值来权衡配置的。

**如果设的较小，可以保证接受的请求较快相应，但是超出的请求可能就直接被拒绝**

**如果设的较大，可能就会出现大量的请求超时的情况，因为我们系统的处理能力是一定的。**

最近一直在解决线上一个问题，表现是：

Tomcat每到凌晨会有一个高峰，峰值的并发达到了3000以上，最后的结果是Tomcat线程池满了，日志看很多请求超过了1s。

服务器性能很好，Tomcat版本是7.0.54，配置如下：

<Executor name="tomcatThreadPool" namePrefix="catalina-exec-"

​    maxThreads="3000" minSpareThreads="800"/>

 

  <Connector executor="tomcatThreadPool" port="8084" protocol="org.apache.coyote.http11.Http11AprProtocol"

​        connectionTimeout="60000"

​        keepAliveTimeout="30000"

​        maxKeepAliveRequests="8000"

​        maxHttpHeaderSize="8192"

​        URIEncoding="UTF-8"

​        enableLookups="false"

​        acceptCount="1000"

​        disableUploadTimeout="true"

​        redirectPort="8443" />

事后thread dump看其实真正处于RUNNABLE状态的线程很少，绝大部分线程都处于TIMED_WAITING状态：

![image-20201216082502545](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082502545.png)

于是大伙都开始纠结为什么线程会涨到3000，而且发现即使峰值过了线程数并不会降下来。

我们首先想到的是：

后端应用的处理瞬间比较慢，“堵住了”导致前端线程数涨了起来。

但是优化一个版本上线后发现虽然涨的情况有所好转，但是最终线程池还是会达到3000这个最大值。

以上是大背景，中间的过程省略，直接跟各位说下目前我得到的结论：

1、首先是为什么线程不释放的问题？

简单说下我验证的Tomcat(7.0.54)线程池大概的工作机制

·    Tomcat启动时如果没有请求过来，那么线程数（都是指线程池的）为0；

·    一旦有请求，Tomcat会初始化minSapreThreads设置的线程数；

·    Tomcat不会主动对线程池进行收缩，除非确定没有任何请求的时候，Tomcat才会将线程池收缩到minSpareThreads设置的大小；

·    Tomcat6之前的版本有一个maxSpareThreads参数，但是在7中已经移除了，所以只要前面哪怕只有一个请求，Tomcat也不会释放多于空闲的线程。

至于Tomcat为什么移除maxSpareThreads这个参数，我想也是出于性能的考虑，不停的收缩线程池性能肯定不高，而多余的线程处于等待状态的好处是一有新请求过来立刻可以处理。

·    而且大量的Tomcat线程处于等待状态不会消耗CPU，但是会消耗一些JVM存储。

  补充：上面标红的一句有点问题，进一步验证发现只有使用Keep-Alive（客户端和服务端都支持）时才是这种表现，如果客户端没有使用Keep-Alive那么线程会随着TCP连接的释放而回收。

Tomcat中Keep-Alive相关的参数：

maxKeepAliveRequests:

The maximum number of HTTP requests which can be pipelined until the connection is closed by the server. Setting this attribute to 1 will disable HTTP/1.0 keep-alive, as well as HTTP/1.1 keep-alive and pipelining. Setting this to -1 will allow an unlimited amount of pipelined or keep-alive HTTP requests. If not specified, this attribute is set to 100.

keepAliveTimeout:

The number of milliseconds this Connector will wait for another HTTP request before closing the connection. The default value is to use the value that has been set for the connectionTimeout attribute. Use a value of -1 to indicate no (i.e. infinite) timeout. 

2、为什么线程池会满？

这是我现在纠结的核心。到底是不是应用的性能慢导致的，我现在的结论是有关系，但关键是并发。

·    Tomcat的线程池的线程数跟你的瞬间并发有关系，比如maxThreads设置为1000，当瞬间并发达到1000那么Tomcat就会起1000个线程来处理，这时候跟你应用的快慢关系不大。

那么是不是并发多少Tomcat就会起多少个线程呢？这里还跟Tomcat的这几个参数设置有关系，看官方的解释是最靠谱的：

maxThreads:

The maximum number of request processing threads to be created by this Connector, which therefore determines the maximum number of simultaneous requests that can be handled. If not specified, this attribute is set to 200. If an executor is associated with this connector, this attribute is ignored as the connector will execute tasks using the executor rather than an internal thread pool.

maxConnections:

The maximum number of connections that the server will accept and process at any given time. When this number has been reached, the server will accept, but not process, one further connection. This additional connection be blocked until the number of connections being processed falls below maxConnections at which point the server will start accepting and processing new connections again. Note that once the limit has been reached, the operating system may still accept connections based on the acceptCount setting. The default value varies by connector type. For BIO the default is the value of maxThreads unless an [Executor](http://tomcat.apache.org/tomcat-7.0-doc/config/executor.html) is used in which case the default will be the value of maxThreads from the executor. For NIO the default is 10000. For APR/native, the default is 8192. ……

acceptCount:

The maximum queue length for incoming connection requests when all possible request processing threads are in use. Any requests received when the queue is full will be refused. The default value is 100.

minSpareThreads:

The minimum number of threads always kept running. If not specified, the default of 10 is used.

我简单理解就是：

maxThreads:Tomcat线程池最多能起的线程数；

maxConnections:Tomcat最多能并发处理的请求（连接）；

acceptCount:Tomcat维护最大的对列数；

minSpareThreads:Tomcat初始化的线程池大小或者说Tomcat线程池最少会有这么多线程。

比较容易弄混的是maxThreads和maxConnections这两个参数：

maxThreads是指Tomcat线程池最多能起的线程数，而maxConnections则是Tomcat一瞬间最多能够处理的并发连接数。比如maxThreads=1000，maxConnections=800，假设某一瞬间的并发是1000，那么最终Tomcat的线程数将会是800，即同时处理800个请求，剩余200进入队列“排队”，如果acceptCount=100，那么有100个请求会被拒掉。

注意：根据前面所说，只是并发那一瞬间Tomcat会起800个线程处理请求，但是稳定后，某一瞬间可能只有很少的线程处于RUNNABLE状态，大部分线程是TIMED_WAITING，如果你的应用处理时间够快的话。所以真正决定Tomcat最大可能达到的线程数是maxConnections这个参数和并发数，当并发数超过这个参数则请求会排队，这时响应的快慢就看你的程序性能了。

实际设置：

修改连接器协议，默认是HTTP/1.1，该默认设置不能支持过高的并发量，不然会出现io错误。方法是修改conf/server.xml将<Connector port="8080" protocol="HTTP/1.1"修改为**<Connector**port="8080"protocol="org.apache.coyote.http11.Http11NioProtocol"

优化jar包，如果一个jar文件出现在多个WEB应用中的话，可以将该jar文件统一放到一个目录下，以 避免被tomcat 多次加载，耗用内存占用。方法是：

修改：/conf/catalina.properties文件，将：

common.loader="${catalina.base}/lib","${catalina.base}/lib/*.jar","${catalina.home}/lib","${catalina.home}/lib/*.jar"后面增加："${catalina.home}/share/lib/*.jar"

然后将共用的jar文件放到tomcat下share目录里的lib文件夹里即可。

tomcat8默认会缓存图片资源，当并发过高时，会提示warn信息： WARNING [http-nio-80-exec-43] org.apache.catalina.webresources.Cache.getResource Unable to add the resource at.....，这个本身没有什么问题，只是不断在日志中写入信息，日志文件不断增加，感觉不好，干脆设置不缓存，方法是：

修改META-INF下的context.xml文件，在Context中增加一行：

<Resources cachingAllowed="false"></Resources>

设置jvm较大内存，编辑bin/catalina.bat，找到以下代码段：rem Guess CATALINA_HOME if not defined，在其上面增加代码：

set JAVA_OPTS=-Xms512m -Xmx4096m -XX:PermSize=128M -XX:MaxPermSize=256m

这里设置的Xmx为4G内存，如果安装的不是64位的JDK，那么在设置最大内存的时候，就会提示不支持(好像最多能设置到1G多点，要知道服务器内存是64G啊，!!!)。所以第一步为什么安装64位的操作系统了。

设置tomcat最大并发数，方法：修改conf/server.xml，在Connector下增加以下代码：maxThreads="1000" minSpareThreads="100" maxSpareThreads="300" acceptCount="100" 

以下是我的配置：

**<Connector** port="80" protocol="org.apache.coyote.http11.Http11NioProtocol" 

connectionTimeout="20000" maxThreads="1000" minSpareThreads="100" 

maxSpareThreads="300" acceptCount="100"  

  redirectPort="8443" URIEncoding="GBK" useBodyEncodingForURI="true" **/>** 

因为大多数时候JSP程序都是部署在linux下，没有想到windows下会有这么多问题，以上是经过测试后的时候，网站在高访问量下没有再出问题。另外经过测试在windows服务器下，使用apache+tomcat集成的方法也不好。对于并发的连接数支持还不如纯tomcat。

**安全设置**

[**配置****Tomcat****使用****https****协议（配置****SSL****协议**](http://blog.csdn.net/jimmy609/article/details/18557955)**）**

Tomcat既可以作为独立的Servlet容器，也可以作为其他HTTP服务器附加的Servlet容器。如果Tomcat在非独立模式下工作，通常不必配置SSL，由它从属的HTTP服务器来实现和客户的SSL通信。Tomcat和HTTP服务器之间的通信无须采用加密机制，HTTP服务器将解密后的数据传给Tomcat，并把Tomcat发来的数据加密后传给客户。

如果Tomcat作为独立的Java Web服务器，则可以根据安全需要，为Tomcat配置SSL，它包含以下两个步骤：

（1） 准备安全证书。

（2） 配置Tomcat的SSL连接器（Connector）。

#### A、准备安全证书

获得安全证书有两种方式：一种方式是到权威机构购买，还有一种方式是创建自我签名的证书。这里就介绍第二种获取证书的方式，毕竟免费的嘛！

SUN公司提供了制作证书的工具keytool。在JDK 1.4以后的版本中都包含了这一工具，它的位置为<JAVA_HOME>\bin\keytool.exe。

通过keytool工具创建证书的命令为：

keytool -genkeypair -alias "tomcat" -keyalg "RSA" -keystore "f:\tomcat.keystore"

以上命令将生产一对非对称密钥和自我签名的证书，这个命令中几个参数的意思如下：

| genkeypair | 生成一对非对称密钥               |
| ---------- | -------------------------------- |
| alias      | 指定密钥对的别名，该别名是公开的 |
| keyalg     | 指定加密算法                     |
| keystore   | 证书保存路径                     |

##### A.1 准备服务端证书

![image-20201216082608310](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082608310.png)

首先会提示输入keystore的密码。然后提示输入个人信息，如姓名、组织单位和所在城市等，直接回车即可。接着会提示输入信息是否正确，输入"y"表示信息正确。最后要求输入<Tomcat>的主密码，这里设置与keystore相同的密码，因此只需根据提示按回车键即可。也可以用一条语句执行：

keytool -genkey -v -alias tomcat -keyalg RSA -keystore D:/downloads/tomcat.keystore -dname "CN=192.168.1.1,OU=logiscn,O=logis,L=beijing,ST=beijing,C=CN" -validity 3650 -storepass logiscn -keypass logiscn 

如果Tomcat所在服务器的域名不是"localhost"，应改为对应的域名或者IP地址，否则浏览器会弹出警告窗口，提示用户证书与所在域不匹配。

##### A.2 准备客户端证书

  单向验证时跳过这步

###### A.2.1 生成客户端证书

为了能将证书顺利导入至IE和Firefox，证书格式应该是PKCS12，因此，使用如下命令生成：

![image-20201216082623972](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082623972.png)

也可以用一条语句执行：

keytool -genkey -v -alias tianli -keyalg RSA -storetype PKCS12 -keystore D:/downloads/p12/tianli.p12 -dname "CN=tianli,OU=logiscn,O=logis,L=beijing,ST=beijing,C=CN" -validity 3650 -storepass tianli -keypass tianli"

###### A.2.2 安装客户端证书

双击客户端证书“client.key.p12”完成导入证书过程如下：

![image-20201216082637704](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082637704.png)

![image-20201216082643899](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082643899.png)

![image-20201216082649663](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082649663.png)

![image-20201216082656029](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082656029.png)

![image-20201216082703243](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082703243.png)

![image-20201216082708193](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082708193.png)

![image-20201216082715392](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082715392.png)

##### A.3 让服务器信任客户端证书

如果是双向SSL认证，服务器必须要信任客户端证书，因此，必须把客户端证书添加为服务器的信任认证。由于不能直接将PKCS12格式的证书库导入，我们必须先把客户端证书导出为一个单独的CER文件，使用如下命令：

keytool -export -alias tianli -keystore D:/downloads/p12/tianli.p12 -storetype PKCS12 -storepass tianli -rfc -file D:/downloads/cert/tianli.cer

通过以上命令，客户端证书就被我们导出到"D:/downloads/cert/tianli.cer r"文件了。

![image-20201216082739676](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082739676.png)

下一步，是将该文件导入到服务器的证书库，添加为一个信任证书：

keytool -import -alias tianli -v -file D:/downloads/cert/tianli.cer -keystore D:/downloads/tomcat.keystore -storepass logiscn <myint.inf

由于在导入的过程中需要输入Y或者N，在此处直接使用一个文件myint.inf代替输入，myint.inf是一个文本文件，里面的内容只有 Y 和一个回车。

![image-20201216082749991](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082749991.png)

通过list命令查看服务器的证书库，我们可以看到两个输入，一个是服务器证书，一个是受信任的客户端证书：

keytool -list -keystore D:\tomcat.keystore (tomcat为你设置服务器端的证书名)。

![image-20201216082800883](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082800883.png)

##### A.4 让客户端信任服务器证书

###### A.4.1 把服务器证书导出为CER文件

如果是双向SSL认证，客户端也要验证服务器证书，因此，必须把服务器证书添加到浏览的“受信任的根证书颁发机构”。由于不能直接将keystore格式的证书库导入，必须先把服务器证书导出为一个单独的CER文件，使用如下命令：

keytool -keystore D:\home\tomcat.keystore -export -alias tomcat -file D:\home\tomcat.cer (tomcat为你设置服务器端的证书名)。

![image-20201216082819097](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082819097.png)

###### A.4.2 在客户端安装服务器证书

双击“tomcat.cer”，按照提示安装证书，将证书填入到“受信任的根证书颁发机构”。

![image-20201216082831761](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082831761.png)

![image-20201216082839758](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082839758.png)

![image-20201216082845530](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082845530.png)

![image-20201216082850629](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082850629.png)

![image-20201216082856649](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082856649.png)

![image-20201216082902092](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082902092.png)

![image-20201216082907289](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082907289.png)

**A.4.3** **检查安装结果**

IE -> Internet选项 -> 内容 -> 证书

![image-20201216082919945](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216082919945.png)

#### B、配置Tomcat服务器

**<Connector** port="8443" protocol="HTTP/1.1" SSLEnabled="true" 

​      maxThreads="150" scheme="https" secure="true" 

​      clientAuth="false" sslProtocol="TLS" 

​      keystoreFile="D:\\tomcat.keystore" keystorePass="888888" 

​      truststoreFile="D:\\tomcat.keystore" truststorePass="888888" **/>** 

注意服务端证书名保持一致

属性说明：

| 属性           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| clientAuth     | 设置是否双向验证，默认为false，设置为true代表双向验证。如果设置为"want"，则表示可以验证客户端证书，但如果客户端没有有效证书，也不强制验证 |
| keystoreFile   | 服务器证书文件路径。指定keystore文件的存放位置，可以指定绝对路径，也可以指定相对于<CATALINA_HOME>（Tomcat安装目录）环境变量 的相对路径。如果此项没有设定，默认情况下，Tomcat将从当前操作系统用户的用户目录下读取名为".keystore"的文件。 |
| keystorePass   | 服务器证书密码。指定keystore的密码，如果此项没有设定，在默认情况下，Tomcat将使用"changeit"作为默认密码。 |
| truststoreFile | 用来验证客户端证书的根证书，此例中就是服务器证书             |
| truststorePass | 根证书密码                                                   |
| sslProtocol    | 指定套接字（Socket）使用的加密/解密协议，默认值为TLS，用户不应该修改这个默认值。 |
| ciphers        | 指定套接字可用的用于加密的密码清单，多个密码间以逗号（,）分隔。如果此项没有设定，在默认情况下，套接字可以使用任意一个可用的密码。 |

实际上，基于SSL的HTTPS使用的默认端口是443。但Tomcat在这里将HTTPS端口设置为8443。

遇到的问题：

在配置的过程中问题，当我修改了server.xml的配置后，启动tomcat报错

java.lang.Exception: No Certificate file specified or invalid file format
 at org.apache.tomcat.jni.SSLContext.setCertificate(Native Method)
 at org.apache.tomcat.util.net.AprEndpoint.init(AprEndpoint.java:761)
 at org.apache.coyote.http11.Http11AprProtocol.init(Http11AprProtocol.java:109)
 at org.apache.catalina.connector.Connector.initialize(Connector.java:1123)
 at org.apache.catalina.core.StandardService.initialize(StandardService.java:703)
 at org.apache.catalina.core.StandardServer.initialize(StandardServer.java:838)
 at org.apache.catalina.startup.Catalina.load(Catalina.java:538)
 at org.apache.catalina.startup.Catalina.load(Catalina.java:562)

网上找了下，其实就是将protocol="HTTP/1.1"替换为protocol="org.apache.coyote.http11.Http11Protocol"，问题得以解决；

APR给Tomcat的性能提升起到很大作用，建议配置APR方式，这样就可以了

#### C、测试

https://localhost:8443/

![image-20201216083018957](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083018957.png)

![image-20201216083024632](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083024632.png)

服务器的证书与网址不相符问题需要理解浏览器做了什么：

1、浏览器将自己支持的一套加密规则发送给网站。

2、网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

3、获得网站证书之后浏览器要做以下工作：

  a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。

  b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。

  c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。

#### D、Java Web

要使你自己的WEB程序应用SSL安全访问，请遵循如下配置

在web.xml的 <web-app></web-app> 中加入如下配置

  <login-config>   <!-- Authorization setting  for SSL -->   <auth-method>**CLIENT-CERT**</auth-method>   <realm-name>**Client Cert Users-only Area**</realm-name>  </login-config>  <security-constraint>   <!-- Authorization setting  for SSL -->   <web-resource-collection >      <web-resource-name >**SSL**</web-resource-name>      <url-pattern>**/\***</url-pattern>   </web-resource-collection>   <user-data-constraint>      <transport-guarantee>**CONFIDENTIAL**</transport-guarantee>   </user-data-constraint>  </security-constraint>  

你会发现，即使用 http://....:8080 访问应用程序，它也会重定向为 https://....8443，也就是说，你的应用已经强制使用SSL安全访问层。

返回一个新的接受任意SSL证书的HttpClient（tomcat中clientAuth="false"）

  private DefaultHttpClient getIgnoreSSLHttpClient**(**int sslPort**)** **throws** Exception **{**     httpclient **=** **new** DefaultHttpClient**();**     SSLContext sslContext **=** SSLContext**.**getInstance**(**"TLS"**);**     X509TrustManager tm **=** **new** X509TrustManager**()** **{**      public X509Certificate**[]** getAcceptedIssuers**(){**       **return** **null****;**      **}**      public void checkClientTrusted**(**X509Certificate**[]** certs**,** String authType**)** **{**              **}**      public void checkServerTrusted**(**X509Certificate**[]** certs**,** String authType**)** **{**       System**.**out**.**println**(**"server:"**+**certs**[**0**]);**      **}**   **};**     sslContext**.**init**(****null****,** **new** TrustManager**[]** **{**tm**},** **null****);**     SSLSocketFactory sf **=** **new** SSLSocketFactory**(**sslContext**);**     Scheme sch **=** **new** Scheme**(**"https"**,** sslPort**,** sf**);**     httpclient**.**getConnectionManager**().**getSchemeRegistry**().**register**(**sch**);**   **return** httpclient**;**  **}**  

单向验证SSL证书的HttpClient（tomcat中clientAuth="false"）

  private  DefaultHttpClient getOneWayAuthSSLHttpClient**(**final  String ip**,** int  sslPort**)** **throws**  Exception **{**   httpclient **=** **new**  DefaultHttpClient**();**   SSLContext sslContext **=**  SSLContext**.**getInstance**(**"TLS"**);**   X509TrustManager tm **=** **new**  X509TrustManager**()** **{**    public  X509Certificate**[]** getAcceptedIssuers**(){**     **return** **new**  X509Certificate**[**0**];**    **}**    public void  checkClientTrusted**(**X509Certificate**[]**  certs**,** String authType**)** **{**        **}**    public void  checkServerTrusted**(**X509Certificate**[]**  certs**,** String authType**)** **throws**  CertificateException **{**     **if** **(**certs  **==** **null** **||**  certs**.**length **==** 0**)**      **throw** **new**  IllegalArgumentException**(**"null  or zero-length certificate chain"**);**     **if** **(**authType  **==** **null** **||**  authType**.**length**()** **==** 0**)**      **throw** **new**  IllegalArgumentException**(**"null  or zero-length authentication type"**);**     boolean  br **=** **false****;**     **for** **(**X509Certificate  x509Certificate **:** certs**)** **{**      String issuer **=**  x509Certificate**.**getIssuerDN**().**toString**();**      **if****(**issuer**.**contains**(**"CN=" **+**  ip**)){**       br **=** **true****;**       **return****;**      **}**     **}**     **if** **(!**br**)** **{**      **throw** **new**  CertificateException**(**"authen  failed!"**);**     **}**    **}**   **};**   sslContext**.**init**(****null****,** **new**  TrustManager**[]** **{**tm**},** **null****);**   SSLSocketFactory sf **=** **new**  SSLSocketFactory**(**sslContext**);**   Scheme sch **=** **new**  Scheme**(**"https"**,**  sslPort**,** sf**);**   httpclient**.**getConnectionManager**().**getSchemeRegistry**().**register**(**sch**);**   **return**  httpclient**;**  **}**  

双向验证SSL证书的HttpClient（tomcat中clientAuth="true"）

  private DefaultHttpClient  getMutualAuthSSLHttpClient**(**int sslPort**)** **throws** Exception **{**     httpclient **=** **new** DefaultHttpClient**();**     String CLIENT_KEY_STORE_PASSWORD **=** "123123"**;**     String CLIENT_TRUST_KEY_STORE_PASSWORD **=** "123123"**;**     String CLIENT_KEY_PATH **=** "clientKey.keystore"**;**//client's private key     String SERVER_CERT_PATH **=** "serverCrt.keystore"**;**//server's certificate     SSLContext sslContext **=** SSLContext**.**getInstance**(**"TSL"**);**     KeyManagerFactory kmf **=** KeyManagerFactory**.**getInstance**(**"SunX509"**);**     TrustManagerFactory tmf **=** TrustManagerFactory**.**getInstance**(**"SunX509"**);**     KeyStore ks **=** KeyStore**.**getInstance**(**"JKS"**);**     KeyStore tks **=** KeyStore**.**getInstance**(**"JKS"**);**     ks**.**load**(****new** FileInputStream**(**CLIENT_KEY_PATH**),** CLIENT_KEY_STORE_PASSWORD**.**toCharArray**());**     tks**.**load**(****new** FileInputStream**(**SERVER_CERT_PATH**),** CLIENT_TRUST_KEY_STORE_PASSWORD**.**toCharArray**());**     kmf**.**init**(**ks**,** CLIENT_KEY_STORE_PASSWORD**.**toCharArray**());**     tmf**.**init**(**tks**);**     sslContext**.**init**(**kmf**.**getKeyManagers**(),** tmf**.**getTrustManagers**(),** **null****);**     SSLSocketFactory sf **=** **new** SSLSocketFactory**(**sslContext**);**     Scheme sch **=** **new** Scheme**(**"https"**,** sslPort**,** sf**);**     httpclient**.**getConnectionManager**().**getSchemeRegistry**().**register**(**sch**);**   **return** httpclient**;**  **}**  

 

参考 ：

http://www.sunchis.com/html/java/javaweb/2010/0314/71.html

http://www.blogjava.net/stone2083/archive/2007/12/20/169015.html

#### E、批量生成安全证书

为了实现每人发放一个证书，如果重复以上的操作也可以达到目的，考虑到需要进行大量的测试，并且在不同的机器上部署，就想到使用程序自动生成命令的方法。

生成命令的程序是使用java 写的，生成命令需要预先设置如下的几项：

1．Basedir生成的命令文件的位置，生成的命令运行后生成cer和p12格式的文件，为了区分存放，需要建立两个文件夹，因此需要与一个基本目录

2．生成的keyStore文件需要一个密码，为了安全起见，不同的域名的keyStore需要不同的密码。

3．域地址，如果域地址不正确，则会在整数上发出警告。因此对于不同的域，地址是不同的。

完成以上的三个设置之后就可以生成命令了。生成的文件包括3个，全部存放在Basedir下。

1．Myint.inf文件，仅仅用于输入内容很简单包括y 和一个回车

2．Conf的文件，里面包括了生成的配置文件片段和一段简单的使用说明，内容如下

<Connector port="443" protocol="HTTP/1.1" SSLEnabled="true"

​    maxThreads="150" scheme="https" secure="true"

​    clientAuth="true" sslProtocol="TLS"

​    keystoreFile="D:/downloads/tomcat.keystore"

​    keystorePass="logiscn"

​    truststoreFile="D:/downloads/tomcat.keystore"

​    truststorePass="logiscn"/>

使用的时候直接复制到相应的server.xml中

3．可执行的命令文件command.bat，执行上述命令之前，需要建立两个文件夹，以便于把生成的文件存放到合适的位置，部分代码如下

mkdir cert

  mkdir p12

  keytool -genkey -v -alias tomcat -keyalg RSA -keystore D:/downloads/tomcat.keystore -dname "CN=localhost,OU=logiscn,O=logis,L=beijing,ST=beijing,C=CN" -validity 3650 -storepass logiscn -keypass logiscn

  rem 为 tianli 生成证书

  rem 第二步：为客户端生成证书

  keytool -genkey -v -alias tianli -keyalg RSA -storetype PKCS12 -keystore D:/downloads/p12/tianli.p12 -dname "CN=tianli,OU=logiscn,O=logis,L=beijing,ST=beijing,C=CN" -validity 3650 -storepass tianli -keypass tianli"

  rem 第三步：让服务器信任客户端证书

  keytool -export -alias tianli -keystore D:/downloads/p12/tianli.p12 -storetype PKCS12 -storepass tianli -rfc -file D:/downloads/cert/tianli.cer"

  keytool -import -alias tianli -v -file D:/downloads/cert/tianli.cer -keystore D:/downloads/tomcat.keystore -storepass logiscn <myint.inf

#### F、[JKS密钥对生成与读取方法](http://blog.csdn.net/xiao_zhu_kuai_pao/article/details/45441853)

**前言：**

**JKS**文件是一个java中的密钥管理库。

JKS文件就好像一个仓库，里面可以放很多的东西，这里只存放一类东西就是密钥，仓库当然会有一把锁，防范别人随便乱拿，这个就是JKS文件的密码。里面存放的密钥也各有不同，每个密钥都有一个名字（在下面叫别名），一类叫密钥对，一类叫公钥，一类叫私钥，密钥对就是包含公钥和私钥的。这里的公钥只要你能进入仓库你就可以随便查看拿走，私钥则是有密码的，只允许有权限的人查看拿走。

Keytool 是一个JAVA环境下的安全钥匙与证书的管理工具，Keytool将密钥（key）和证书（certificates）存在一个称为keystore 的文件(受密码保护)中。

在keystore里，包含两种数据： 

密钥实体（Key entity）——密钥（secretkey）又或者是私钥和配对公钥（采用非对称加密）

可信任的证书实体（trustedcertificate entries）——只包含公钥

##### F.1 生成JKS文件（密钥对）

keytool-genkey -keyalg RSA -keysize 1024 -validity 365 -dname "CN=spdb, OU=spdb,O=spdb, L=shanghai, ST=shanghai, C=CN" -alias csii_key -keypass 888888 -keystore csii.jks -storepass 123456 ;

  CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称),ST=(州或省份名称), C=(单位的两字母国家代码)

![image-20201216083136862](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083136862.png)

##### F.2 读取JKS文件信息

keytool -list -v -keystore csii.jks -storepass 123456 ;

  缺省情况下，-list 命令打印证书的 MD5 指纹。

  而如果指定了 -v 选项，将以可读格式打印证书，如果指定了 -rfc 选项，将以可打印的编码格式输出证书。

![image-20201216083153286](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083153286.png)

##### F.3 提取公钥JKS

1）导出公钥到证书中（cer文件）

keytool-export -alias csii_key -keystore csii.jks -storepass 123456 -file csii.cer ;

![image-20201216083204229](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083204229.png)

2）将服务端证书（公钥），导入客户端密钥库中

keytool-import -alias csii_key -file csii.cer -keystore csii_pub.jks -storepass 123456;

（保存时，需要设置密钥库密码，且此时不能少于6位）

![image-20201216083215999](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083215999.png)

至此，私钥JKS、公钥JKS文件都已经生成好了，生成文件如下：

![image-20201216083228852](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083228852.png)

JDK中keytool常用命令

-genkey   

在用户主目录中创建一个默认文件".keystore",还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书

-alias    

产生别名

-keystore  

指定密钥库的名称(产生的各类信息将不在.keystore文件中

-keyalg   

指定密钥的算法  

-validity  

指定创建的证书有效期多少天

-keysize   

指定密钥长度

-storepass  

指定密钥库的密码

-keypass   

指定别名条目的密码

-dname    

指定证书拥有者信息 例如： "CN=sagely,OU=atr,O=szu,L=sz,ST=gd,C=cn"

-list    

显示密钥库中的证书信息 keytool -list -v -keystore sage -storepass ....

-v     

显示密钥库中的证书详细信息

-export   

将别名指定的证书导出到文件 keytool -export -alias caroot -file caroot.crt

-file    

参数指定导出到文件的文件名

-delete   

删除密钥库中某条目     keytool -delete -alias sage -keystore sage

-keypasswd  

修改密钥库中指定条目口令  keytool -keypasswd -alias sage -keypass ....

-new .... -storepass ... -keystore sage

-import   

将已签名数字证书导入密钥库 keytool -import -alias sage -keystore sagely -file sagely.crt 导入已签名数字证书用keytool -list -v 以后可以明显发现多了认证链长度，并且把整个CA链全部打印出来。

 

1.证书的显示

-list

[-v | -rfc] [-alias <alias>]

[-keystore <keystore>] [-storepass <storepass>]

[-storetype <storetype>] [-provider <provider_class_name>]

例如：

keytool -list -v -alias RapaServer -keystore cacerts -storepass 12345678

keytool -list -v -keystore d2aapplet.keystore -storepass 12345678 -storetype IAIKKeystore

2.将证书导出到证书文件

例如：

keytool -export -keystore monitor.keystore -alias monitor -file monitor.cer

将把证书库 monitor.keystore 中的别名为 monitor 的证书导出到 monitor.cer 证书文件中，它包含证书主体的信息及证书的公钥，不包括私钥，可以公开。

keytool -export -keystore d2aApplet.keystore -alias RapaServer -file Rapa.cert -storetype IAIKKeystore

3.将keystore导入证书中，这里向Java默认的证书 cacerts导入Rapa.cert

keytool -import -alias RapaServer -keystore cacerts -file Rapa.cert -keystore cacerts

4.证书条目的删除

keytool的命令行参数 -delete 可以删除密钥库中的条目，如： keytool -delete -alias RapaServer -keystore d2aApplet.keystore ，这条命令将 d2aApplet.keystore 中的 RapaServer 这一条证书删除了。

5.证书条目口令的修改

使用 -keypasswd 参数，如：

keytool -keypasswd -alias RapaServer -keystore d2aApplet.keystore

可以以交互的方式修改 d2aApplet.keystore证书库中的条目为 RapaServer 的证书。

Keytool -keypasswd -alias RapaServer -keypass 654321 -new 123456 -storepass 888888 -keystore d2aApplet.keystore

这一行命令以非交互式的方式修改库中别名为 RapaServer 的证书的密码为新密码 654321，行中的 123456 是指该条证书的原密码， 888888 是指证书库的密码。

##### F.4 Java使用JKS文件，示例代码

**1****）使用私钥签名**

//a. 创建针对jks文件的输入流

InputStream  inputStream = **new** FileInputStream(cafile);

//CA 文件名  如： D:/zyt/tmp/online.jks

//b. 创建KeyStore实例     （store_password密钥库密码）

KeyStore keyStore = KeyStore.*getInstance*("JKS");

keyStore.load(inputStream,store_password.toCharArray());

  //c. 获取私钥      （alias 为私钥别名，password为私钥密码）

PrivateKey pk = keyStore.getKey(alias,password.toCharArray());

  //d. 用私钥对数据签名

  //获取Signature实例，指定签名算法（本例使用MD5withRSA，可自选）

Signaturedsa = Signature.*getInstance*("MD5withRSA");

//加载私钥

dsa.initSign(privateKey);

//更新待签名的数据

dsa.update(data.getBytes());

//进行签名

**byte**[] sig = dsa.sign();

//转换成十六进制字符串，作为最终的签名数据

  **return** *byteToHex*(sig);

备注：上述字节数组即签名后的数据，可将该字节数组转换成十六进制字符串，此处不再赘述，直接去问谷老师吧。

**2****）使用公钥验签**

//a. 创建针对jks文件的输入流

同上

//b. 创建KeyStore实例    

同上

//c. 获取公钥      （alias 为公钥别名）

PublicKey pubKey= keyStore.getCertificate(alias).getPublicKey();

//d. 公钥进行验签

//获取Signature实例，指定签名算法(与之前一致)

Signaturedsa = Signature.*getInstance*("MD5withRSA");

//加载公钥

dsa.initVerify(publicKey);

//更新原数据

dsa.update(orgData.getBytes());

//将签名数据从十六进制字符串转回字节数组

**byte** sig[] =*hexToByte*(signData);

   //公钥验签（true-验签通过；false-验签失败）

**return** dsa.verify(sig);

用java读出证书的信息

import java.io.*;
 import java.security.cert.*;
 public class TestCert {
   public static void main(String[] args) {
     try {
       FileInputStream fis = new FileInputStream("mycert.cer");
       CertificateFactory cf=CertificateFactory.getInstance("X509");
       X509Certificate c=(X509Certificate) cf.generateCertificate(fis);
       System.out.println("Certficate for" + c.getSubjectDN());
       System.out.println("Generated with "+c.getSigAlgName());
     } catch (FileNotFoundException ex) {
     } catch (CertificateException ex) {
       /** @todo Handle this exception */
     }
   }
 }

输出：

Certficate forCN=chen sr, OU=tanglab, O=lab, L=gz, ST=gd, C=cn
 Generated with SHA1withDSA

#### G、配置WebService的HTTPS实现SSL的单双向认证

##### G.1 单向认证

\1. 首先使用Keytool工具生成服务端的Keystore文件，Keytool工具实现确认下机器上是否配置了JDK的环境变量，如果没有的话需要进入JDK的当前目录执行命令了

  keytool -genkey -alias webService_server -keystore server.keystore -keyalg RSA  -keysize 4096 -storetype JKS

\2. 导出服务端RSA证书并将证书导入到客户端truststore文件中，信任库文件被客户端使用，用于对服务端身份验证

  keytool -export -alias webService_server -file webServiceServer.cer -storepass 123456a? -keystore server.keystore -storetype JKS

  keytool -import -file webServiceServer.cer -storepass 123456a? -keystore client.truststore -alias serverkey -noprompt

\3. 配置Tomcat根目录下conf/server.xml文件中以下内容，去注释

  <Connector port="8443" protocol="HTTP/1.1" maxThreads="150" minSpareThreads="25" maxSpareThreads="75"

enableLookups="false" disableUploadTimeout="true" SSLEnabled="true"

acceptCount="100" debug="0" scheme="https" secure="true" clientAuth="true" keystoreFile="server.keystore" keystorePass="password"sslProtocol="TLS" />

4.部署Axis服务，这里就不写如何部署了，直接启动Tomcat查看Wsdl

  https://localhost:8443/ws/services/axisWS.Test?wsdl

以上步骤完成了服务端的配置，下面是客户端的调用方式

  public static void main**(**String**[]** args**)** **{**    **try** **{**      String  endpoint **=** "https://localhost:8443/eomsWS/services/axisWS.Test"**;**      // 1.创建service对象，通过axis自带的类创建      Service  service **=** **new** Service**();**      URL  url **=** **new** URL**(**endpoint**);**      // 通过URL类的构造方法传入wsdlUrl地址创建URL对象      // 2.创建服务方法的调用者对象call，设置call对象的属性      Call  call **=** **(**Call**)** service**.**createCall**();**      //配置客户端信任库文件路径      System**.**setProperty**(**"javax.net.ssl.trustStore"**,** "E:/keystore/client/client.truststore"**);**      // 给call对象设置请求的URL属性          call**.**setTargetEndpointAddress**(**url**);**      String  serviceName **=** "sayHello"**;**      // 给call对象设置调用方法名属性      call**.**setOperationName**(****new** QName**(**"http://loushang.ws"**,**serviceName**));**      // 给call对象设置方法的参数名、参数类型、参数模式      call**.**addParameter**(**"param"**,** XMLType**.**XSD_STRING**,** ParameterMode**.**IN**);**      // 设置调用方法的返回值类型      call**.**setReturnType**(**XMLType**.**SOAP_STRING**);**      // 4.通过invoke方法调用webservice      String  param **=** "1222222"**;**      String  res **=** **(**String**)** call**.**invoke**(****new** Object**[]** **{** param **});**// 调用服务方法      System**.**out**.**println**(**res**);**    **}** **catch** **(**ServiceException e**)** **{**      e**.**printStackTrace**();**    **}** **catch** **(**MalformedURLException e1**)** **{**      e1**.**printStackTrace**();**    **}** **catch** **(**RemoteException e**)** **{**      e**.**printStackTrace**();**    **}**  **}**  

\6. 运行该代码，如果出现接口输出结果表示连接成功。

##### G.2 双向认证

双向认证较上面的步骤多出一个生成客户端密钥库，并将客户端证书RSA文件导入到服务端信任库文件的过程，步骤如下：

\1. 在单向认证1，2步骤后生成客户端密钥库keystore文件

  keytool -genkey -dname " CN=webService_Client, OU=JN, O=JN, L=JN, S=JN, C=CN" -storepass 123456a? -keystore client.keystore -keyalg RSA -keypass 123456a?

\2. 导出客户端端RSA证书并将证书导入到服务端端truststore文件中，该信任库文件被服务端使用，用于对客户端端身份验证

  keytool -export -file webServiceClient.cer -storepass 123456a? -keystore client.keystore

  keytool -import -file webServiceClient.cer -storepass 123456a? -keystore server.truststore -alias clientkey -noprompt

\3. 在Tomcat下conf/server.xml中的Connector 中添加truststoreFile和truststorePass，配置见单向认证中的3种追加

\4. 修改客户端调用代码

  //配置客户端信任库验证文件路径

  System.setProperty("javax.net.ssl.trustStore", "E:/keystore/client/client.truststore");

  //配置服务端信任库验证文件路径

  System.setProperty("javax.net.ssl.keyStore", "E:/keystore/client/client.keystore");

\5. 重启Tomcat测试代码，即可。

#### H、从godaddy购买ssl证书以及如何应用到tomcat上

1.访问 

https://www.digicert.com/easy-csr/keytool.htm 

填写必要的信息，尤其是common name，是网站域名.结果是生成命令，拷贝到命令行里面直接之行，会生成一个jks文件和一个csr文件，注意jks文件其实就是.keystore，名字不同而已。注意这里要记住密码。 

![image-20201216083256834](C:\Users\23907\AppData\Roaming\Typora\typora-user-images\image-20201216083256834.png)

 

2.csr文件内容提交到godaddy。

3.下面先解释一下压缩包里面几个文件的含义。 

根据 http://serverfault.com/questions/578025/discerning-godaddy-ssl-certificate-types 的说明： 

gd_bundle-g2-g1.crt: Go Daddy Certificate Bundles - G2 With Cross to G1, includes Root 

gdig2.crt: Go Daddy Secure Server Certificate (Intermediate Certificate) - G2 

随机id.crt: Your certificate 

4.下面开始导入这几个文件到.keystore文件（或者说是jks文件）。

分别导入： 

gd_bundle-g2-g1.crt 

gdig2.crt 

xxxxxx.crt（压缩包里面一个随机id.crt的文件） 

godaddy的文档貌似也是这么解释的，**实际上不行**。 

需要访问 https://certs.godaddy.com/repository

下载gdroot-g2.crt，作为root CA进行签名。对我来说是： 

keytool -import -alias root -keystore tomcat.keystore -storepass 密码 -trustcacerts -file gdroot-g2.crt 

keytool -import -alias intermed -keystore tomcat.keystore -storepass 密码 -trustcacerts -file gdig2.crt 

keytool -import -alias server -keystore tomcat.keystore -storepass 密码-trustcacerts -file 随机id.crt （**注意这里****alias****是****server****，是因为最早生成****keystore****的时候，****alias****是****server****，很多文档写的****tomcat****，因为开始生成****keystore****使用的****alias****是****tomcat****）** 

需要注意的是，如果直接把gd_bundle-g2-g1.crt作为root，会报告错误：无法从回复中建立链（Failed to establish chain from reply） 

然后把这个tomcata.keystore(我没有叫tomcat.jks主要是为了以后看起来明确这个文件是干什么的)，以及密码配置到server.xml即可。 

<Connector port="443" protocol="org.apache.coyote.http11.Http11Protocol" 

​        maxThreads="150" SSLEnabled="true" scheme="https" secure="true" 

​        clientAuth="false" sslProtocol="TLS" 

keystoreFile="路径/tomcat.keystore" keystorePass="密码"/> 

现在浏览器访问，不会再报告ssl不安全了。

参考：

https://sg.godaddy.com/zh/help/tomcat-4x5x6x7x-ssl-5239

  rem keytool -genkey -alias server -keyalg  RSA -keysize 2048 -keystore www_nielsenecom_com.jks -dname  "CN=www.nielsenecom.com, O=nielsen, L=Shanghai, ST=Shanghai, C=CN"   rem keytool -certreq -alias server -file  www_nielsenecom_com.csr -keystore www_nielsenecom_com.jks   rem echo Your certificate signing request  is in www_nielsenecom_com.csr. Your  keystore file is www_nielsenecom_com.jks.   Thanks for using the DigiCert keytool CSR helper.     rem 密码:123456  keytool -genkey -v -alias ecommerce -keyalg RSA  -keystore D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\ecommerce.jks -dname  "CN**=**www.nielsenecom.com,OU**=**nielsen,L**=**Shanghai,ST**=**Shanghai,C**=**CN" && keytool -certreq  -alias ecommerce -file  D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\ecommerce.csr -keystore  D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\ecommerce.jks      keytool -import -alias root -keystore  D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\ecommerce.jks -storepass 123456  -trustcacerts -file  D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\gdroot-g2.crt     keytool -import -alias intermed -keystore  D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\ecommerce.jks -storepass 123456  -trustcacerts -file D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\gdig2.crt.pem     keytool -import -alias ecommerce  -keystore D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\ecommerce.jks  -storepass 123456 -trustcacerts -file  D:\Nielsen\dev\apache-tomcat-8.0.35\conf\ssl\f4a14b96e621de6d.crt  

 

**安装服务**

https://jingyan.baidu.com/article/6dad5075042a2ba123e36ed5.html

 

 

**错误解决**

#### The CATALINA_HOME environment variable is not defined correctly

答：配置CATALINA_HOME环境变量，注意环境变量不要以";"结尾，否则就会报地址找不到。由于更改了环境变量所以导致cmd环境改变需要**重新打开**cmd控制台。

 

## IIS



### 常见问题

**1、[IIS锁定是默认设置的 (overrideModeDefault="Deny")问题解决](https://www.cnblogs.com/yaotome/p/11118460.html)**

发布网站时提示错误：

锁定是默认设置的 (overrideModeDefault="Deny")，或者是通过包含 overrideMode="Deny" 或旧有的 allowOverride="false" 的位置标记明确设置的。

解决方法

管理员方式打开命令行运行以下命令

```bash
%windir%\system32\inetsrv\appcmd unlock config -section:system.webServer/handlers
%windir%\system32\inetsrv\appcmd unlock config -section:system.webServer/modules
```


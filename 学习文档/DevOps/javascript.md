 

***\*数组\****

通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。

### ***\*创建数组\****

数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。

调用构造函数Array()是创建数组的另一种方法。

l new Array()

l new Array(length)

l new Array(e1,e2,…)

### ***\*数组元素的读和写\****

[]

数组是对象的特殊形式，因此没有“越界”概念。

0~232-2之间的整数属性名是索引。数组会自动维护length属性值

如果一个数组确实继承了元素或使用了元素的getter和setter方法，你应该期望它使用非优化的代码路径:访问这种数组的元素的时间会与常规对象属性的查找时间相近。

### ***\*稀疏数组\****

稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。

***\*var\**** a1 ***\*=\**** ***\*[,,,];\****//数组是[undefined,undefined,undefined]***\*var\**** a2 ***\*=\**** ***\*new\**** Array***\*(\****3***\*);\****//该数组根本没有元素0 ***\*in\**** a1 // => true: a1在索引0处有一个元素0 ***\*in\**** a2 // => false: a2在索引0处没有元素//当在数组直接量中省略值时不会创建稀疏数组，需要注意的是，当省略数组直接量中的值时(使用连续的逗号，比如[1,,3])，这时所得到的数组也是稀疏数组，省略掉的值是不存在的:***\*var\**** a1 ***\*=\**** ***\*[,];\**** //此数组没有元素，长度是1***\*var\**** a2 ***\*=\**** ***\*[\****undefined***\*];\**** //此数组包含一个值为undefined的元素0 ***\*in\**** a1 // => false: a1在索引0处没有元素0 ***\*in\**** a2 // => true: 且在索引0处有一个值为undefined的元素

### ***\*数组长度\****

每个数组有一个length属性，就是这个属性使其区别于常规的JavaScript对象

a ***\*=\**** ***\*[\****1 ***\*,\**** 2***\*,\**** 3***\*,\**** 4***\*,\**** 5***\*];\****//从5个元素的数组开始a***\*.\****length ***\*=\**** 3***\*;\****//现在a 为[1,2,3]a***\*.\****length ***\*=\**** 0***\*;\****//删除所有的元素。a为[ ]a***\*.\****length ***\*=\**** 5***\*;\**** //长度为5，但是没有元素，就像new Array(5)

在ECMAScript 5 中，可以用Object.defineProperty() 让数组的length属性变成只读的。如果让一个数组元素不能配置，就不能删除它。如果不能删除它，length属性不能设置为小于不可配置元素的索引值

### ***\*数组元素的添加和删除\****

a ***\*=\**** ***\*[]\**** //开始是一个空数组a***\*[\****0***\*]\**** ***\*=\**** "zero"***\*;\**** //然后向其中添加元素a***\*[\****1***\*]\**** ***\*=\**** "one"***\*;\****b ***\*=\**** ***\*[];\**** //开始是一个空数组b***\*.\****push***\*(\****"zero"***\*)\**** //在末尾添加一个元素。b = ["zero"]b***\*.\****push***\*(\****"one" ***\*,\**** "two"***\*)\**** //再添加两个元素。b = ["zero", "one" , "two"]c ***\*=\**** ***\*[\****1***\*,\****2***\*,\****3***\*];\*******\*delete\**** c***\*[\****1***\*];\****// a在索引1的位置不再有元素1 ***\*in\**** c // => false: 数组索引1并未在数组中定义c***\*.\****length // => 3: delete操作并不影响数组长度

### ***\*数组遍历\****

l for

l for/in

l forEach() //ECMAScript 5

### ***\*多维数组\****

//创建一个多维数组***\*var\**** tab1e ***\*=\**** ***\*new\**** Array***\*(\****10***\*);\**** //表格有10行***\*for\*******\*(\*******\*var\**** i ***\*=\**** 0***\*;\**** i ***\*<\**** tab1e.1ength***\*;\**** i***\*++)\****	tab1e***\*[\****i***\*]\**** ***\*=\**** ***\*new\**** Array***\*(\****10***\*);\**** //每行有10列//初始化数组***\*for\*******\*(\*******\*var\**** row ***\*=\**** 0***\*;\**** row ***\*<\**** tab1e.1ength***\*;\**** row***\*++)\**** ***\*{\****	***\*for\*******\*(\****col ***\*=\**** 0***\*;\**** col ***\*<\**** tab1e***\*[\****row***\*].\****length***\*;\**** col***\*++)\**** ***\*{\****		tab1e***\*[\****row***\*][\****col***\*]\**** ***\*=\**** row***\**\****col***\*;\****	***\*}\*******\*}\****//使用多维数组来计算(查询)5*7****var\**** product ***\*=\**** table***\*[\****5***\*][\****7***\*];\**** // 35

### ***\*数组方法\****

join():将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。

***\*var\**** a ***\*=\**** ***\*[\****1***\*,\**** 2***\*,\**** 3***\*];\**** //创建一个包含三个元素的数组a***\*.\****join***\*();\**** // =>"1,2,3"a***\*.\****join***\*(\****" "***\*);\**** // => "1 2 3"a***\*.\****join***\*(\****""***\*);\**** // => "123"***\*var\**** b ***\*=\**** ***\*new\**** Array***\*(\****10***\*);\**** //长度为10的空数组b***\*.\****join***\*(\****'-'***\*)\**** // => '---------': 9个连字号组成的字符串

reverse():将数组中的元素颠倒顺序，返回逆序的数组

***\*var\**** a ***\*=\**** ***\*[\****1***\*,\****2***\*,\****3***\*];\****a***\*.\****reverse***\*().\****join***\*()\**** // => "3,2,1"，并且现在的a是[3,2,1]

sort():将数组中的元素排序并返回排序后的数组。

***\*var\**** a ***\*=\**** ***\*new\**** Array***\*(\****"banana"***\*,\**** "cherry"***\*,\**** "apple"***\*);\****a***\*.\****sort***\*();\*******\*var\**** s ***\*=\**** a***\*.\****join***\*(\****", "***\*);\**** // s = "apple, banana, cherry" a ***\*=\**** ***\*[\****33 ***\*,\**** 4***\*,\**** 1111***\*,\**** 222***\*];\****a***\*.\****sort***\*();\**** //字母表顺序: 1111, 222 , 33, 4a***\*.\****sort***\*(\*******\*function\*******\*(\****a ***\*,\**** b***\*)\**** ***\*{\**** //数值顺序: 4, 33, 222 , 1111	***\*return\**** a***\*-\****b***\*;\**** //根据顺序，返回负数、0、正数***\*});\**** a***\*.\****sort***\*(\*******\*function\*******\*(\****a***\*,\**** b***\*)\**** ***\*{\*******\*return\**** b***\*-\****a***\*});\**** //数值大小相反的顺序//注意，这里使用匿名函数表达式非常方便。既然比较函数只使用一次，就没必要给它们命名了。 a ***\*=\**** ***\*[\****'ant' ***\*,\**** 'Bug' ***\*,\**** 'cat' ***\*,\**** 'Dog'***\*]\****a***\*.\****sort***\*();\**** //区分大小写的排序: ['Bug' , 'Dog' , 'ant' ,cat']a***\*.\****sort***\*(\*******\*function\*******\*(\****s ***\*,\****t***\*)\**** ***\*{\**** //不区分大小写的排序	***\*var\**** a ***\*=\**** s***\*.\****toLowerCase***\*();\****	***\*var\**** b ***\*=\**** t***\*.\****toLowerCase***\*();\****	***\*if\**** ***\*(\****a ***\*<\**** b***\*)\**** ***\*return\**** ***\*-\****1***\*;\****	***\*if\**** ***\*(\****a ***\*>\**** b***\*)\**** ***\*return\**** 1***\*;\****	***\*return\**** 0***\*;\*******\*});\****// => ['ant', 'Bug', 'cat', 'Dog']

concat():创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意， concat()不会递归扁平化数组的数组。concat()也不会修改调用的数组。

***\*var\**** a ***\*=\**** ***\*[\****1***\*,\****2***\*,\****3***\*];\****a***\*.\****concat***\*(\****4***\*,\****5***\*);\****//返回[1,2,3,4,5]a***\*.\****concat***\*([\****4***\*,\****5***\*]);\****//返回[1,2,3,4,5]a***\*.\****concat***\*([\****4***\*,\****5***\*],[\****6***\*,\****7***\*])\****//返回[1,2,3,4,5,6,7]a***\*.\****concat***\*(\****4***\*,[\****5***\*,[\****6***\*,\****7***\*]])\****//返回[1,2,3,4,5,[6,7]]

slice():返回指定数组的一个片段或子数组，不会修改调用的数组。

***\*var\**** a ***\*=\**** ***\*[\****1***\*,\****2***\*,\****3***\*,\****4***\*,\****5***\*];\****a***\*.\****slice***\*(\****0***\*,\****3***\*);\**** //返回[1,2,3]a***\*.\****slice***\*(\****3***\*);\**** //返回[4,5]a***\*.\****slice***\*(\****1***\*,-\****1***\*);\****//返回[2,3,4]a***\*.\****slice***\*(-\****3***\*,-\****2***\*);\**** //返回[3]

splice():在数组中插入或删除元素的通用方法。第一个参数指定了插入和(或)删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。

***\*var\**** a***\*=[\****1***\*,\****2***\*,\****3***\*,\****4***\*,\****5***\*,\****6***\*,\****7***\*,\****8***\*];\****a***\*.\****splice***\*(\****4***\*);\****//return [5,6,7,8]; a=[1,2,3,4]a***\*.\****splice***\*(\****1***\*,\****2***\*);\****//return [2,3]; a=[1,4]a***\*.\****splice***\*(\****1***\*,\****1***\*)\****；//return [4]; a=[1] a***\*=[\****1***\*,\****2***\*,\****3***\*,\****4***\*,\****5***\*];\****a***\*.\****splice***\*(\****2***\*,\****0***\*,\****'a'***\*,\****'b'***\*);\****//return []; a=[1,2,'a','b',3,4,5]a***\*.\****splice***\*(\****2***\*,\****2***\*,[\****1***\*,\****2***\*],\****3***\*);\****//return ['a','b']; a=[1,2,[1,2],3,3,4,5]

push()和pop():允许将数组当做栈来使用。push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop() 方住则相反，它删除数组的最后一个元素，减小数组长度并返回它删除的值。注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用push()和pop()能够用JavaScript数组实现先进后出的栈。

unshift():在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。

shift():删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。

toString():针对数组，该方法将其每个元素转化为字符串(如有必要将调用元素的toString()方法)并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符。

toLocaleString():是toString()方法的本地化版本。

### ***\*ECMAScript 5中的数组方法\****

forEach():从头至尾遍历数组，为每个元素调用指定的函数。传递的函数作为forEach()的第一个参数。然后forEach()使用三个参数调用该函数:数组元素、元素的索引和数组本身。forEach()无法在所有元素都传递给调用的函数之前终止遍历。也就是说，投有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try块中，并能抛出一个异常。如果forEach()调用的函数抛出foreach.break异常，循环会提前终止:

***\*var\**** data  ***\*=\**** ***\*[\****1***\*,\**** 2***\*,\**** 3***\*,\**** 4***\*,\**** 5***\*];\**** //要求和的数组//计算数组元素的和值***\*var\**** sum  ***\*=\**** 0***\*;\**** //初始为0data***\*.\****forEach***\*(\*******\*function\*******\*(\****value***\*)\**** ***\*{\**** sum  ***\*+=\**** value***\*;\**** ***\*});\**** //将每个值累加到sum上sum  //  =>  15 //每个数组元素的值自加1data***\*.\****forEach***\*(\*******\*function\*******\*(\****v***\*,\**** i***\*,\**** a***\*)\**** ***\*{\**** a***\*[\****i***\*]\**** ***\*=\**** v ***\*+\**** 1***\*;\**** ***\*});\**** data  // => [2, 3, 4, 5, 6] ***\*function\**** foreach***\*(\****a***\*,\**** f***\*,\**** t***\*)\**** ***\*{\**** ***\*try\**** ***\*{\**** a***\*.\****forEach***\*(\****f***\*,\****t***\*);\**** ***\*}\**** ***\*catch\*******\*(\****e***\*)\**** ***\*{\**** 	***\*if\**** ***\*(\****e ***\*===\**** foreach***\*.\*******\*break\*******\*)\**** ***\*return\*******\*;\**** 	***\*else\**** ***\*throw\**** e***\*;\**** ***\*}\*******\*}\****foreach***\*.\*******\*break\**** ***\*=\**** ***\*new\**** Error***\*(\****"Stoplteration"***\*);\****

map():将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。map()返回的是新数组:它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组:它具有相同的长度，相同的缺失元素。

a  ***\*=\**** ***\*[\****1***\*,\**** 2***\*,\**** 3***\*];\**** b ***\*=\**** a***\*.\****map***\*(\*******\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x***\**\****x***\*;\**** ***\*});\**** // b是[1, 4, 9]

filter():返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的:该函数返回true或false。

a ***\*=\**** ***\*[\****5***\*,\**** 4***\*,\**** 3***\*,\**** 2***\*,\**** 1***\*];\**** smallvalues ***\*=\**** a***\*.\****filter***\*(\*******\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x ***\*<\**** 3 ***\*});\**** // [2, 1] everyother ***\*=\**** a***\*.\****filter***\*(\*******\*function\*******\*(\****x***\*,\**** i***\*)\**** ***\*{\**** ***\*return\**** i***\*%\****2***\*==\****0 ***\*});\**** // [5, 3, 1] //filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的***\*var\**** dense ***\*=\**** sparse***\*.\****filter***\*(\*******\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*true\*******\*;\**** ***\*});\****//为了压缩稀疏数组的空缺，甚至压缩空缺并删除undefined和null元素 a ***\*=\**** a***\*.\****filter***\*(\*******\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x ***\*!==\**** undefined ***\*&&\**** x ***\*!=\**** ***\*null\*******\*;\**** ***\*});\****

every():就像数学中的"针对所有"，当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true

some():就像数学中的"存在"，当数组中至少有一个元素调用判定函数返回true，它就返回true

一旦every()和some()确认该返回什么值它们就会停止遍历数组元素。根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false

reduce()和reduceRight():使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为"注入"和"折叠"。

reduce()需要两个参数，第一个是执行化简操作的函数，第二个是传递给函数的初始值（可选）。

没有第二个参数时，数组的第一个元素就是初始值。

化简函数的第一个参数是上次执行结果的临时值（首次运算时是初始值），第二个参数是当前数组元素

***\*var\**** a ***\*=\**** ***\*[\****1***\*,\****2***\*,\****3***\*,\****4***\*,\****5***\*];\*******\*var\**** sum ***\*=\**** a***\*.\****reduce***\*(\*******\*function\*******\*(\****x***\*,\****y***\*){\**** ***\*return\**** x***\*+\****y ***\*},\**** 0***\*);\****//数组求和***\*var\**** product ***\*=\**** a***\*.\****reduce***\*(\*******\*function\*******\*(\****x***\*,\****y***\*){\**** ***\*return\**** x***\**\****y ***\*},\**** 1***\*);\****//数组求积***\*var\**** max ***\*=\**** a***\*.\****reduce***\*(\*******\*function\*******\*(\****x***\*,\****y***\*){\**** ***\*return\**** ***\*(\****x***\*>\****y***\*)?\****x***\*:\****y ***\*});\****//求最大值 a ***\*=\**** ***\*[\****2***\*,\****3***\*,\****4***\*]\****//计算2^(3^4)。乘方操作的优先顺序是从右到左***\*var\**** big ***\*=\**** a***\*.\****reduceRight***\*(\*******\*function\*******\*(\****accumulator***\*,\****value***\*){\****	***\*return\**** Math***\*.\****pow***\*(\****value***\*,\****accumulator***\*);\*******\*});\**** ***\*var\**** objects ***\*=\**** ***\*[{\****x***\*:\****1***\*},{\****y***\*:\****2***\*},{\****z***\*:\****3***\*}];\*******\*var\**** merged ***\*=\**** objects***\*.\****reduce***\*(\****union***\*);\**** //=>{x:1,y:2,z:3} objects ***\*=\**** ***\*[{\****x***\*:\****1***\*,\****a***\*:\****1***\*},{\****y***\*:\****2***\*,\****a***\*:\****2***\*},{\****z***\*:\****3***\*,\****a***\*:\****3***\*}];\*******\*var\**** leftunion ***\*=\**** objects***\*.\****reduce***\*(\****union***\*);\****//{x:1,y:2,z:3,a:1}***\*var\**** rightunion ***\*=\**** objects***\*.\****reduceRight***\*(\****union***\*);\****//{x:1,y:2,z:3,a:3}

indexOf()和lastIndexOf():搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。indexOf()从头至尾搜索，而lastIndexOf()则反向搜索。

a ***\*=\**** ***\*[\****0***\*,\****1***\*,\****2***\*,\****1***\*,\****0***\*];\****a***\*.\****indexOf***\*(\****1***\*)\**** //=>1:a[1]是1a***\*.\****lastIndexOf***\*(\****1***\*)\**** //=>3:a[3]是1a***\*.\****indexOf***\*(\****3***\*)\**** //=>-1:没有值为3的元素 //在数组中查找所有出现的x，并返回一个包含匹配索引的数组***\*function\**** findAll***\*(\****a***\*,\****x***\*){\****	***\*var\**** results ***\*=\**** ***\*[],\**** //将会返回的数组		len ***\*=\**** a***\*.\****length***\*,\**** //待搜索数组的长度		pos ***\*=\**** 0***\*;\**** // 开始搜索的位置	***\*while\*******\*(\****pos***\*<\****len***\*){\****		pos ***\*=\**** a***\*.\****indexOf***\*(\****x***\*,\****pos***\*);\****		***\*if\*******\*(\****pos***\*===-\****1***\*)\**** ***\*break\*******\*;\****		results***\*.\****push***\*(\****pos***\*);\****		pos***\*++;\****	***\*}\****	***\*return\**** results***\*;\**** // 返回包含索引的数组***\*}\****

### ***\*数组类型\****

在ECMAScript 5中，可以使用Array.isArray()函数来判断对象是否为数组。

在ECMAScript 3中

***\*var\**** isArray ***\*=\**** ***\*Function\****.isArray ***\*||\**** ***\*function\*******\*(\****o***\*)\**** ***\*{\**** 

 ***\*return\**** ***\*typeof\**** o ***\*===\**** **"object"** ***\*&&\**** ***\*Object\****.***\*prototype\****.***\*toString\****.***\*call\*******\*(\****o***\*)\**** ***\*===\**** **"[object Array]"\******;\****

***\*};\**** 

### ***\*类数组对象\****

***\*var\**** a ***\*=\**** ***\*{};\**** **//从一个常规空对象开始**

**//添加一些属性，称为"类数组"**

***\*var\**** i ***\*=\**** ***\*0\*******\*;\**** 

***\*while\*******\*(\****i ***\*<\**** ***\*10\*******\*)\**** ***\*{\**** 

 a***\*[\****i***\*]\**** ***\*=\**** i ***\**\**** i***\*;\**** 

 i***\*++;\****

***\*}\**** 

a.***\*length\**** ***\*=\**** i***\*;\**** 

**//现在，当做真正的数组遍历它**

***\*var\**** total  ***\*=\**** ***\*0\*******\*;\**** 

***\*for\*******\*(\*******\*var\**** j ***\*=\**** ***\*0\*******\*;\**** j ***\*<\**** a.***\*length\*******\*;\**** j***\*++)\**** 

 total ***\*+=\**** a***\*[\****j***\*];\**** 

Arguments对象就是一个类数组对象

**//判定o是否是一个类数组对象**

**//字符串和函数有length属性，但是它们**

**//可以用typeof检测将其排除。在客户端JavaScript 中， DOM文本节点**

**//也有length属性，需要用额外判断o.nodeType != 3将其排除**

***\*function\**** isArrayLike***\*(\****o***\*)\**** ***\*{\**** 

 ***\*if\**** ***\*(\****o ***\*&&\**** **// o非null、undefined等**

  ***\*typeof\**** o ***\*===\**** **"object"** ***\*&&\**** **// o是对象**

  ***\*isFinite\*******\*(\****o.***\*length\*******\*)\**** ***\*&&\**** **// o.length是有限数值**

  o.***\*length\**** ***\*>=\**** ***\*0\**** ***\*&&\**** **//o.length为非负值**

  o.***\*length\**** ***\*===\**** ***\*Math\****.***\*floor\*******\*(\****o.***\*length\*******\*)\**** ***\*&&\**** **//o.length是整数**

  o.***\*length\**** ***\*<\**** ***\*4294967296\*******\*)\**** **// o.length < 2^32** 

  ***\*return\**** ***\*true\*******\*;\**** **//o是类数组对象**

 ***\*else\**** 

  ***\*return\**** ***\*false\*******\*;\**** **//否则它不是**

当用在类数组对象上时，数组方法的静态函数版本非常有用。但既然它们不是标准的，不能期望它们在所有的浏览器中都有定义。可以这样书写代码来保证使用它们之前是存在的:

***\*Array\****.***\*join\**** ***\*=\**** ***\*Array\****.***\*join\**** ***\*||\**** ***\*function\*******\*(\****a ***\*,\****sep***\*)\**** ***\*{\**** 

 ***\*return\**** ***\*Array\****.***\*prototype\****.***\*join\****.***\*call\*******\*(\****a ***\*,\**** sep***\*);\****

***\*};\**** 

***\*Array\****.***\*slice\**** ***\*=\**** ***\*Array\****.***\*slice\**** ***\*||\**** ***\*function\*******\*(\****a ***\*,\****from***\*,\****to***\*)\**** ***\*{\**** 

 ***\*return\**** ***\*Array\****.***\*prototype\****.***\*slice\****.***\*call\*******\*(\****a ***\*,\****from***\*,\****to***\*);\****

***\*};\****

***\*Array\****.map  ***\*=\**** ***\*Array\****.map  ***\*||\**** ***\*function\*******\*(\****a, f, thisArg***\*)\**** ***\*{\**** 

 ***\*return\**** ***\*Array\****.***\*prototype\****.map.***\*call\*******\*(\****a, f, thisArg***\*);\****

***\*}\**** 

### ***\*作为数组的字符串\****

字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。例如:

s ***\*=\**** **"JavaScript"** 

***\*Array\****.***\*prototype\****.***\*join\****.***\*call\*******\*(\****s ***\*,\**** **"  "\******)\**** **// =>J a v a S c r i p t"** 

***\*Array\****.***\*prototype\****.filter.***\*call\*******\*(\****s ***\*,\**** **//过滤字符串中的字符**

 ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** 

  ***\*return\**** ***\*x\****.***\*match\*******\*(/[^\****aeiou***\*]/);\**** **//只匹配非元音字母**

 ***\*})\****.***\*join\*******\*(\******""\******)\**** **// => "JvScrpt"** 

请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()和splice()等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误:出错的时候没有提示。

***\*函数\****

形参、实参、本次调用的上下文this

作为对象的属性时，称为对象的方法。此时this就是该对象

初始化新创建的函数称为构造函数

js的函数可以嵌套，它们可以访问被定义时所处作用域中的任何变量。js函数构成了一个闭包。

### ***\*定义\****

函数声明语句“被提前”到外部脚本或外部函数作用域的顶部， 所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。

不过，以表达式定义的函数就另当别论了，为了调用一个函数，必须要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它赋值给一个变量。***\*变量的声明提前了，但给变量赋值是不会提前的\****，所以，以表达式方式定义的函数在定义之前无法调用。

嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如，在下面的代码里，内部函数square() 可以读写外部函数hypotenuse()定义的参数a和b。这些作用域规则对内嵌函数非常重要。嵌套函数：

***\*function\**** hypotenuse***\*(\****a***\*,\**** b***\*)\**** ***\*{\**** ***\*function\**** square***\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x***\**\****x***\*;\**** ***\*}\**** ***\*return\**** Math***\*.\****sqrt***\*(\****square***\*(\****a***\*)\**** ***\*+\**** square***\*(\****b***\*));\**** ***\*}\****

声明形式的函数不能出现在循环、条件判断或者try/catch/finally以及with语句中。

函数定义表达式可以出现在任何地方。

### ***\*调用\****

函数调用方式：

1) 作为函数

特征：就是一个简单的函数调用。函数名的前面没有任何引导内容。

function foo () {} var func = function () {}; ... foo(); func(); (function (){})();

this的含义：在函数中this表示全局对象，在浏览器中是window

2) 作为方法

特征：方法一定是依附于一个对象，将函数赋值给对象的一个属性，那么就成为了方法。

function f() {  this.method = function () {}; } var o = { method: function () {} }

this的含义：这个依附的对象

和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this值不是全局对象(非严格模式下)就是undefined (严格模式下)。***\*很多人误以为调用嵌套函数时this会指向调用外层函数的上下文，其实不是\****。如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用变量self来保存this，比如：

***\*var\**** o ***\*=\**** ***\*{\**** //对象o m***\*:\**** ***\*function\*******\*()\**** ***\*{\**** //对象中的方法m()  ***\*var\**** ***\*self\**** ***\*=\**** ***\*this\*******\*;\**** //将this的值保存至一个变量中  console***\*.\****log***\*(\*******\*this\**** ***\*===\**** o***\*);\**** //输出true，this就是这个对象o  f***\*();\**** //调用辅助函数f()	***\*function\**** f***\*()\**** ***\*{\**** //定义一个嵌套函数f()   console***\*.\****log***\*(\*******\*this\**** ***\*===\**** o***\*);\**** // "false": this的值是全局对象或undefined   console***\*.\****log***\*(\*******\*self\**** ***\*===\**** o***\*);\**** // "true": self指外部函数的this值	***\*}\**** ***\*}\*******\*}\****o.m(); 

凡是没有形参的构造函数调用都可以省略圆括号。

3) 作为构造函数

创建对象的时候，构造函数做了什么？

创建一个新的空对象，这个对象继承自构造函数的prototype属性。构造函数初始化这个新对象，并将这个新对象用作其调用上下文。

由于构造函数只是给 this 添加成员，没有做其他事情，而方法也可以完成这个操作。就 this 而言，构造函数与方法没有本质区别。

特征：

\1. 使用 new 关键字，来引导构造函数.

\2. 构造函数中 this 与方法中一样，表示对象，但是构造函数中的对象是刚刚创建出来的对象

\3. 构造函数中不需要 return，就会默认的 return this

补充:

\1. 如果手动的添加 return，就相当于 return this

\2. 如果手动的添加 return 基本类型，无效，还是保留原来 返回 this

\3. 如果手动添加 return null 或 return undefiend，无效

\4. 如果手动添加 return 对象类型，那么原来创建的 this 就会被丢掉，返回的是 return 后面的对象

创造对象的工厂方法：

// 工厂就是用来生产的, 因此如果函数创建对象并返回，就称该函数为工厂函数function createPerson(name, age, gender) {var o = {};o.name = name;o.age = age;o.gender = gender;return o;}

4) 通过call()和apply()间接调用

JavaScript中的函数也是对象，和其他JavaScript对象没什么两样，函数对象也可以包含方法。其中的两个方法call()和apply()可以用来间接地调用函数。

两个方法都允许显式指定调用所需的this值，也就是说，***\*任何函数可以作为任何对象的方法来调用\****，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。 

call() 方法使用它自有的实参列表作为函数的实参，apply()方法则要求以数组的形式传入参数。

上下文就是环境，就是自定义设置 this 的含义

语法：

\1. 函数名.apply( 对象, [ 参数 ] );

\2. 函数名.call( 对象, 参数 );

描述：

\1. 函数名就是表示的函数本身，使用函数进行调用的时候默认 this 是全局变量

\2. 函数名也可以是方法提供，使用方法调用的时候，this 是指当前对象

\3. 使用 apply 进行调用后，无论是函数，还是方法都无效了。我们的 this，由 apply 的第一个参数决定

注意：

\1. 如果函数或方法中没有 this 的操作，那么无论什么调用其实都一样

\2. 如果是函数调用 foo()，那么有点像 foo.apply(window)

\3. 如果是方法调用 o.method()，那么有点像 o.method.apply(o)

每行代码和下面代码的功能类似（假设对象o中预先不存在名为m的属性）。

o.m = f; //将f存储为o的临时方法

o.m(); //调用它，不传入参数

delete o.m; //将临时方法删除

参数问题：

无论是 call 还是 apply 在没有后面的参数的情况下（函数无参数，方法无参数）是完全一样的

function foo() {  console.log(this);}foo.apply(obj);foo.call(obj);

第一个参数的使用也是有规则的

\1. 如果传入的是一个对象，那么就相当于设置该函数中的 this 为参数

\2. 如果不传入参数，或传入 null、undefiend 等，那么相当于 this 默认为 window

foo();foo.apply();foo.apply(null);foo.call(undefined);

\3. 如果传入的是基本类型，那么 this 就是基本类型对应的包装类型的引用

number -> Number

boolean -> Boolean

string -> String

除了 this 的参数外的参数

在使用 上下文调用的 时候，原函数（方法）可能会带有参数，那么这个参数在上下文调用中使用第二个（第n个）参数来表示

function foo(num) {  console.log(num);}foo.apply(null, [123]);// 等价于foo(123);

应用

上下文调用只是能修改 this，但是使用的最多的地方是借用函数调用

将伪数组转换为数组

传统的做法

var a = {};a[0] = 'a';a[1] = 'b';a.length = 2;// 数组自带的方法 concat// 语法: arr.concat(1, 2, 3, [4, [5]]);// 特点不修改原数组var arr = [];var newArr = arr.concat(a);

​	push

var a = { length: 0 }; // 伪数组a[a.length++] = 'abc'; // a[0] = 'abc'; a.length++;a[a.length++] = 'def';// 使用一个空数组，将元素一个个放到数组中即可var arr = [];arr.push(a); // 此时不会将元素展开，而是将这个伪数组作为一个元素加到数组中// 再次利用 apply 可以展开伪数组的特征arr.push.apply(arr, a);// 利用 apply 可以展开伪数组的特性，这里就相当于 arr.push(a[0], a[1])

slice

  语法：arr.slice( index, endIndex )

  如果第二个参数不传，那么就是 从 index 一致获取到结尾

  该方法不会修改原数组

var a = { length: 0 };a[a.length++] = 'abc';a[a.length++] = 'def';// 假设他是一个数组，就是应该 从 0 项开始截取到 最后// 如果可以的话，应该 a.slice(0)// 但是他没有该方法// 借用 数组的 slice，将 this 转换成 这个伪数组var arr = [];var newArr = arr.slice.apply(a, [0]);

trace

接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法是“包裹”原始方法的另一个泛函数。这种动态修改已有方法的做法有时称做"monkey-patching" 。

**// 将对象o中名为m()的方法替换为另一个方法**

**// 可以在调用原始的方法之前和之后记录日志消息**

***\*function\**** trace***\*(\****o***\*,\**** m***\*)\**** ***\*{\**** 

 ***\*var\**** original ***\*=\**** o***\*[\****m***\*];\**** **//在闭包中保存原始方法**

 o***\*[\****m***\*]\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** **//定义新的方法**

  console.***\*log\*******\*(new\**** ***\*Date\*******\*(),\**** **"Entering:"\******,\**** m***\*);\**** **//输出日志消息**

  ***\*var\**** result ***\*=\**** original.***\*apply\*******\*(\*******\*this\*******\*,\**** ***\*arguments\*******\*);\**** **//调用原始函数**

  console.***\*log\*******\*(new\**** ***\*Date\*******\*(),\**** **"Exiting:"\******,\**** m***\*);\**** **//输出日志消息**

  ***\*return\**** result***\*;\**** **//返回结果**

 ***\*};\****

***\*}\****

泛函数在这里特指一种变换，以函数为输入，输出可以是值也可以是另一个函数，泛函的概念可以参照: http://zh.wikipedia.org/wiki/泛函数。

当方法的返回是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（通常称为“链”或者“级联”）每次的调用结果都是另外一个表达式的组成部分。比如，基于jQuery库，我们常常会这样写代码：

 // 找到所有的header，取得它们id的映射，转换为数组并对它们进行排序

$(":header").map(function(){ return this.id}).get().sort();

当方法并不需要返回值时，最好直接返回this。如果在设计的API中一直采用这种方式（每个方法都返回this），使用 API就可以进行“链式”调用风格的编程，在这种编程风格中，只需指定一次要调用的对象即可，余下的方法都可以基于此进行调用：

shape.setX(100).setY(100).setSize(So).setOutline("red").setFill("blue").draw();

***\*不要将方法的链式调用和构造函数的链式调用混为一谈\****。

### ***\*实参和形参\****

**// 将对象o中可枚举的属性名追加至数组a中，并返回这个数组a**

**// 如果省略a，则创建一个新数组并返回这个新数组**

***\*function\**** getPropertyNames***\*(\****o***\*,\**** **/\* optional \*/** a***\*)\**** ***\*{\**** 

 **// if (a === undefined) a = []; //如果未定义，则使用新数组**

 a ***\*=\**** a ***\*||\**** ***\*[];\****

 ***\*for\**** ***\*(\*******\*var\**** property ***\*in\**** o***\*)\**** a.***\*push\*******\*(\****property***\*);\**** 

 ***\*return\**** a***\*;\**** 

}

**// 这个函数调用可以传入1个或2个实参**

***\*var\**** a ***\*=\**** getPropertyNames***\*(\****o***\*);\**** **// 将o的属性存储到一个新数组中**

getPropertyNames***\*(\****p***\*,\**** a***\*);\**** **// 将p的属性追加至数组a中**

需要注意的是，使用"||"运算符代替if语句的前提是a必须预先声明，否则a = a||[] 会报引用错误，在这个例子中a是作为形参传入的，相当于var a，即已经声明了a，所以这样用是没有问题的。

在函数中使用***\*arguments\****可以获取实参列表。不定实参函数示例：

***\*function\**** ***\*max\*******\*(\******/\* ... \*/\******}\**** ***\*{\**** 

 ***\*var\**** ***\*max\**** ***\*=\**** ***\*Number\****.***\*NEGATIVE_INFINITY\*******\*;\**** 

 **//遍历实参，查找并记住最大值**

 ***\*for\**** ***\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** 

  ***\*if\**** ***\*(\*******\*arguments\*******\*[\****i***\*]\**** ***\*>\**** ***\*max\*******\*)\**** ***\*max\**** ***\*=\**** ***\*arguments\*******\*[\****i***\*];\**** 

 **//返回最大值**

 ***\*return\**** ***\*max\*******\*;\****

***\*}\**** 

***\*var\**** largest ***\*=\**** ***\*max\*******\*(\*******\*1\*******\*,\**** ***\*10\*******\*,\**** ***\*100\*******\*,\**** ***\*2\*******\*,\**** ***\*3\*******\*,\**** ***\*1000\*******\*,\**** ***\*4\*******\*,\**** ***\*5\*******\*,\**** ***\*10000\*******\*,\**** ***\*6\*******\*};\**** **// => 10000** 

非严格模式下，ECMAScript标准规范规定callee属性指代当前正在执行的函数。

caller是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过caller属性可以访问调用栈。

callee属性某些时候很有用，比如在匿名函数中通过callee来递归地调用自身。

***\*var\**** factorial ***\*=\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** 

 ***\*if\**** ***\*(\*******\*x\**** <***\*=\**** ***\*1\*******\*)\**** ***\*return\**** ***\*1\*******\*;\**** 

 ***\*return\**** ***\*x\**** ***\**\**** ***\*arguments\****.***\*callee\*******\*(\*******\*x\*******\*-\*******\*1\*******\*);\****

***\*}\**** 

将对象属性用作实参可以写出更好的代码

**//将原始数组的length元素复制至目标数组**

**//开始复制原始数组的from_start:元素**

**//并且将其复制至目标数组的to_start中**

**//要记住实参的顺序并不容易**

***\*function\**** arraycopy***\*(\******/\* array \*/** from***\*,\**** **/\* index \*/** from_start***\*,\**** 

​          **/\* array \*/** to***\*,\**** **/\* index \*/** to_start***\*,\**** 

​          **/\* integer \*/** ***\*length\*******\*)\**** ***\*{\**** 

 **//逻辑代码**

***\*}\**** 

**//这个版本的实现效率稍微有些低，但你不必再去记住实参的顺序**

**//并且from_start和to_start都默认为0**

***\*function\**** easycopy***\*(\****args***\*)\**** ***\*{\**** 

 arraycopy***\*(\****args.from***\*,\**** 

​      args.from_start ***\*||\**** ***\*0\*******\*,\**** **//注意这里设置了默认值**

​      args.to***\*,\****

​      args.to_start ***\*||\**** ***\*0\*******\*,\**** args.***\*length\*******\*);\****

***\*}\**** 

**//来看如何调用easycopy()**

***\*var\**** a ***\*=\**** ***\*[\*******\*1\*******\*,\**** ***\*2\*******\*,\**** ***\*3\*******\*,\**** ***\*4\*******\*],\**** b ***\*=\**** ***\*[];\**** 

easycopy***\*({\**** from***\*:\**** a***\*,\**** to***\*:\**** b***\*,\**** ***\*length\*******\*:\**** ***\*4\**** ***\*});\****

在函数中判断实参类型，进行相应处理

**//返回数组(或类数组对象)a的元素的累加和**

**//数组a中必须为数字、null和undefined的元素都将忽略**

***\*function\**** sum***\*(\****a***\*)\**** ***\*{\**** 

 ***\*if\**** ***\*(\****isArrayLike***\*(\****a***\*))\**** ***\*{\**** 

  ***\*var\**** total ***\*=\**** ***\*0\*******\*;\**** 

  ***\*for\**** ***\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** a.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** **//遍历所有元素**

   ***\*var\**** ***\*element\**** ***\*=\**** a***\*[\****il***\*;\**** 

   ***\*if\**** ***\*(\*******\*element\**** ***\*==\**** ***\*null\*******\*)\**** ***\*continue\*******\*;\**** **//跳过null和undefined**

   ***\*if\**** ***\*(\*******\*isFinite\*******\*(\*******\*element\*******\*))\**** total ***\*+=\**** ***\*element\*******\*;\**** 

   ***\*else\**** ***\*throw\**** ***\*new\**** Error***\*(\******"sum(): elements must be finite numbers"\******);\**** 

  ***\*}\****

  ***\*return\**** total***\*;\****

 ***\*}\**** 

 ***\*else\**** ***\*throw\**** ***\*new\**** Error***\*(\******"sum(): argument must be array-like"\******);\****

***\*}\**** 

 

***\*function\**** flexisum***\*(\****a***\*)\**** ***\*{\**** 

 ***\*var\**** total ***\*=\**** ***\*0\*******\*;\**** 

 ***\*for\**** ***\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** 

  ***\*var\**** ***\*element\**** ***\*=\**** ***\*arguments\*******\*[\****i***\*],\**** n***\*;\**** 

  ***\*if\**** ***\*(\*******\*element\**** ***\*==\**** ***\*null\*******\*)\**** ***\*continue\*******\*;\**** **//忽略null和undefined实参**

  ***\*if\**** ***\*(\****isArray***\*(\*******\*element\*******\*))\**** **//如果实参是数组**

   n ***\*=\**** flexisum.***\*apply\*******\*(\*******\*this\*******\*,\**** ***\*element\*******\*);\**** **//递归地计算累加和**

  ***\*else\**** ***\*if\**** ***\*(typeof\**** ***\*element\**** ***\*===\**** **"function"\******)\**** **//否则，如果是函数...**

   n ***\*=\**** ***\*Number\*******\*(\*******\*element\*******\*());\**** **//调用它并做类型转换**

  ***\*else\**** 

   n ***\*=\**** ***\*Number\*******\*(\*******\*element\*******\*);\**** **//否则直接做类型转换**

  ***\*if\**** ***\*(\*******\*isNaN\*******\*(\****n***\*))\**** **//如果无法转换为数字，则抛出异常**

   ***\*throw\**** Error***\*(\******"f1exisum(): can't convert "** ***\*+\**** ***\*element\**** ***\*+\**** **" to number"\******);\**** 

  total ***\*+=\**** n***\*;\**** **//否则，将n累加至total**

 ***\*}\****

 ***\*return\**** total***\*;\****

***\*}\**** 

### ***\*作为\*******\*值的函数\****

// We define some simple functions here（在这里定义一些简单的函数）***\*function\**** add***\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x ***\*+\**** y***\*;\**** ***\*}\*******\*function\**** subtract***\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x ***\*-\**** y***\*;\**** ***\*}\*******\*function\**** multiply***\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x ***\**\**** y***\*;\**** ***\*}\*******\*function\**** divide***\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x ***\*/\**** y***\*;\**** ***\*}\**** // Here's a function that takes one of the above functions// as an argument and invokes it on two operands// 这里的函数以上面某个函数为参数并传入两个操作数后调用它***\*function\**** operate***\*(\****operator***\*,\**** operand1***\*,\**** operand2***\*)\**** ***\*{\****  ***\*return\**** operator***\*(\****operand1***\*,\**** operand2***\*);\*******\*}\**** // We could invoke this function like this to compute the value (2+3) + (4*5):// 这行代码所示的函数实际上计算了(2+3) + (4*5)***\*var\**** i ***\*=\**** operate***\*(\****add***\*,\**** operate***\*(\****add***\*,\**** 2***\*,\**** 3***\*),\**** operate***\*(\****multiply***\*,\**** 4***\*,\**** 5***\*));\**** // For the sake of the example, we implement the simple functions again, // this time using function literals within an object literal;// 我们为这个例子重复实现一个简单的函数。这次实现使用函数直接量，这些函数直接量定义在一个对象直接量中***\*var\**** operators ***\*=\**** ***\*{\****  add***\*:\****   ***\*function\*******\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x***\*+\****y***\*;\**** ***\*},\****  subtract***\*:\**** ***\*function\*******\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x***\*-\****y***\*;\**** ***\*},\****  multiply***\*:\**** ***\*function\*******\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x***\**\****y***\*;\**** ***\*},\****  divide***\*:\****  ***\*function\*******\*(\****x***\*,\****y***\*)\**** ***\*{\**** ***\*return\**** x***\*/\****y***\*;\**** ***\*},\****  pow***\*:\****   Math***\*.\****pow  // Works for predefined functions too（使用预定义的函数）***\*};\**** // This function takes the name of an operator, looks up that operator// in the object, and then invokes it on the supplied operands. Note// the syntax used to invoke the operator function.// 这个函数接收一个名字作为运算符，在对象中查找这个运算符，然后将它作用于所提供的操作数，注意这里调用运算符函数的语法***\*function\**** operate2***\*(\****operation***\*,\**** operand1***\*,\**** operand2***\*)\**** ***\*{\****  ***\*if\**** ***\*(\*******\*typeof\**** operators***\*[\****operation***\*]\**** ***\*===\**** "function"***\*)\****    ***\*return\**** operators***\*[\****operation***\*](\****operand1***\*,\**** operand2***\*);\****  ***\*else\**** ***\*throw\**** "unknown operator"***\*;\*******\*}\**** // Compute the value ("hello" + " " + "world") like this:***\*var\**** j ***\*=\**** operate2***\*(\****"add"***\*,\**** "hello"***\*,\**** operate2***\*(\****"add"***\*,\**** " "***\*,\**** "world"***\*));\****// Using the predefined Math.pow() function:***\*var\**** k ***\*=\**** operate2***\*(\****"pow"***\*,\**** 10***\*,\**** 2***\*);\****

***\*自定义函数\*******\*属性\****

一个非常有用的功能，因为函数也是对象，所以如果只在调用这个函数时需要获取一个“记录”值，那么可以使用它。它可以替代全局变量。

示例：缓存结果

//初始化函数对象的计数器属性//由于函数声明被提前了，因此这里是可以在函数声明//之前给它的成员赋值的uniquelnteger***\*.\****counter ***\*=\**** O***\*;\**** //每次调用这个函数都会返回一个不同的整数//它使用一个属性来记住下一次将要返回的值***\*function\**** uniquelnteger***\*()\**** ***\*{\**** ***\*return\**** uniquelnteger***\*.\****counter***\*++;\**** //先返回计数器的值，然后计数器自增1***\*}\**** //计算阶乘，并将结果缓存至函数的属性中***\*function\**** factorial***\*(\****n***\*)\**** ***\*{\**** ***\*if\**** ***\*(\****isFinite***\*(\****n***\*)\**** ***\*&&\**** n***\*>\****0 ***\*&&\**** n***\*==\****Math***\*.\****round***\*(\****n***\*))\**** ***\*{\**** //有限的正整数		***\*if\**** ***\*(!(\****n ***\*in\**** factorial***\*))\**** //如果没有缓存结果			factorial***\*[\****n***\*]\**** ***\*=\**** n ***\**\**** factorial***\*(\****n***\*-\****1***\*);\**** //计算结果并缓存之		***\*return\**** factorial***\*[\****n***\*];\**** //返回缓存结果	***\*}\**** ***\*else\**** ***\*return\**** NaN***\*;\**** //如果输入有误factorial***\*[\****1***\*]\**** ***\*=\**** 1***\*;\**** //初始化缓存以保存这种基本情况

 

### ***\*作为命名空间的函数\****

我们常常简单地定义一个函数用做临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。

***\*function\**** mymodule***\*()\**** ***\*{\**** // 模块代码	// 这个模块所使用的所有变量都是局部变量	// 而不是污染全局命名空间***\*}\****mymodule***\*();\**** //不要忘了还要调用这个函数// 这段代码仅仅定义了一个单独的全局变量: 名叫 "mymodule" 的函数。这样还是太麻烦，可以直接定义一个匿名函数，并在单个表达式中调用它：***\*(\*******\*function\*******\*()\**** ***\*{\**** //mymodule()函数重写为匿名的函数表达式	// 模块代码***\*}());\**** //结束函数定义并立即调用它// 这种定义匿名函数并立即在单个表达式中调用它的写法非常常见，已经成为一种惯用法了。

### ***\*闭包\****

JS采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数***\*定义\****时决定的。

函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为“闭包”。

闭包的特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。

***\*var\**** scope ***\*=\**** "global scope"***\*;\**** //全局变量***\*function\**** checkscope***\*()\**** ***\*{\**** ***\*var\**** scope ***\*=\**** "local scope"***\*;\**** //局部变量	***\*function\**** f***\*()\**** ***\*{\**** ***\*return\**** scope***\*;\**** ***\*}\**** //在作用域中返回这个值	***\*return\**** f***\*();\**** ***\*}\****checkscope***\*()\**** // =>  "local scope"  ***\*var\**** scope ***\*=\**** "global  scope"***\*;\**** //全局变量***\*function\**** checkscope***\*()\**** ***\*{\**** ***\*var\**** scope ***\*=\**** "local scope"***\*;\**** //局部变量	***\*function\**** f***\*()\**** ***\*{\**** ***\*return\**** scope***\*;\**** ***\*}\**** //在作用域中返回这个值	***\*return\**** f***\*;\*******\*}\****	checkscope***\*()()\**** //返回值是什么？ "local scope" var uniqueInteger = (function(){ //定义函数并立即调用 var counter = 0; //函数的私有状态 return function() { return counter++; }; //当外部函数返回后，只有内部函数才能访问变量counter}()); //同一个外部函数内定义的多个嵌套函数共享一个作用域链function counter() { var n = 0; return {  count: function() { return n++; },  reset: function() { n = 0 }  };  }var c = counter(), d = counter(); //创建两个计数器//每次调用counter()都会创建一个新的作用域链和一个新的私有变量c.count() //=>0d.count() //=>0，它们互不干扰c.reset() //reset()和count()方法共享状态c.count() //=>0，因为我们重置了cd.count() //=>1，没有重置d //可以将闭包合并到属性存取器方法getter和setterfunction counter(n) { //函数参数n是一个私有变量 //属性getter方法返回并给私有计数器递增1 get count() { return n++; } //属性setter不允许n递减 set count(m){  if(m>=n) n=m;  else throw Error("count can only be set to a larger value");   };}var c = counter(1000);c.count //=>1000c.count //=>1001c.count = 2000c.count //=>2000c.count = 2000 //=>Error! //常见错误//返回一个函数组成数组，它们的返回值是0～9function constfuncs(){ var func = []; for(var i=0;i<10;i++){  func[i] = function(){ return i; };  }  return funcs;}var func = constfuncs();func[5]() //=>10，为什么？//外部函数constfuncs返回时，变量i的值是10，所有闭包共享这个值，所以... //内部函数可以直接访问外部函数的参数，局部变量，但是不能直接访问外部函数的this、arguments

Peter Mortensen问：

就像老Albert所说的，“如果你不能向一个六岁的孩子解释清楚，那么其实你自己根本就没弄懂。”好吧，我试着向一个27岁的朋友解释JS闭包（JavaScript closure）却彻底失败了。

你们会怎么把它解释给一个充满好奇心的六岁孩子听呢？

注：我看过StackOverflow上给出的示例，但根本没用。

　　Ali的回答：

　　当function里嵌套function时，内部的function可以访问外部function里的变量。

function foo(x) {  var tmp = 3;  function bar(y) {    alert(x + y + (++tmp));  }  bar(10); } foo(2)

　　不管执行多少次，都会alert 16，因为bar能访问foo的参数x，也能访问foo的变量tmp。

　　但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。

function foo(x) {

var tmp = 3;  return function (y) {    alert(x + y + (++tmp));  } } var bar = foo(2); // bar 现在是一个闭包 bar(10);

　　上面的脚本最终也会alert 16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。

　　但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1.

　　（考虑到六岁这个限制：我们其实可以建立不止一个闭包方法，比如return它们的数组，也可以把它们设置为全局变量。它们全都指向相同的x和相同的tmp，而不是各自有一份副本。）

　　注：现在来整点儿七岁的内容。

　　上面的x是一个字面值（值传递），和JS里其他的字面值一样，当调用foo时，实参x的值被复制了一份，复制的那一份作为了foo的参数x。

　　那么问题来了，JS里处理object时是用到引用传递的，那么，你调用foo时传递一个object，foo函数return的闭包也会引用最初那个object！

function foo(x) { var tmp = 3; return function (y) {  alert(x + y + tmp);  x.memb = x.memb ? x.memb + 1 : 1;  alert(x.memb); }

}

var age = new Number(2);

var bar = foo(age); // bar 现在是一个引用了age的闭包

bar(10);

　　不出我们意料，每次运行bar(10)，x.memb都会自加1。但需要注意的是x每次都指向同一个object变量age，运行两次bar(10)后，age.memb会变成2

　　这和HTML对象的内存泄漏有关，呃，不过貌似超出了答题的范围。

　　JohnMerlino 对Ali说：

　　这里有一个不用return关键字的闭包例子：

function closureExample(objID, text, timedelay) {     setTimeout(function() {       document.getElementById(objID).innerHTML = text;     }, timedelay);   }   closureExample('myDiv', 'Closure is created', 500);

　　深夜1:37 John Pick这样回答：

　　JS里的function能访问它们的：

1. 参数
2. 局部变量或函数
3. 外部变量（环境变量？），包括

​		3.1 全局变量，包括DOM。

​		3.2 外部函数的变量或函数。

　　如果一个函数访问了它的外部变量，那么它就是一个闭包。

　　注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。

　　一个典型的例子就是全局变量的使用。

　　mykhal这样回答：

　　Wikipedia对闭包的定义是这样的：

In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.

　　从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。

　　Since ***\*scope-defining construction in Javascript is a function\****, not a code block like in many other languages, ***\*what we usually mean by\**** ***\**closure\**\*** ***\*in Javascript\**** is a ***\*fuction working with nonlocal variables defined in already executed surrounding function\****.

　　闭包经常用于创建含有隐藏数据的函数（但并不总是这样）。

var db = (function() { // 创建一个隐藏的object, 这个object持有一些数据 // 从外部是不能访问这个object的 var data = {}; // 创建一个函数, 这个函数提供一些访问data的数据的方法 return function(key, val) {  if (val === undefined) { return data[key] } // get  else { return data[key] = val } // set } // 我们可以调用这个匿名方法 // 返回这个内部函数，它是一个闭包

})();

db('x'); // 返回 undefined

db('x', 1); // 设置data['x']为1

db('x'); // 返回 1

// 我们不可能访问data这个object本身

// 但是我们可以设置它的成员

　　对闭包的总结如下：

（1）闭包是一种设计原则，它通过分析上下文，来简化用户的调用，让用户在不知晓的情况下，达到他的目的；

（2）网上主流的对闭包剖析的文章实际上是和闭包原则反向而驰的，如果需要知道闭包细节才能用好的话，这个闭包是设计失败的；

（3）尽量少学习。

 

### ***\*函数属性、方法和构造函数\****

length属性

函数的length属性是只读属性，它代表函数***\*形\*******\*参\****的数量，也就是在函数定义时给出的参数（形参）个数，通常也是在函数调用时期望传入参数（实参）个数。

**// 这个函数使用arguments.callee，因此它不能在严格模式下工作**

***\*function\**** check***\*(\****args***\*)\**** ***\*{\**** 

  ***\*var\**** actual ***\*=\**** args.***\*length\*******\*;\**** **//实参的真实个数**

  ***\*var\**** expected ***\*=\**** args.***\*callee\****.***\*length\*******\*;\**** **//期望的实参个数\****（形参个数，****args.callee****返回****当前调用函数）**

  ***\*if\**** ***\*(\****actual ***\*!==\**** expected***\*)\**** **//如果不同则抛出异常**

​    ***\*throw\**** Error***\*(\******"Expected  "** ***\*+\**** expected ***\*+\**** **"args; got "** ***\*+\**** actual***\*);\**** 

***\*}\****

***\*function\**** f***\*(\*******\*x\*******\*,\**** ***\*y\*******\*,\**** z***\*)\**** ***\*{\**** 

  check***\*(\*******\*arguments\*******\*);\**** **//检查实参个数和\****形参****个数是否一致**

  ***\*return\**** ***\*x\**** ***\*+\**** ***\*y\**** ***\*+\**** z***\*;\**** **//再执行函数的后续逻辑**

***\*}\****

prototype属性

每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称做“原型对象” (prototype object)。

每一个函数都包含不同的原型对象。当将函数用做构造函数的时候，新创建的对象会从原型对象上继承属性。 

[call()和apply()](#call和apply)

bind()方法

在ECMAScript 5 中新增的方法，但在ECMAScript 3 中可以轻易模拟。

主要作用就是将函数绑定至某个对象。

当在函数f()上调用bind()方法并传入一个对象作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数f()当做o的方法来调用。传入新函数的任何实参都将传入原始函数，比如：

***\*function\**** f***\*(\*******\*y\*******\*)\**** ***\*{\**** ***\*return\**** ***\*this\****.***\*x\**** ***\*+\**** ***\*y\*******\*;\**** ***\*}\**** **//这个是待绑定的函数**

***\*var\**** o ***\*=\**** ***\*{\**** ***\*x\**** ***\*:\**** ***\*1\**** ***\*};\**** **//将要绑定的对象**

***\*var\**** g ***\*=\**** f.bind***\*(\****o***\*);\**** **//通过调用g(x)来调用o.f(x)**

g***\*(\*******\*2\*******\*)\**** **// => 3** 

 

// 可以通过如下代码轻易地实现这种绑定

**// 返回一个函数，通过调用它来调用o中的方法f()，传递它所有的实参**

***\*function\**** bind***\*(\****f***\*,\**** o***\*)\**** ***\*{\**** 

  ***\*if\**** ***\*(\****f.bind***\*)\**** ***\*return\**** f.bind***\*(\****o***\*);\**** **//如果bind()方法存在的话，使用bind()方法**

  ***\*else\**** ***\*return\**** ***\*function\*******\*()\**** ***\*{\**** **//否则，这样绑定**

​    ***\*return\**** f.***\*apply\*******\*(\****o***\*,\**** ***\*arguments\*******\*);\****

  ***\*};\****

***\*}\****

ECMAScript 5 中的bind()方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用：除了第一个实参之外，传入bind()的实参也会绑定至this，这个附带的应用是一种常见的函数式编程技术，有时也被称为“***\*柯里化\****”(currying)。

***\*var\**** sum ***\*=\**** ***\*function\*******\*(\*******\*x\*******\*,\**** ***\*y\*******\*)\**** ***\*{\**** ***\*return\**** ***\*x\**** ***\*+\**** ***\*y\**** ***\*};\**** **//返回两个实参的和值**

**// 创建一个类似sum的新函数，但this的值绑定到null**

**// 并且第一个参数绑定到1，这个新的函数期望只传入一个实参**

***\*var\**** succ ***\*=\**** sum.bind***\*(\*******\*null\*******\*,\**** ***\*1\*******\*);\**** 

succ***\*(\*******\*2\*******\*)\**** **// => 3: x绑定到1，并传入2作为实参y**

 

***\*function\**** f***\*(\*******\*y\*******\*,\**** z***\*)\**** ***\*{\**** ***\*return\**** ***\*this\****.***\*x\**** ***\*+\**** ***\*y\**** ***\*+\**** z ***\*};\**** **//另外一个做累加计算的函数**

***\*var\**** g ***\*=\**** f.bind***\*({\*******\*x\*******\*:\*******\*1\*******\*},\**** ***\*2\*******\*);\**** **//绑定this和y**

g***\*(\*******\*3\*******\*)\**** **// => 6: this.x绑定到1，y绑定至2，z绑定到3**

ECMAScript 3版本的Function.bind()方法

***\*if\**** ***\*(!\*******\*Function\****.***\*prototype\****.bind***\*)\**** ***\*{\****

  ***\*Function\****.***\*prototype\****.bind ***\*=\**** ***\*function\*******\*(\****o **/\*, args \*/\******)\**** ***\*{\****

​    **// Save the this and arguments values into variables so we can**

​    **// use them in the nested function below.**

​    ***\*var\**** ***\*self\**** ***\*=\**** ***\*this\*******\*,\**** boundArgs ***\*=\**** ***\*arguments\*******\*;\****

​    **// The return value of the bind() method is a function**

​    ***\*return\**** ***\*function\*******\*()\**** ***\*{\****

​      **// Build up an argument list, starting with any args passed**

​      **// to bind after the first one, and follow those with all args**

​      **// passed to this function.**

​      ***\*var\**** args ***\*=\**** ***\*[],\**** i***\*;\****

​      ***\*for\*******\*(\****i ***\*=\**** ***\*1\*******\*;\**** i ***\*<\**** boundArgs.***\*length\*******\*;\**** i***\*++)\**** args.***\*push\*******\*(\****boundArgs***\*[\****i***\*]);\****

​      ***\*for\*******\*(\****i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** args.***\*push\*******\*(\*******\*arguments\*******\*[\****i***\*]);\****

​      **// Now invoke self as a method of o, with those arguments**

​      ***\*return\**** ***\*self\****.***\*apply\*******\*(\****o***\*,\**** args***\*);\****

​    ***\*};\****

  ***\*};\****

***\*}\****

toString()方法

和所有的JavaScript对象一样，函数也有toString()方法，ECMAScript规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的toString()方法的实现都返回函数的完整源码。内置函数往往返回一个类似"[native code]" 的字符串作为函数体。

Function()

函数定义除了使用关键字function，还可以通过Function()构造函数定义

var f = new Function("x", "y", "return x*y;"); 

这一行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价：

var f = function(x, y) { return x*y; }

Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的JavaScript语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串一一函数体一一即可。

注意，Function() 构造函数并不需要通过传入实参以指定函数名。就像函数直接量一样，Function()构造函数创建一个匿名函数。

关于Function() 构造函数有几点需要特别注意: 

Function() 构造函数允许JavaScript在运行时动态地创建并编译函数。

每次调用Function() 构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。

最后一点，也是关于Function()构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数（也就是全局作用域）执行，正如下面代码所示：

***\*var\**** scope ***\*=\**** "global"***\*;\**** ***\*function\**** constructFunction***\*()\**** ***\*{\**** ***\*var\**** scope ***\*=\**** "local"***\*;\**** ***\*return\**** ***\*new\**** Function***\*(\****"return scope"***\*);\**** //无法捕获局部作用域***\*}\**** //这一行代码返回global，因为通过Function()构造函数//所返回的函数使用的不是局部作用域constructFunction***\*()();\**** // => "global"

可调用的对象

可调用的对象(callable object)是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调用对象都是函数。

如果想检测一个对象是否是真正的函数对象：

***\*function\**** isFunction***\*(\*******\*x\*******\*)\**** ***\*{\**** 

 ***\*return\**** ***\*Object\****.***\*prototype\****.***\*toString\****.***\*call\*******\*(\*******\*x\*******\*)\**** ***\*===\**** **"[object Function]"\******;\**** 

***\*}\****

### ***\*函数式编程\****

和Lisp、Haskell不同，JavaScript并非函数式编程语言，但在JavaScript中可以像操控对象一样操控函数，也就是说可以在JavaScript中应用函数式编程技术。

如果你对这部分内容感兴趣，椎荐你使用一下（至少阅读一下）奥利弗·斯蒂尔（Oliver Steele）的函数式JavaScript库，请参照: http://osteele.com/sources/javascript/functional/ 。

假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样：

***\*var\**** ***\*data\**** ***\*=\**** ***\*[\*******\*1\*******\*,\**** ***\*1\*******\*,\**** ***\*3\*******\*,\**** ***\*5\*******\*,\**** ***\*5\*******\*];\**** **//这里是待处理的数组**

**// 平均数是所有元素的累加和值除以元素个数**

***\*var\**** total ***\*=\**** ***\*0\*******\*;\****

***\*for\*******\*(\*******\*var\**** i ***\*=\**** O***\*;\**** i ***\*<\**** ***\*data\****.***\*length\*******\*;\**** i***\*++)\**** total ***\*+=\**** ***\*data\*******\*[\****i***\*];\**** 

***\*var\**** mean ***\*=\**** total***\*/\*******\*data\****.***\*length\*******\*;\**** **//平均数是3**

**// 计算标准差，首先计算每个数据减去平均数之后偏差的平方然后求和**

total ***\*=\**** O***\*;\**** 

***\*for\*******\*(\*******\*var\**** i ***\*=\**** O***\*;\**** i ***\*<\**** ***\*data\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** 

 ***\*var\**** deviation ***\*=\**** ***\*data\*******\*[\****i***\*]\**** ***\*-\**** mean***\*;\**** 

 total ***\*+=\**** deviation ***\**\**** deviation***\*;\**** 

***\*}\****

***\*var\**** stddev ***\*=\**** ***\*Math\****.***\*sqrt\*******\*(\****total***\*/(\*******\*data\****.***\*length\*******\*-\*******\*1\*******\*));\**** **//标准差的值是 2**

可以使用数组方法map()和reduce()来实现同样的计算，这种实现极其简洁：

**// 首先定义两个简单的函数**

***\*var\**** sum  ***\*=\**** ***\*function\*******\*(\*******\*x\*******\*,\**** ***\*y\*******\*)\**** ***\*{\**** ***\*return\**** ***\*x\**** ***\*+\**** ***\*y\*******\*;\**** ***\*};\**** 

***\*var\**** square  ***\*=\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** ***\*return\**** ***\*x\**** ***\**\**** ***\*x\*******\*;\**** ***\*};\**** 

**// 然后将这些函数和数组方法配合使用计算出平均数和标准差**

***\*var\**** ***\*data\**** ***\*=\**** ***\*[\*******\*1\*******\*,\**** ***\*1\*******\*,\**** ***\*3\*******\*,\**** ***\*5\*******\*,\**** ***\*5\*******\*];\**** 

***\*var\**** mean  ***\*=\**** ***\*data\****.reduce***\*(\****sum***\*)/\*******\*data\****.***\*length\*******\*;\**** 

***\*var\**** deviations  ***\*=\**** ***\*data\****.map***\*(\*******\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\*******\*return\**** ***\*x\**** ***\*-\**** mean***\*; });\**** 

***\*var\**** stddev  ***\*=\**** ***\*Math\****.***\*sqrt\*******\*(\****deviations.map***\*(\****square***\*)\****.reduce***\*(\****sum***\*)/(\*******\*data\****.***\*length\*******\*-\*******\*1\*******\*));\**** 

如果我们基于ECMAScript 3 来如何实现呢？因为ECMAScript 3 中并不包含这些数组方法，如果不存在内置方法的话我们可以自定义map()和reduce()函数：

**//** **对于每个数组元素调用函数f()，并返回一个结果数组**

**//** **如果Array.prototype.map定义了的话，就使用这个方法**

***\*var\**** map  ***\*=\**** ***\*Array\****.***\*prototype\****.map 

​      ***\*?\**** ***\*function\*******\*(\****a***\*,\**** f***\*)\**** ***\*{\**** ***\*return\**** a.map***\*(\****f***\*);\**** ***\*}\**** **//如果已经存在map()方法，就直接使用它**

​      ***\*:\**** ***\*function\*******\*(\****a***\*,\**** f***\*)\**** ***\*{\**** **//否则，自己实现一个**

​       ***\*var\**** results ***\*=\**** ***\*[];\**** 

​       ***\*for\**** ***\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*,\**** len ***\*=\**** a.***\*length\*******\*;\**** i ***\*<\**** len***\*;\**** i***\*++)\**** ***\*{\**** 

​        ***\*if\**** ***\*(\****i ***\*in\**** a***\*)\**** results***\*[\****i***\*]\**** ***\*=\**** f.***\*call\*******\*(\*******\*null\*******\*,\**** a***\*[\****i***\*],\**** i***\*,\**** a***\*);\**** 

​       ***\*}\****

​       ***\*return\**** results***\*;\****

​      ***\*};\**** 

**//使用函数f()和可选的初始值将数组a减至一个值**

**//如果Array.prototype.reduce存在自的话，就使用这个方法**

***\*var\**** reduce ***\*=\**** ***\*Array\****.***\*prototype\****.reduce 

​       ***\*?\**** ***\*function\*******\*(\****a***\*,\**** f***\*,\**** initial***\*)\**** ***\*{\**** **//如果reduce()方能存在的话**

​        ***\*if\**** ***\*(\*******\*arguments\****.***\*length\**** ***\*>\**** ***\*2\*******\*)\**** 

​         ***\*return\**** a.reduce***\*(\****f***\*,\**** initial***\*);\**** **//如果传入了一个初始值**

​        ***\*else\**** ***\*return\**** a.reduce***\*(\****f***\*);\**** **//否则没有初始值**

​       ***\*:\**** ***\*function\*******\*(\****a***\*,\**** f***\*,\**** initial***\*)\**** ***\*{\**** **//这个算法来自 ES5规范**

​        ***\*var\**** i ***\*=\**** ***\*0\*******\*,\**** len ***\*=\**** a.***\*length\*******\*,\**** accumulator***\*;\**** 

​        **//以特定的初始值开始，否则第一个值取自a**

​        ***\*if\**** ***\*(\*******\*arguments\****.***\*length\**** ***\*>\**** ***\*2\*******\*)\**** accumulator ***\*=\**** initial***\*;\**** 

​        ***\*else\**** ***\*{\**** **//找到数组中第一个已定义的索引**

​         ***\*if\**** ***\*(\****len ***\*==\**** ***\*0\*******\*)\**** ***\*throw\**** TypeError***\*();\**** 

​         ***\*while\**** ***\*(\****i ***\*<\**** len***\*)\**** ***\*{\**** 

​          ***\*if\**** ***\*(\****i ***\*in\**** a***\*)\**** ***\*{\**** 

​           accumulator ***\*=\**** a***\*[\****i***\*++];\**** 

​           ***\*break\*******\*;\**** 

​          ***\*}\**** ***\*else\**** 

​           i***\*++;\****

​         ***\*}\**** 

​         ***\*if\**** ***\*(\****i ***\*==\**** len***\*)\**** ***\*throw\**** TypeError***\*();\**** 

​        ***\*}\****

​        **//对于数组中剩下的元素依次调用f()**

​        ***\*while\**** ***\*(\****i ***\*<\**** len***\*)\**** ***\*{\**** 

​         ***\*if\**** ***\*(\****i ***\*in\**** a***\*)\**** 

​          accumulator ***\*=\**** f.***\*call\*******\*(\****undefined***\*,\**** accumulator***\*,\**** a***\*[\****i***\*],\**** i***\*,\**** a***\*);\**** 

​         i***\*++;\****

​        ***\*}\**** 

​        ***\*return\**** accumulator***\*;\**** 

​       ***\*};\****

**//使用定义的map()和reduce()函数，计算平均值和标准差的代码看起来像这样:**

***\*var\**** ***\*data\**** ***\*=\**** ***\*[\*******\*1\**** ***\*,\**** ***\*1\*******\*,\**** ***\*3\*******\*,\**** ***\*5\*******\*,\**** ***\*5\*******\*];\**** 

***\*var\**** sum ***\*=\**** ***\*function\*******\*(\*******\*x\*******\*,\**** ***\*y\*******\*)\**** ***\*{\**** ***\*return\**** ***\*x\*******\*+\*******\*y\*******\*;\**** ***\*};\**** 

***\*var\**** square ***\*=\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** ***\*return\**** ***\*x\*******\**\*******\*x\*******\*;\**** ***\*};\**** 

***\*var\**** mean ***\*=\**** reduce***\*(\*******\*data\*******\*,\**** sum***\*)/\*******\*data\****.***\*length\*******\*;\**** 

***\*var\**** deviations ***\*=\**** map***\*(\*******\*data\*******\*,\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\*******\*return\**** ***\*x\*******\*-\****mean***\*;});\**** 

***\*var\**** stddev ***\*=\**** ***\*Math\****.***\*sqrt\*******\*(\****reduce***\*(\****map***\*(\****deviations***\*,\**** square***\*),\**** sum***\*)/(\*******\*data\****.***\*length\*******\*-\*******\*1\*******\*));\**** 

所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数。

//这个高阶函数返回一个新的函数，这个新函数将它的实参传人f()//并返回f的返回值的逻辑非***\*function\**** not***\*(\****f***\*)\**** ***\*{\**** ***\*return\**** ***\*function\*******\*()\**** ***\*{\**** //返回一个新的函数		***\*var\**** result ***\*=\**** f***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\**** //调用f()		***\*return\**** ***\*!\****result***\*;\**** //对结果求反	***\*};\*******\*}\*******\*var\**** even ***\*=\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** //判断a是否为偶数的函数	***\*return\**** x***\*%\****2 ***\*===\**** 0***\*;\*******\*}\****	***\*var\**** odd ***\*=\**** not***\*(\****even***\*);\**** //一个新函数，所做的事情和even()相反***\*[\****1***\*,\**** 1***\*,\**** 3***\*,\**** 5***\*,\**** 5***\*].\****every***\*(\****odd***\*);\**** // => true: 每个元素都是奇数

另外一个例子，来看下面的mapper()函数，它也是接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。

//所返回的函数的参数应当是一个实参数组，并对每个数组元素执行函数f()//并返回所有计算结果组成的数组//可以对比一下这个函数和上文提到的map()函数***\*function\**** mapper***\*(\****f***\*)\**** ***\*{\**** ***\*return\**** ***\*function\*******\*(\****a***\*)\**** ***\*{\**** ***\*return\**** map***\*(\****a***\*,\**** f***\*);\**** ***\*};\*******\*}\****	***\*var\**** increment ***\*=\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x***\*+\****1***\*;\**** ***\*};\**** ***\*var\**** incrementer ***\*=\**** mapper***\*(\****increment***\*);\**** incrementer***\*([\****1***\*,\**** 2***\*,\**** 3***\*])\**** // => [2, 3, 4]  //这里是一个更常见的例子，它接收两个函数f()和g()，并返回一个新的函数用以计算f(g())://返回的函数h() 将它所有的实参传人g()，然后将g() 的返回值传人f()//调用f()和g() 时的this值和调用h() 时的this值是同一个this***\*function\**** compose***\*(\****f***\*,\****g***\*)\**** ***\*{\**** ***\*return\**** ***\*function\*******\*()\**** ***\*{\**** 	//需要给f()传入一个参数，所以使用f()的call()方法		//需要给g()传入很多参数，所以使用g()的apply()方法		***\*return\**** f***\*.\****call***\*(\*******\*this\*******\*,\**** g***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*));\**** ***\*};\*******\*}\*******\*var\**** square ***\*=\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x***\**\****x***\*;\**** ***\*};\**** ***\*var\**** sum ***\*=\**** ***\*function\*******\*(\****x***\*,\**** y***\*)\**** ***\*{\**** ***\*return\**** x***\*+\****y***\*;\**** ***\*};\**** ***\*var\**** squareofsum ***\*=\**** compose***\*(\****square***\*,\**** sum***\*);\**** squareofsum***\*(\****2***\*,\****3***\*)\**** // => 25

把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数(partial function)，每次函数调用叫做不完全调用 (partial application)，这种函数变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止，举一个简单的例子，将对函数f(1, 2, 3, 4, 5, 6)的调用修改为等价的f(1, 2)(3, 4)(5, 6)，后者包含三次调用，和每次调用相关的函数就是“不完全函数”。

// 实现一个工具函数将类数组对象(或对象)转换为真正的数组// 在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组***\*function\**** array***\*(\****a***\*,\**** n***\*)\**** ***\*{\**** ***\*return\**** Array***\*.\*******\*prototype\*******\*.\****slice***\*.\****call***\*(\****a***\*,\**** n***\*||\****0***\*);\**** ***\*}\**** // 这个函数的实参传递至左侧***\*function\**** partialLeft***\*(\****f /*, ...*/***\*)\**** ***\*{\**** ***\*var\**** args ***\*=\**** arguments***\*;\**** //保存外部的实参数组	***\*return\**** ***\*function\*******\*()\**** ***\*{\****  //并返回这个函数		***\*var\**** a ***\*=\**** array***\*(\****args***\*,\**** 1***\*);\**** //开始处理外部的第1个args		a ***\*=\**** a***\*.\****concat***\*(\****array***\*(\****arguments***\*));\**** // 然后增加所有的内部实参		***\*return\**** f***\*.\****apply***\*(\*******\*this\*******\*,\**** a***\*);\**** // 然后基于这个实参列表调用f()	***\*};\*******\*}\**** // 这个函数的实参传递至右侧***\*function\**** partialRight***\*(\****f /*, ...*/***\*)\**** ***\*{\**** ***\*var\**** args ***\*=\**** arguments***\*;\**** // 保存外部实参数组	***\*return\**** ***\*function\*******\*()\**** ***\*{\**** // 返回这个函数		***\*var\**** a ***\*=\**** array***\*(\****arguments***\*);\**** //从内部参数开始		a ***\*=\**** a***\*.\****concat***\*(\****array***\*(\****args***\*,\**** 1***\*));\**** //然后从外部第1个args开始添加		***\*return\**** f***\*.\****apply***\*(\*******\*this\*******\*,\**** a***\*);\**** // 最后基于这个实参列表调用f()	***\*};\*******\*}\**** // 这个函数的实参被用做模板// 实参列表中的undefined值都被填充***\*function\**** partial***\*(\****f /*, ... */****)\**** ***\*{\**** ***\*var\**** args ***\*=\**** arguments***\*;\**** //保存外部实参数组	***\*return\**** ***\*function\*******\*()\**** ***\*{\**** 	***\*var\**** a ***\*=\**** array***\*(\****args***\*,\**** 1***\*);\**** //从外部args开始		***\*var\**** i ***\*=\**** 0***\*,\**** j ***\*=\**** 0***\*;\**** 	// 遍历args，从内部实参填充undefined值		***\*for\**** ***\*(;\**** i ***\*<\**** a***\*.\****length***\*;\**** i***\*++)\**** 		***\*if\**** ***\*(\****a***\*[\****i***\*]\**** ***\*===\**** undefined***\*)\**** a***\*[\****i***\*]\**** ***\*=\**** arguments***\*[\****j***\*++];\**** 	// 现在将剩下的内部实参都追加进去		a ***\*=\**** a***\*.\****concat***\*(\****array***\*(\****arguments***\*,\**** j***\*))\**** 	***\*return\**** f***\*.\****apply***\*(\*******\*this\*******\*,\**** a***\*);\**** ***\*};\*******\*}\****// 这个函数带有三个实参***\*var\**** f ***\*=\**** ***\*function\*******\*(\****x***\*,\**** y***\*,\**** z***\*)\**** ***\*{\**** ***\*return\**** x ***\**\**** ***\*(\****y ***\*-\**** z***\*);\**** ***\*};\**** // 注意这三个不完全调用之间的区别partialLeft***\*(\****f***\*,\**** 2***\*)(\****3***\*,\**** 4***\*)\**** // => -2: 绑定第一个实参: 2 * (3 - 4) partialRight***\*(\****f***\*,\**** 2***\*)(\****3***\*,\**** 4***\*)\**** // => 6: 绑定最后一个实参: 3 * (4 - 2) partial***\*(\****f***\*,\**** undefined***\*,\**** 2***\*)(\****3***\*,\**** 4***\*)\**** // => -6: 绑定中间的实参: 3 * (2 - 4) //利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数，参照下面这个例子:***\*var\**** increment ***\*=\**** partialLeft***\*(\****sum***\*,\**** 1***\*);\**** ***\*var\**** cuberoot ***\*=\**** partialRight***\*(\****Math***\*.\****pow***\*,\**** 1***\*/\****3***\*);\**** String***\*.\*******\*prototype\*******\*.\****first ***\*=\**** partial***\*(\****String***\*.\*******\*prototype\*******\*.\****charAt***\*,\**** 0***\*);\**** String***\*.\*******\*prototype\*******\*.\****last ***\*=\**** partial***\*(\****String***\*.\*******\*prototype\*******\*.\****substr***\*,\**** ***\*-\****1***\*,\**** 1***\*);\**** //当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了not()函数，它用到了刚才提到的不完全调用:***\*var\**** not ***\*=\**** partialLeft***\*(\****compose***\*,\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** ***\*!\****x***\*;\**** ***\*});\**** ***\*var\**** even ***\*=\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x***\*%\****2 ***\*===\**** 0***\*;\**** ***\*};\**** ***\*var\**** odd ***\*=\**** not***\*(\****even***\*);\**** ***\*var\**** isNumber ***\*=\**** not***\*(\****isNaN***\*)\**** //我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程:***\*var\**** data ***\*=\**** ***\*[\****1***\*,\**** 1***\*,\**** 3***\*,\**** 5***\*,\**** 5***\*];\**** // 我们要处理的数据***\*var\**** sum ***\*=\**** ***\*function\*******\*(\****x***\*,\**** y***\*)\**** ***\*{\**** ***\*return\**** x ***\*+\**** y***\*;\**** ***\*};\**** // 两个初等函数***\*var\**** product ***\*=\**** ***\*function\*******\*(\****x***\*,\**** y***\*)\**** ***\*{\**** ***\*return\**** x ***\**\**** y***\*;\**** ***\*};\**** ***\*var\**** neg ***\*=\**** partial***\*(\****product***\*,\**** ***\*-\****1***\*);\**** // 定义其他函数***\*var\**** square ***\*=\**** partial***\*(\****Math***\*.\****pow***\*,\**** undefined***\*,\**** 2***\*);\**** ***\*var\**** sqrt ***\*=\**** partial***\*(\****Math***\*.\****pow***\*,\**** undefined***\*,\**** .5***\*);\**** ***\*var\**** reciprocal ***\*=\**** partial***\*(\****Math***\*.\****pow***\*,\**** undefined***\*,\**** ***\*-\****1***\*);\**** // 现在计算平均值和标准差，所有的函数调用都不带运算符// 这段代码看起来很像lisp代码***\*var\**** mean ***\*=\**** product***\*(\****reduce***\*(\****data***\*,\**** sum***\*),\**** reciprocal***\*(\****data***\*.\****length***\*));\**** ***\*var\**** stddev ***\*=\**** sqrt***\*(\****product***\*(\****reduce***\*(\****map***\*(\****data***\*,\**** compose***\*(\****square***\*,\**** partial***\*(\****sum***\*,\**** neg***\*(\****mean***\*))))\**** ***\*,\**** sum***\*),\**** 				reciprocal***\*(\****sum***\*(\****data***\*.\****length***\*,\**** ***\*-\****1***\*))));\****

记忆是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端JavaScript中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。

下面的代码展示了一个高阶函数，memorize()接收一个函数作为实参，并返回带有记忆能力的函数。memorize()函数创建一个新的对象，这个对象被当做缓存(的宿主)并赋值给一个局部变量，因此对于返回的函数来说它是私有的(在闭包中)。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用memorize():

// 返回f()的带有记忆功能的版本// 只有当f()的实参的字符串表示都不相同时它才会工作***\*function\**** memorize***\*(\****f***\*)\**** ***\*{\**** ***\*var\**** cache ***\*=\**** ***\*{};\**** //将值保存在闭包内	***\*return\**** ***\*function\*******\*()\**** ***\*{\**** 	//将实参转换为字符串形式，并将其用做缓存的键		***\*var\**** key ***\*=\**** arguments***\*.\****length ***\*+\**** Array***\*.\*******\*prototype\*******\*.\****join***\*.\****call***\*(\****arguments***\*,\**** ","***\*);\****		***\*if\**** ***\*(\****key ***\*in\**** cache***\*)\**** ***\*return\**** cache***\*[\****key***\*];\****		***\*else\**** ***\*return\**** cache***\*[\****key***\*]\**** ***\*=\**** f***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\**** ***\*};\*******\*}\**** //返回两个整数的最大公约数//使用欧几里德算法 :http://en.wikipedia.org/wiki/Euclidean_algorithm***\*function\**** gcd***\*(\****a***\*,\**** b***\*)\**** ***\*{\**** //这里省略对a和b的类型检查	***\*var\**** t***\*;\**** //临时变量用来存储交换数值	***\*if\**** ***\*(\****a ***\*<\**** b***\*)\**** t***\*=\****b***\*,\**** b***\*=\****a***\*,\**** a***\*=\****t***\*;\**** //确保 a >= b 	***\*while\*******\*(\****b ***\*!=\**** 0***\*)\**** t***\*=\****b***\*,\**** b***\*=\****a***\*%\****b***\*,\**** a***\*=\****t***\*;\**** //这是求最大公约数的欧几里德算法	***\*return\**** a***\*;\*******\*}\****	***\*var\**** gcdmemo ***\*=\**** memorize***\*(\****gcd***\*);\**** gcdmemo***\*(\****85***\*,\**** 187***\*)\**** // => 17 //注意，当我们写一个递归函数时，往往需要实现记忆功能//我们更希望调用实现了记忆功能的递归函数，而不是原递归函数***\*var\**** factorial ***\*=\**** memorize***\*(\*******\*function\*******\*(\****n***\*)\**** ***\*{\**** ***\*return\**** ***\*(\****n ***\*<=\**** 1***\*)\**** ***\*?\**** 1 ***\*:\**** n***\**\****factorial***\*(\****n***\*-\****1***\*);\**** ***\*});\**** factorial***\*(\****5***\*)\**** // => 120. 对于4~1的值也有缓存

 

***\*类和模块\****

在JavaScript中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。 

JavaScript中类的一个重要特性是“动态可继承”(dynamically extendable)

### ***\*类和原型\****

简易的类模拟库：

var Class = function () {  return function () {    this.init.apply(this, arguments);};}; var Person = new Class;Person.prototype.init = function () {  // 基于Person 的实例做初始化};// 用法：var person = new Person;

从这里首先知道调用函数(匿名)的一种方式：

// 1new function () {  console.log("hello");}// 2.另一种方式(function () {  console.log("hello");})()

在JavaScript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。

// range.js: 实现一个能表示值的范围的类// 这个工厂方法返回一个新的“范围对象”***\*function\**** range***\*(\*******\*from\*******\*,\**** to***\*)\**** ***\*{\**** // 使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象	// 原型对象作为函数的一个属性存储，并定义所有“范围对象”所共享的方法（行为）	***\*var\**** r ***\*=\**** inherit***\*(\****range***\*.\****methods***\*);\**** // 存储新的“范围对象”的起始位置和结束位置（状态）	// 这两个属性是不可继承的，每个对象都拥有唯一的属性	r***\*.\*******\*from\**** ***\*=\**** ***\*from\*******\*;\**** r***\*.\****to ***\*=\**** to***\*;\**** // 返回这个新创建的对象	***\*return\**** r***\*;\**** ***\*}\**** // 原型对象定义方法，这些方法为每个范围对象所继承range***\*.\****methods ***\*=\**** ***\*{\**** // 如果 x 在范围内，则返回true，否则返回false  // 这个方法可以比较数字范围，也可以比较字符串和日期范围	includes***\*:\**** ***\*function\**** ***\*(\****x***\*)\**** ***\*{\**** 	***\*return\**** ***\*this\*******\*.\*******\*from\**** ***\*<=\**** x ***\*&&\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** ***\*},\**** // 对于范围内的每个整数都调用一次f	// 这个方法只可用做数字范围	foreach***\*:\**** ***\*function\**** ***\*(\****f***\*)\**** ***\*{\**** 	***\*for\**** ***\*(\*******\*var\**** x ***\*=\**** Math***\*.\****ceil***\*(\*******\*this\*******\*.\*******\*from\*******\*);\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** x***\*++)\**** f***\*(\****x***\*);\**** ***\*},\****	// 返回表示这个范围的字符串	toString***\*:\**** ***\*function\**** ***\*()\**** ***\*{\**** ***\*return\**** "(" ***\*+\**** ***\*this\*******\*.\*******\*from\**** ***\*+\**** "..." ***\*+\**** ***\*this\*******\*.\****to ***\*+\**** ")"***\*; }\**** ***\*};\****// 这里是使用“范围对象”的一些例子***\*var\**** r ***\*=\**** range***\*(\****1***\*,\**** 3***\*);\**** //创建一个范围对象r***\*.\****includes***\*(\****2***\*);\**** //=> true:2在这个范围内r***\*.\****foreach***\*(\****console***\*.\****log***\*);\**** //输出123console***\*.\****log***\*(\****r***\*);\**** //输出(1...3)

我们注意到，这里给range()函数定义了一个属性range.methods，用以快捷地存放定义类的原型对象。把原型对象挂在函数上没什么大不了，但也不是惯用做法。

这个创建对象的方法可以被称为“工厂方法”。

### ***\*类和构造函数\****

使用new调用构造函数会自动创建一个新对象，因此构造函数本身只需初始化这个新对象的状态即可。调用构造函数的一个重要特征是，构造函数的prototype属性被用做新对象的原型。

这里遵循了一个常见的编程约定：从某种意义上讲，定义构造函数即是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。

构造函数调用和普通函数调用是不尽相同的。构造函数就是用来“构造新对象”的，它必须通过关键宇new调用，如果将构造函数用做普通函数的话，往往不会正常工作。开发者可以通过命名约定来（构造函数首字母大写，普通方法首字母小写）判断是否应当在函数之前冠以关键宇new。还有一个非常重要的区别，就是原型对象的命名。上面示例代码中的原型是range.methods。这种命名方式很方便同时具有很好的语义，但又过于随意。在下面示例代码中的原型是Range. prototype。这是一个强制的命名，对Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型。

// range2.jS: 表示值的范围的类的另一种实现// 这是一个构造函数，用以初始化新创建的“范围对象”// 注意，这里并没有创建并返回一个对象，仅仅是初始化***\*function\**** Range***\*(\*******\*from\*******\*,\**** to***\*)\**** ***\*{\**** // 存储“范围对象”的起始位置和结束位置（状态）	// 这两个属性是不可继承的，每个对象都拥有唯一的属性	***\*this\*******\*.\*******\*from\**** ***\*=\**** ***\*from\*******\*;\**** ***\*this\*******\*.\****to ***\*=\**** to***\*;\**** ***\*}\**** // 所有的“范围对象”都继承自这个对象// 注意，属性的名字必须是"prototype"Range***\*.\*******\*prototype\**** ***\*=\**** ***\*{\**** // 如果x在范围内，则返回true；否则返回false	// 这个方法可以比较数字范围，也可以比较字符串和日期范围	includes***\*:\**** ***\*function\**** ***\*(\****x***\*)\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\*******\*from\**** ***\*<=\**** x ***\*&&\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** ***\*},\**** // 对于范围内的每个整数都调用一次f	// 这个方法只可用于数字范围	foreach***\*:\**** ***\*function\**** ***\*(\****f***\*)\**** ***\*{\**** 	***\*for\**** ***\*(\*******\*var\**** x ***\*=\**** Math***\*.\****ceil***\*(\*******\*this\*******\*.\*******\*from\*******\*);\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** x***\*++)\**** f***\*(\****x***\*);\**** ***\*},\**** // 返回表示这个范围的字符串	toString***\*:\**** ***\*function\**** ***\*()\**** ***\*{\**** ***\*return\**** "(" ***\*+\**** ***\*this\*******\*.\*******\*from\**** ***\*+\**** "..." ***\*+\**** ***\*this\*******\*.\****to ***\*+\**** ")"***\*;\**** ***\*}\**** ***\*};\****// 这里是使用“范围对象”的一些例子***\*var\**** r ***\*=\**** ***\*new\**** Range***\*(\****1***\*,\**** 3***\*);\**** //创建一个范围对象r***\*.\****includes***\*(\****2***\*);\**** //=> true:2 在这个范围内r***\*.\****foreach***\*(\****console***\*.\****log***\*);\**** //输出 123console***\*.\****log***\*(\****r***\*);\**** //输出 (1...3)

***\*原型对象是类的唯一标识\****：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。当使用instanceof运算符来检测对象是否属于某个类时会用到构造函数。假设这里有一个对象r，我们想知道r是否是Range对象，我们这样写：

r instanceof Range  //如果r继承自 Range.prototype，则返回true

实际上instanceof运算符并不会检查r是否是由Range()构造函数初始化而来，而会检查r是否继承自 Range.prototype。不过instanceof的语法则强化了“构造函数是类的公有标识”的概念。

上例中为Range.prototype定义一个新对象，其实没必要。任何JavaScript函数都可以用做构造函数，并且调用构造函数需要用到一个prototye属性。因此每个JS函数（ES5的Function.bind()除外）都自动有一个prototype属性，这个属性是一个对象，包含唯一一个不可枚举值constructor。constructor属性的值是一个函数对象：

***\*var\**** F ***\*=\**** ***\*function\*******\*()\**** ***\*{};\**** //这是一个函数对象***\*var\**** p ***\*=\**** F***\*.\*******\*prototype\*******\*;\**** //这是F相关联的原型对象***\*var\**** c ***\*=\**** p***\*.\*******\*constructor\*******\*;\**** //这是与原型相关联的函数c ***\*===\**** F // => true：对于任意函数F.prototype.constructor==F//构造函数的原型中存在预先定义好的constructor属性，这意味着对象通常继承的constructor均指代它们的构造函数。由于构造函数是类的"公共标识"，因此这个constructor属性为对象提供了类。***\*var\**** o ***\*=\**** ***\*new\**** F***\*();\**** //创建类F的一个对象o***\*.\*******\*constructor\**** ***\*===\**** F // => true, constructor属性指代这个类

构造函数及其原型和示例：

![x](file://D:/WorkingDir/Office/Resources/js002.JPG?lastModify=1614742308)

 

 

// 上例中定义的Range类使用它自身的一个新对象重写预定义的Range.prototype对象。这个新定义的原型对象不含有constructor属性。因此Range类的实例也不含有constructor属性。我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：Range***\*.\*******\*prototype\**** ***\*=\**** ***\*{\**** ***\*constructor\*******\*:\**** Range***\*,\**** //显式设置构造函数反向引用	includes***\*:\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\*******\*from\**** ***\*<=\**** x ***\*&&\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** ***\*},\**** foreach***\*:\**** ***\*function\*******\*(\****f***\*)\**** ***\*{\**** 	***\*for\*******\*(\*******\*var\**** x ***\*=\**** Math***\*.\****ceil***\*(\*******\*this\*******\*.\*******\*from\*******\*);\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** x***\*++)\**** f***\*(\****x***\*);\**** ***\*},\**** toString***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** "(" ***\*+\**** ***\*this\*******\*.\*******\*from\**** ***\*+\**** "..." ***\*+\**** ***\*this\*******\*.\****to ***\*+\**** ")"***\*;\**** ***\*}\**** ***\*};\****// 另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含constructor属性，然后依次给原型对象添加方法：// 扩展预定义的Range.prototype对象，而不重写之// 这样就自动创建Range.prototype.constructor属性Range***\*.\*******\*prototype\*******\*.\****includes ***\*=\**** ***\*function\**** ***\*(\****x***\*)\**** ***\*{\*******\*return\**** ***\*this\*******\*.\*******\*from\**** ***\*<=\**** x ***\*&&\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** ***\*};\**** Range***\*.\*******\*prototype\*******\*.\****foreach ***\*=\**** ***\*function\**** ***\*(\****f***\*)\**** ***\*{\**** ***\*for\**** ***\*(\*******\*var\**** x ***\*=\**** Math***\*.\****ceil***\*(\*******\*this\*******\*.\*******\*from\*******\*);\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*;\**** x***\*++)\**** f***\*(\****x***\*);\**** ***\*};\**** Range***\*.\*******\*prototype\*******\*.\****toString ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** "(" ***\*+\**** ***\*this\*******\*.\*******\*from\**** ***\*+\**** "..." ***\*+\**** ***\*this\*******\*.\****to ***\*+\**** ")"***\*;\**** ***\*};\****

### ***\*JavaScript中Java式的类继承\****

JavaScript和Java的一个不同之处在于，JavaScript中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。

JavaScript 中的类牵扯三种不同的对象，三种对象的属性的行为和下面三种类成员非常相似：

l 构造函数对象

之前提到，构造函数（对象）为JavaScript的类定义了名字。任何添加到这个构造函数对象中的属性都是类宇段和类方法（如果属性值是函数的话就是类方法）。

l 原型对象

原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。

l 实例对象

类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。定义在实例上的非函数属性，实际上是实例的字段。

在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。我们可以将这三个步骤封装进一个简单的defineClass()函数中

// 一个用以定义简单类的函数function defineClass(constructor, //用以设置实例的属性的函数					  methods, //实例的方法，复制至原型中					  statics) //类属性，复制至构造函数中{  if (methods) extend(constructor.prototype, methods);  if (statics) extend(constructor, statics);  return constructor;} function extend(o, p) {  for (prop in p) {      // For all props in p.    o[prop] = p[prop];   // Add the property to o.  }  return o;} // 这是Range类的另一个实现var SimpleRange = defineClass(  function (f, t) { this.f = f; this.t = t; },  {	  includes: function (x) { return this.f <= x && x <= this.t; },    toString: function () { return this.f + "..." + this.t; }  },  { upto: function (t) { return new SimpleRange(0, t); } });

下面代码展示了如何使用JavaScript来模拟实现Java式的类成员

/* * Complex.js: * This file defines a Complex class to represent complex numbers. * Recall that a complex number is the sum of a real number and an * imaginary number and that the imaginary number i is the square root of -1. */ /* * This constructor function defines the instance fields r and i on every * instance it creates.  These fields hold the real and imaginary parts of * the complex number: they are the state of the object. */****function\**** Complex***\*(\****real***\*,\**** imaginary***\*)\**** ***\*{\****  ***\*if\**** ***\*(\****isNaN***\*(\****real***\*)\**** ***\*||\**** isNaN***\*(\****imaginary***\*))\**** // Ensure that both args are numbers.    ***\*throw\**** ***\*new\**** TypeError***\*();\****      // Throw an error if they are not.  ***\*this\*******\*.\****r ***\*=\**** real***\*;\****            // The real part of the complex number.  ***\*this\*******\*.\****i ***\*=\**** imaginary***\*;\****         // The imaginary part of the number.***\*}\**** /* * The instance methods of a class are defined as function-valued properties * of the prototype object.  The methods defined here are inherited by all * instances and provide the shared behavior of the class. Note that JavaScript * instance methods must use the this keyword to access the instance fields. */ // Add a complex number to this one and return the sum in a new object.Complex****.\*******\*prototype\*******\*.\****add ***\*=\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****  ***\*return\**** ***\*new\**** Complex***\*(\*******\*this\*******\*.\****r ***\*+\**** that***\*.\****r***\*,\**** ***\*this\*******\*.\****i ***\*+\**** that***\*.\****i***\*);\*******\*};\**** // Multiply this complex number by another and return the product.Complex***\*.\*******\*prototype\*******\*.\****mul ***\*=\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****  ***\*return\**** ***\*new\**** Complex***\*(\*******\*this\*******\*.\****r ***\**\**** that***\*.\****r ***\*-\**** ***\*this\*******\*.\****i ***\**\**** that***\*.\****i***\*,\****            ***\*this\*******\*.\****r ***\**\**** that***\*.\****i ***\*+\**** ***\*this\*******\*.\****i ***\**\**** that***\*.\****r***\*);\*******\*};\**** // Return the real magnitude of a complex number. This is defined// as its distance from the origin (0,0) of the complex plane.Complex***\*.\*******\*prototype\*******\*.\****mag ***\*=\**** ***\*function\*******\*()\**** ***\*{\****  ***\*return\**** Math***\*.\****sqrt***\*(\*******\*this\*******\*.\****r***\**\*******\*this\*******\*.\****r ***\*+\**** ***\*this\*******\*.\****i***\**\*******\*this\*******\*.\****i***\*);\*******\*};\**** // Return a complex number that is the negative of this one.Complex***\*.\*******\*prototype\*******\*.\****neg ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*new\**** Complex***\*(-\*******\*this\*******\*.\****r***\*,\**** ***\*-\*******\*this\*******\*.\****i***\*);\**** ***\*};\**** // Convert a Complex object to a string in a useful way.Complex***\*.\*******\*prototype\*******\*.\****toString ***\*=\**** ***\*function\*******\*()\**** ***\*{\****  ***\*return\**** "{" ***\*+\**** ***\*this\*******\*.\****r ***\*+\**** "," ***\*+\**** ***\*this\*******\*.\****i ***\*+\**** "}"***\*;\*******\*};\**** // Test whether this Complex object has the same value as another.Complex***\*.\*******\*prototype\*******\*.\****equals ***\*=\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****  ***\*return\**** that ***\*!=\**** ***\*null\**** ***\*&&\****           // must be defined and non-null    that***\*.\*******\*constructor\**** ***\*===\**** Complex ***\*&&\****     // and an instance of Complex     ***\*this\*******\*.\****r ***\*===\**** that***\*.\****r ***\*&&\**** ***\*this\*******\*.\****i ***\*===\**** that***\*.\****i***\*;\**** // and have the same values.***\*};\**** /* * Class fields (such as constants) and class methods are defined as  * properties of the constructor. Note that class methods do not  * generally use the this keyword: they operate only on their arguments. */ // Here are some class fields that hold useful predefined complex numbers.// Their names are uppercase to indicate that they are constants.// (In ECMAScript 5, we could actually make these properties read-only.)Complex****.\****ZERO ***\*=\**** ***\*new\**** Complex***\*(\****0***\*,\****0***\*);\****Complex***\*.\****ONE ***\*=\**** ***\*new\**** Complex***\*(\****1***\*,\****0***\*);\****Complex***\*.\****I ***\*=\**** ***\*new\**** Complex***\*(\****0***\*,\****1***\*);\**** // This class method parses a string in the format returned by the toString// instance method and returns a Complex object or throws a TypeError.Complex***\*.\****parse ***\*=\**** ***\*function\*******\*(\****s***\*)\**** ***\*{\****  ***\*try\**** ***\*{\****     // Assume that the parsing will succeed    ***\*var\**** m ***\*=\**** Complex***\*.\*****format***\*.\****exec***\*(\****s***\*);\**** // Regular expression magic    ***\*return\**** ***\*new\**** Complex***\*(\*******\*parseFloat\*******\*(\****m***\*[\****1***\*]),\**** ***\*parseFloat\*******\*(\****m***\*[\****2***\*]));\****  ***\*}\**** ***\*catch\**** ***\*(\****x***\*)\**** ***\*{\**** // And throw an exception if it fails    ***\*throw\**** ***\*new\**** TypeError***\*(\****"Can't parse '" ***\*+\**** s ***\*+\**** "' as a complex number."***\*);\****  ***\*}\*******\*};\**** // A "private" class field used in Complex.parse() above.// The underscore in its name indicates that it is intended for internal// use and should not be considered part of the public API of this class.Complex***\*.\*****format ***\*=\**** ***\*/^{([^,]+),([^}]+)}$/\*******\*;\****

看一下这段示例代码：

***\*var\**** c ***\*=\**** ***\*new\**** Complex***\*(\****2***\*,\**** 3***\*);\**** //使用构造函数创建新的对象***\*var\**** d ***\*=\**** ***\*new\**** Complex***\*(\****c***\*.\****i***\*,\**** c***\*.\****r***\*);\**** //用到了c 的实例属性c***\*.\****add***\*(\****d***\*).\****toString***\*()\****j  // => "{5, 5}": 使用了实例的方法//这个稍微复杂的表达式用到了类方法和类字段Complex***\*.\****parse***\*(\****c***\*.\****toString***\*())\**** //将c转换为字符串    ***\*.\****add***\*(\****c***\*.\****neg***\*())\**** //加上它的负数    ***\*.\****equals***\*(\****Complex***\*.\****ZERO***\*)\**** //结果应当永远是“零”

### ***\*类的扩充\****

JavaScript中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。

JavaScript内置类的原型对象也是一样如此“开放”，也就是说可以给数字、字符串、数组、函数等数据类型添加方法。

 通过Object.prototype添加的方法无法在ES5之前设置为不可枚举，Object.defineProperty()方法可以安全地扩冲Object.prototype

**// 多次调用这个函f，传入一个迭代数**

**// 比如，要输出"hello"三次:**

**// var n = 3;**

**// n.times(function(n) { console.log(n + " hello"); });**

***\*Number\****.***\*prototype\****.times ***\*=\**** ***\*function\*******\*(\****f***\*,\**** context***\*)\**** ***\*{\****

  ***\*var\**** n ***\*=\**** ***\*Number\*******\*(\*******\*this\*******\*);\****

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** n***\*;\**** i***\*++)\**** f.***\*call\*******\*(\****context***\*,\**** i***\*);\****

***\*};\****

**// 如果不存在ES5的String.trim()方法的话，就定义它**

**// 这个方法用以去除字符串开头和结尾的空格**

***\*String\****.***\*prototype\****.trim ***\*=\**** ***\*String\****.***\*prototype\****.trim ***\*||\**** ***\*function\*******\*()\**** ***\*{\****

  ***\*if\**** ***\*(!\*******\*this\*******\*)\**** ***\*return\**** ***\*this\*******\*;\**** **//空字符串不做处理**

  ***\*return\**** ***\*this\****.***\*replace\*******\*(/^\****\s***\*+|\****\s***\*+$/\****g***\*,\**** **""\******);\**** **//使用正则表达式进行空格替换**

***\*};\****

**// 返回函数的名字，如果它有\****（****非标准的****）****name属性，则直接使用name属性**

**// 否则，将函数转换为字符串然后从中提取名字**

**// 如果是没有名字的函数，则返回一个空字符串**

***\*Function\****.***\*prototype\****.getName ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

  ***\*return\**** ***\*this\****.***\*name\**** ***\*||\**** ***\*this\****.***\*toString\*******\*()\****.***\*match\*******\*(/\*******\*function\**** \s***\**([^()\*]\********(/)[\*******\*1\*******\*];\****

***\*};\****

### ***\*类和类型\****

***\*instanceof运算符\****

左操作数是待检测其类的对象，右操作数是定义类的构造函数。

构造函数是类的公共标识，但原型是唯一的标识。尽管instanceof运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数。

range.methods.isPrototypeOf(r); //range.method 是原型对象

instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。

***\*constructor属性\****

另一种识别对象是否属于某个类的方法是使用constructor属性。因为构造函数是类的公共标识

***\*function\**** typeAndValue***\*(\*******\*x\*******\*)\**** ***\*{\****

  ***\*if\**** ***\*(\*******\*x\**** ***\*==\**** ***\*null\*******\*)\**** ***\*return\**** **""\******;\**** **//Null和undefined没有构造函数**

  ***\*switch\*******\*(\*******\*x\****.constructor***\*)\**** ***\*{\****

​    ***\*case\**** ***\*Number\*******\*:\**** ***\*return\**** **"Number: "** ***\*+\**** ***\*x\*******\*;\**** **//处理原始类型**

​    ***\*case\**** ***\*String\*******\*:\**** ***\*return\**** **"String: '"** ***\*+\**** ***\*x\**** ***\*+\**** **"'"\******;\****

​    ***\*case\**** ***\*Date\*******\*:\**** ***\*return\**** **"Date: "** ***\*+\**** ***\*x\*******\*;\**** **//处理内置类型**

​    ***\*case\**** ***\*RegExp\*******\*:\**** ***\*return\**** **"Regexp: "** ***\*+\**** ***\*x\*******\*;\****

​    ***\*case\**** Complex***\*:\**** ***\*return\**** **"Complex: "** ***\*+\**** ***\*x\*******\*;\**** **//处理自定义类型**

  ***\*}\****

***\*}\****

需要注意的是，在代码中关键字case后的表达式都是函数，如果改用typeof运算符或获取到对象的class属性的话，它们应当改为字符串。

使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法正常工作的（比如在浏览器窗口的多个框架子页面中）。在这种情况下，每个框架页面各自拥有独立的构造函数集合，一个框架页面中的Array构造函数和另一个框架页面的Array构造函数不是同一个构造函数。

同样，在JavaScript中也并非所有的对象都包含constructor属性。在每个新创建的函数原型上默认会有constructor属性，但我们常常会忽略原型上的constructor属性。

***\*构造函数的名称\****

使用instanceof运算符和constructor属性来检测对象所属的类有一个主要的问题，在多个执行上下文中存在构造函数的多个副本的时候，这两种方法的检测结果会出错。多个执行上下文中的函数看起来是一模一样的，但它们是相互独立的对象，因此彼此也不相等。

一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。

**/\****

 *** Return the type of o as a string:**

 ***  -If o is null, return "null", if o is NaN, return "nan".**

 ***  -If typeof returns a value other than "object" return that value.**

 ***   (Note that some implementations identify regexps as functions.)**

 ***  -If the class of o is anything other than "Object", return that.**

 ***  -If o has a constructor and that constructor has a name, return it.**

 ***  -Otherwise, just return "Object".**

 ****/**

***\*function\**** ***\*type\*******\*(\****o***\*)\**** ***\*{\****

  ***\*var\**** t***\*,\**** c***\*,\**** n***\*;\**** **// type, class, name**

  **// Special case for the null value:**

  ***\*if\**** ***\*(\****o ***\*===\**** ***\*null\*******\*)\**** ***\*return\**** **"null"\******;\****

  **// Another special case: NaN is the only value not equal to itself:**

  ***\*if\**** ***\*(\****o ***\*!==\**** o***\*)\**** ***\*return\**** **"nan"\******;\****

  **// Use typeof for any value other than "object".**

  **// This identifies any primitive value and also functions.**

  ***\*if\**** ***\*((\****t ***\*=\**** ***\*typeof\**** o***\*)\**** ***\*!==\**** **"object"\******)\**** ***\*return\**** t***\*;\****

  **// Return the class of the object unless it is "Object".**

  **// This will identify most native objects.**

  ***\*if\**** ***\*((\****c ***\*=\**** classof***\*(\****o***\*))\**** ***\*!==\**** **"Object"\******)\**** ***\*return\**** c***\*;\****

  **// Return the object's constructor name, if it has one**

  ***\*if\**** ***\*(\****o.constructor ***\*&&\**** ***\*typeof\**** o.constructor ***\*===\**** **"function"** ***\*&&\****

​    ***\*(\****n ***\*=\**** o.constructor.getName***\*()))\**** ***\*return\**** n***\*;\****

  **// We can't determine a more specific type, so return "Object"**

  ***\*return\**** **"Object"\******;\****

***\*}\****

 

**// Return the class of an object.**

***\*function\**** classof***\*(\****o***\*)\**** ***\*{\****

  ***\*return\**** ***\*Object\****.***\*prototype\****.***\*toString\****.***\*call\*******\*(\****o***\*)\****.***\*slice\*******\*(\*******\*8\*******\*,-\*******\*1\*******\*);\****

***\*};\****

  

**// Return the name of a function (may be "") or null for nonfunctions**

***\*Function\****.***\*prototype\****.getName ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

  ***\*if\**** ***\*(\******"name"** ***\*in\**** ***\*this\*******\*)\**** ***\*return\**** ***\*this\****.***\*name\*******\*;\****

  ***\*return\**** ***\*this\****.***\*name\**** ***\*=\**** ***\*this\****.***\*toString\*******\*()\****.***\*match\*******\*(/\*******\*function\****\s***\**([^(]\*)\********(/)[\*******\*1\*******\*];\****

***\*};\****

这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题：并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。

**// 这个构造函数没有名字**

***\*var\**** Complex ***\*=\**** ***\*function\*******\*(\*******\*x\*******\*,\**** ***\*y\*******\*)\**** ***\*{\**** ***\*this\****.r ***\*=\**** ***\*x\*******\*;\**** ***\*this\****.i ***\*=\**** ***\*y\*******\*;\**** ***\*}\****

**// 这个构造函数有名字**

***\*var\**** Range ***\*=\**** ***\*function\**** Range***\*(\****f***\*,\**** t***\*)\**** ***\*{\**** ***\*this\****.from ***\*=\**** f***\*;\**** ***\*this\****.to ***\*=\**** t***\*;\**** ***\*}\****

***\*鸭式辩型\****

不要关注“对象的类是什么”，而是关注“对象能做什么”。这种思考问题的方式在Python和Ruby中非常普遍，称为“鸭式辩型”（这个表述是由作家James Whitcomb Riley 提出的）。

像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子。

下例中按照鸭式辩型的理念定义了quacks()函数（函数名叫"implements"会更加合适，但implements是保留字）。 

quacks()用以检查一个对象（第一个实参）是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法，如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法。如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。

**// Return true if o implements the methods specified by the remaining args.**

***\*function\**** quacks***\*(\****o **/\*, ... \*/\******)\**** ***\*{\****

 ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*1\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** **// for each argument after o**

  ***\*var\**** arg ***\*=\**** ***\*arguments\*******\*[\****i***\*];\****

  ***\*switch\*******\*(typeof\**** arg***\*)\**** ***\*{\**** **// If arg is a:**

   ***\*case\**** **'string'\******:\****    **// string: check for a method with that name**

​    ***\*if\**** ***\*(typeof\**** o***\*[\****arg***\*]\**** ***\*!==\**** **"function"\******)\**** ***\*return\**** ***\*false\*******\*;\****

​    ***\*continue\*******\*;\****

   ***\*case\**** **'function'\******:\****   **// function: use the prototype object instead**

​    **// If the argument is a function, we use its prototype object**

​    arg ***\*=\**** arg.***\*prototype\*******\*;\**** **// fall through to the next case**

   ***\*case\**** **'object'\******:\****    **// object: check for matching methods**

​    ***\*for\*******\*(\*******\*var\**** m ***\*in\**** arg***\*)\**** ***\*{\**** **// For each property of the object**

​     ***\*if\**** ***\*(typeof\**** arg***\*[\****m***\*]\**** ***\*!==\**** **"function"\******)\**** ***\*continue\*******\*;\**** **// skip non-methods**

​     ***\*if\**** ***\*(typeof\**** o***\*[\****m***\*]\**** ***\*!==\**** **"function"\******)\**** ***\*return\**** ***\*false\*******\*;\****

​    ***\*}\****

   ***\*}\****

  ***\*}\****

  **// If we're still here, then o implements everything**

  ***\*return\**** ***\*true\*******\*;\****

***\*}\****

### ***\*JavaScript中的面向对象技术\****

***\*一个例子\*******\*：\*******\*集合类\****

***\*function\**** Set***\*()\**** ***\*{\****     **// This is the constructor**

  ***\*this\****.values ***\*=\**** ***\*{};\****   **// The properties of this object hold the set**

  ***\*this\****.n ***\*=\**** ***\*0\*******\*;\****      **// How many values are in the set**

  ***\*this\****.add.***\*apply\*******\*(\*******\*this\*******\*,\**** ***\*arguments\*******\*);\**** **// All arguments are values to add**

***\*}\****

 

**// Add each of the arguments to the set.**

Set.***\*prototype\****.add ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** **// For each argument**

​    ***\*var\**** val ***\*=\**** ***\*arguments\*******\*[\****i***\*];\****         **// The value to add to the set**

​    ***\*var\**** str ***\*=\**** Set._v2s***\*(\****val***\*);\****         **// Transform it to a string**

​    ***\*if\**** ***\*(!\*******\*this\****.values.hasOwnProperty***\*(\****str***\*))\**** ***\*{\**** **// If not already in the set**

​      ***\*this\****.values***\*[\****str***\*]\**** ***\*=\**** val***\*;\****       **// Map string to value**

​      ***\*this\****.n***\*++;\****              **// Increase set size**

​    ***\*}\****

  ***\*}\****

  ***\*return\**** ***\*this\*******\*;\****                 **// Support chained method calls**

***\*};\****

 

**// Remove each of the arguments from the set.**

Set.***\*prototype\****.remove ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** **// For each argument**

​    ***\*var\**** str ***\*=\**** Set._v2s***\*(\*******\*arguments\*******\*[\****i***\*]);\****    **// Map to a string**

​    ***\*if\**** ***\*(\*******\*this\****.values.hasOwnProperty***\*(\****str***\*))\**** ***\*{\****  **// If it is in the set**

​      ***\*delete\**** ***\*this\****.values***\*[\****str***\*];\****       **// Delete it**

​      ***\*this\****.n***\*--;\****              **// Decrease set size**

​    ***\*}\****

  ***\*}\****

  ***\*return\**** ***\*this\*******\*;\****                 **// For method chaining**

***\*};\****

 

**// Return true if the set contains value; false otherwise.**

Set.***\*prototype\****.***\*contains\**** ***\*=\**** ***\*function\*******\*(\*******\*value\*******\*)\**** ***\*{\****

  ***\*return\**** ***\*this\****.values.hasOwnProperty***\*(\****Set._v2s***\*(\*******\*value\*******\*));\****

***\*};\****

 

**// Return the size of the set.**

Set.***\*prototype\****.size ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\****.n***\*;\**** ***\*};\****

 

**// Call function f on the specified context for each element of the set.**

Set.***\*prototype\****.foreach ***\*=\**** ***\*function\*******\*(\****f***\*,\**** context***\*)\**** ***\*{\****

  ***\*for\*******\*(\*******\*var\**** s ***\*in\**** ***\*this\****.values***\*)\****         **// For each string in the set**

​    ***\*if\**** ***\*(\*******\*this\****.values.hasOwnProperty***\*(\****s***\*))\****  **// Ignore inherited properties**

​      f.***\*call\*******\*(\****context***\*,\**** ***\*this\****.values***\*[\****s***\*]);\**** **// Call f on the value**

***\*};\****

 

**// This internal function maps any JavaScript value to a unique string.**

Set._v2s ***\*=\**** ***\*function\*******\*(\****val***\*)\**** ***\*{\****

  ***\*switch\*******\*(\****val***\*)\**** ***\*{\****

​    ***\*case\**** undefined***\*:\****   ***\*return\**** **'u'\******;\****     **// Special primitive**

​    ***\*case\**** ***\*null\*******\*:\****     ***\*return\**** **'n'\******;\****     **// values get single-letter**

​    ***\*case\**** ***\*true\*******\*:\****     ***\*return\**** **'t'\******;\****     **// codes.**

​    ***\*case\**** ***\*false\*******\*:\****     ***\*return\**** **'f'\******;\****

​    ***\*default\*******\*:\**** ***\*switch\*******\*(typeof\**** val***\*)\**** ***\*{\****

​      ***\*case\**** **'number'\******:\**** ***\*return\**** **'#'** ***\*+\**** val***\*;\****  **// Numbers get # prefix.**

​      ***\*case\**** **'string'\******:\**** ***\*return\**** **'"'** ***\*+\**** val***\*;\****  **// Strings get " prefix.**

​      ***\*default\*******\*:\**** ***\*return\**** **'@'** ***\*+\**** objectId***\*(\****val***\*);\**** **// Objs and funcs get @**

​    ***\*}\****

  ***\*}\****

 

  **// For any object, return a string. This function will return a different**

  **// string for different objects, and will always return the same string**

  **// if called multiple times for the same object. To do this it creates a**

  **// property on o. In ES5 the property would be nonenumerable and read-only.**

  ***\*function\**** objectId***\*(\****o***\*)\**** ***\*{\****

​    ***\*var\**** prop ***\*=\**** **"|**objectid**|"\******;\****  **// Private property name for storing ids**

​    ***\*if\**** ***\*(!\****o.hasOwnProperty***\*(\****prop***\*))\****  **// If the object has no id**

​      o***\*[\****prop***\*]\**** ***\*=\**** Set._v2s.***\*next\*******\*++;\**** **// Assign it the next available**

​    ***\*return\**** o***\*[\****prop***\*];\****        **// Return the id**

  ***\*}\****

***\*};\****

Set._v2s.***\*next\**** ***\*=\**** ***\*100\*******\*;\****  **// Start assigning object ids at this value.**

***\*一个例子\*******\*：\*******\*枚举类型\****

**// This function creates a new enumerated type.  The argument object specifies**

**// the names and values of each instance of the class. The return value**

**// is a constructor function that identifies the new class.  Note, however**

**// that the constructor throws an exception: you can't use it to create new**

**// instances of the type.  The returned constructor has properties that** 

**// map the name of a value to the value itself, and also a values array,**

**// a foreach() iterator function**

***\*function\**** enumeration***\*(\****namesToValues***\*)\**** ***\*{\****

  **// This is the dummy constructor function that will be the return value.**

  ***\*var\**** enumeration ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*throw\**** **"Can't Instantiate Enumerations"\******;\**** ***\*};\****

 

  **// Enumerated values inherit from this object.**

  ***\*var\**** proto ***\*=\**** enumeration.***\*prototype\**** ***\*=\**** ***\*{\****

​    constructor***\*:\**** enumeration***\*,\****          **// Identify type**

​    ***\*toString\*******\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\****.***\*name\*******\*;\**** ***\*},\**** **// Return name**

​    ***\*valueOf\*******\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\****.***\*value\*******\*;\**** ***\*},\**** **// Return value**

​    toJSON***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\****.***\*name\*******\*;\**** ***\*}\****  **// For serialization**

  ***\*};\****

 

  enumeration.values ***\*=\**** ***\*[];\**** **// An array of the enumerated value objects**

 

  **// Now create the instances of this new type.**

  ***\*for\*******\*(\*******\*name\**** ***\*in\**** namesToValues***\*)\**** ***\*{\****     **// For each value** 

​    ***\*var\**** e ***\*=\**** inherit***\*(\****proto***\*);\****     **// Create an object to represent it**

​    e.***\*name\**** ***\*=\**** ***\*name\*******\*;\****          **// Give it a name**

​    e.***\*value\**** ***\*=\**** namesToValues***\*[\*******\*name\*******\*];\****  **// And a value**

​    enumeration***\*[\*******\*name\*******\*]\**** ***\*=\**** e***\*;\****      **// Make it a property of constructor**

​    enumeration.values.***\*push\*******\*(\****e***\*);\****   **// And store in the values array**

  ***\*}\****

  **// A class method for iterating the instances of the class**

  enumeration.foreach ***\*=\**** ***\*function\*******\*(\****f***\*,\****c***\*)\**** ***\*{\****

​    ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*this\****.values.***\*length\*******\*;\**** i***\*++)\**** f.***\*call\*******\*(\****c***\*,\*******\*this\****.values***\*[\****i***\*]);\****

  ***\*};\****

 

  **// Return the constructor that identifies the new type**

  ***\*return\**** enumeration***\*;\****

***\*}\****

 

 

 

**// Define a class to represent a playing card**

***\*function\**** Card***\*(\****suit***\*,\**** rank***\*)\**** ***\*{\****

  ***\*this\****.suit ***\*=\**** suit***\*;\****     **// Each card has a suit**

  ***\*this\****.rank ***\*=\**** rank***\*;\****     **// and a rank**

***\*}\****

 

**// These enumerated types define the suit and rank values**

Card.Suit ***\*=\**** enumeration***\*({\****Clubs***\*:\**** ***\*1\*******\*,\**** Diamonds***\*:\**** ***\*2\*******\*,\**** Hearts***\*:\*******\*3\*******\*,\**** Spades***\*:\*******\*4\*******\*});\****

Card.Rank ***\*=\**** enumeration***\*({\****Two***\*:\**** ***\*2\*******\*,\**** Three***\*:\**** ***\*3\*******\*,\**** Four***\*:\**** ***\*4\*******\*,\**** Five***\*:\**** ***\*5\*******\*,\**** Six***\*:\**** ***\*6\*******\*,\****

​             Seven***\*:\**** ***\*7\*******\*,\**** Eight***\*:\**** ***\*8\*******\*,\**** Nine***\*:\**** ***\*9\*******\*,\**** Ten***\*:\**** ***\*10\*******\*,\****

​             Jack***\*:\**** ***\*11\*******\*,\**** Queen***\*:\**** ***\*12\*******\*,\**** King***\*:\**** ***\*13\*******\*,\**** Ace***\*:\**** ***\*14\*******\*});\****

 

**// Define a textual representation for a card**

Card.***\*prototype\****.***\*toString\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

  ***\*return\**** ***\*this\****.rank.***\*toString\*******\*()\**** ***\*+\**** **" of "** ***\*+\**** ***\*this\****.suit.***\*toString\*******\*();\****

***\*};\****

**// Compare the value of two cards as you would in poker**

Card.***\*prototype\****.compareTo ***\*=\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****

  ***\*if\**** ***\*(\*******\*this\****.rank ***\*<\**** that.rank***\*)\**** ***\*return\**** ***\*-\*******\*1\*******\*;\****

  ***\*if\**** ***\*(\*******\*this\****.rank ***\*>\**** that.rank***\*)\**** ***\*return\**** ***\*1\*******\*;\****

  ***\*return\**** ***\*0\*******\*;\****

***\*};\****

 

**// A function for ordering cards as you would in poker**

Card.orderByRank ***\*=\**** ***\*function\*******\*(\****a***\*,\****b***\*)\**** ***\*{\**** ***\*return\**** a.compareTo***\*(\****b***\*);\**** ***\*};\****

 

**// A function for ordering cards as you would in bridge** 

Card.orderBySuit ***\*=\**** ***\*function\*******\*(\****a***\*,\****b***\*)\**** ***\*{\****

  ***\*if\**** ***\*(\****a.suit ***\*<\**** b.suit***\*)\**** ***\*return\**** ***\*-\*******\*1\*******\*;\****

  ***\*if\**** ***\*(\****a.suit ***\*>\**** b.suit***\*)\**** ***\*return\**** ***\*1\*******\*;\****

  ***\*if\**** ***\*(\****a.rank ***\*<\**** b.rank***\*)\**** ***\*return\**** ***\*-\*******\*1\*******\*;\****

  ***\*if\**** ***\*(\****a.rank ***\*>\**** b.rank***\*)\**** ***\*return\**** ***\*1\*******\*;\****

  ***\*return\**** ***\*0\*******\*;\****

***\*};\****

 

 

**// Define a class to represent a standard deck of cards**

***\*function\**** Deck***\*()\**** ***\*{\****

  ***\*var\**** cards ***\*=\**** ***\*this\****.cards ***\*=\**** ***\*[];\****   **// A deck is just an array of cards**

  Card.Suit.foreach***\*(\*******\*function\*******\*(\****s***\*)\**** ***\*{\**** **// Initialize the array**

​             Card.Rank.foreach***\*(\*******\*function\*******\*(\****r***\*)\**** ***\*{\****

​                        cards.***\*push\*******\*(new\**** Card***\*(\****s***\*,\****r***\*));\****

​                      ***\*});\****

​           ***\*});\****

***\*}\****

 

**// Shuffle method: shuffles cards in place and returns the deck**

Deck.***\*prototype\****.shuffle ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** 

  **// For each element in the array, swap with a randomly chosen lower element**

  ***\*var\**** deck ***\*=\**** ***\*this\****.cards***\*,\**** len ***\*=\**** deck.***\*length\*******\*;\****

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** len***\*-\*******\*1\*******\*;\**** i ***\*>\**** ***\*0\*******\*;\**** i***\*--)\**** ***\*{\****

​    ***\*var\**** r ***\*=\**** ***\*Math\****.***\*floor\*******\*(\*******\*Math\****.***\*random\*******\*()\*(\****i***\*+\*******\*1\*******\*)),\**** temp***\*;\****   **// Random number**

​    temp ***\*=\**** deck***\*[\****i***\*],\**** deck***\*[\****i***\*]\**** ***\*=\**** deck***\*[\****r***\*],\**** deck***\*[\****r***\*]\**** ***\*=\**** temp***\*;\**** **// Swap**

  ***\*}\****

  ***\*return\**** ***\*this\*******\*;\****

***\*};\****

 

**// Deal method: returns an array of cards**

Deck.***\*prototype\****.deal ***\*=\**** ***\*function\*******\*(\****n***\*)\**** ***\*{\**** 

  ***\*if\**** ***\*(\*******\*this\****.cards.***\*length\**** ***\*<\**** n***\*)\**** ***\*throw\**** **"Out of cards"\******;\****

  ***\*return\**** ***\*this\****.cards.***\*splice\*******\*(\*******\*this\****.cards.***\*length\*******\*-\****n***\*,\**** n***\*);\****

***\*};\****

 

**// Create a new deck of cards, shuffle it, and deal a bridge hand**

***\*var\**** deck ***\*=\**** ***\*(new\**** Deck***\*())\****.shuffle***\*();\****

***\*var\**** hand ***\*=\**** deck.deal***\*(\*******\*13\*******\*)\****.***\*sort\*******\*(\****Card.orderBySuit***\*);\****

***\*标准转换方法\****

l toString()：返回一个可以表示这个对象的字符串

l toLocaleString()：返回本地化相关的字符串

l valueOf()：用来将对象转换为原始值

l toJSON()：由JSON.stringify()自动调用

**//将这些方始添加至Set类的原型对象中**

extend***\*(\****Set.***\*prototype\*******\*,\**** ***\*{\**** 

 **//将集合转换为字符串**

 ***\*toString\*******\*:\**** ***\*function\**** ***\*()\**** ***\*{\**** 

  ***\*var\**** s ***\*=\**** **"{"\******,\**** i ***\*=\**** ***\*0\*******\*;\**** 

  ***\*this\****.foreach***\*(\*******\*function\**** ***\*(\****v***\*)\**** ***\*{\****s ***\*+=\**** ***\*((\****i***\*++>\*******\*0\*******\*)\**** ***\*?\**** **", "** ***\*:\**** **""\******)\**** ***\*+\**** v***\*;\**** ***\*});\**** 

  ***\*return\**** s ***\*+\**** **"}"\******;\****

 ***\*},\**** 

 **//类似toString，但是对于所有的值都将调用toLocaleString()**

 ***\*toLocaleString\*******\*:\**** ***\*function\**** ***\*()\**** ***\*{\**** 

  ***\*var\**** s ***\*=\**** **"{"\******,\**** i ***\*=\**** ***\*0\*******\*;\**** 

  ***\*this\****.foreach***\*(\*******\*function\**** ***\*(\****v***\*)\**** ***\*{\**** 

​         ***\*if\**** ***\*(\****i***\*++\**** ***\*>\**** ***\*0\*******\*)\**** s ***\*+=\**** **", "\******;\**** 

​         ***\*if\**** ***\*(\****v ***\*==\**** ***\*null\*******\*)\**** s ***\*+=\**** v***\*;\**** **// null和undefined**

​         ***\*else\**** s ***\*+=\**** v.***\*toLocaleString\*******\*();\**** **//其他情况**

​        ***\*});\****

  ***\*return\**** s ***\*+\**** **"}"\******;\**** 

 ***\*},\****

 **//将集合转换为值数组**

 toArray***\*:\**** ***\*function\**** ***\*()\**** ***\*{\**** 

  ***\*var\**** a ***\*=\**** ***\*[];\**** 

  ***\*this\****.foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\**** a.***\*push\*******\*(\****v***\*);\**** ***\*});\**** 

  ***\*return\**** a***\*;\**** 

 ***\*}\****

***\*});\**** 

**//对于要从JSON转换为字符串的集合都被当做数组来对待**

Set.***\*prototype\****.toJSON ***\*=\**** Set.***\*prototype\****.toArray***\*;\**** 

***\*比较方法\****

JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等，或者比较它们的顺序。

Java编程语言有很多用于对象比较的方法，将Java中的这些方法借用到JavaScript中是一个不错的主意。为了能让自定义类的实例具备比较的功能，定义一个名叫equals()实例方法。这个方法只能接收一个实参，如果这个实参和调用此方法的对象相等的话则返回true。当然，这里所说的“相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。

**// Range类重写它的constructor属性，现在将它添加进去**

Range.***\*prototype\****.constructor ***\*=\**** Range***\*;\**** 

**// 一个Range对象和其他不是Range的对象均不相等**

**// 当且仅当两个范围的端点相等，它们才相等**

Range.***\*prototype\****.equals ***\*=\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\**** 

  ***\*if\**** ***\*(\****that ***\*==\**** ***\*null\*******\*)\**** ***\*return\**** ***\*false\*******\*;\**** **//处理null和undefined**

  ***\*if\**** ***\*(\****that.constructor ***\*!==\**** Range***\*)\**** ***\*return\**** ***\*false\*******\*;\**** **//处理非Range对象**

  **// 当且仅当两个端点相等，才返回true**

  ***\*return\**** ***\*this\****.from ***\*==\**** that.from ***\*&&\**** ***\*this\****.to ***\*==\**** that.to***\*;\**** 

***\*}\****

给Set类定义equals()方法稍微有些复杂。不能简单地比较两个集合的values属性，还要进行更深层次的比较：

Set.***\*prototype\****.equals ***\*=\**** ***\*function\**** ***\*(\****that***\*)\**** ***\*{\**** 

 **//一些次要情况的快捷处理**

 ***\*if\**** ***\*(\*******\*this\**** ***\*===\**** that***\*)\**** ***\*return\**** ***\*true\*******\*;\**** 

 **//如果that对象不是一个集合，它和this不相等**

 **//我们用到了instanceof，使得这个方法可以用于Set的任何子类**

 **//如果希望采用鸭式辩型的方法，可以降低检查的严格程度**

 **//或者可以通过 this.constructor == that.constructor 来加强检查的严格程度**

 **//注意，null和undefined两个值是无法用于instanceof运算的**

 ***\*if\**** ***\*(!(\****that ***\*instanceof\**** Set***\*))\**** ***\*return\**** ***\*false\*******\*;\**** 

 **//如果两个集合的大小不一样，则它们不相等**

 ***\*if\**** ***\*(\*******\*this\****.size***\*()\**** ***\*!=\**** that.size***\*())\**** ***\*return\**** ***\*false\*******\*;\**** 

 **//现在检查两个集合中的元素是否完全一样**

 **//如果两个集合不相等，则通过抛出异常来终止foreach循环**

 ***\*try\**** ***\*{\**** 

  ***\*this\****.foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\**** ***\*if\**** ***\*(!\****that.***\*contains\*******\*(\****v***\*))\**** ***\*throw\**** ***\*false\*******\*;\**** ***\*});\**** 

  ***\*return\**** ***\*true\*******\*;\**** **//所有的元素都匹配:两个集合相等**

 ***\*}\**** ***\*catch\*******\*(\*******\*x\*******\*)\**** ***\*{\**** 

  ***\*if\**** ***\*(\*******\*x\**** ***\*===\**** ***\*false\*******\*)\**** ***\*return\**** ***\*false\*******\*;\**** **//如果集合中有元素在另外一个集合中不存在**

  ***\*throw\**** ***\*x\*******\*;\**** **//重新抛出异常**

 ***\*}\****

***\*};\****

如果将对象用于JavaScript的关系比较运算符，比如"<"和"<=", JavaScript会首先调用对象的valueOf()方法，如果这个方能返回一个原始值，则直接比较原始值。大多数类并没有valueOf()方法，为了按照显式定义的规则来比较这些类型的对象，可以定义一个名叫compareTo()的方法(同样，这里遵照Java中的命名约定)。compareTo()方法应当只能接收一个参数，这个方法将这个参数和调用它的对象进行比较。如果this对象小于参数对象，compareTo()应当返回比0小的值。如果this对象大于参数对象，应当返回比0大的值。如果两个对象相等，应当返回0。

可以给Range类添加一个类似的方法，用以比较它们的下边界:

Range.***\*prototype\****.compareTo ***\*=\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\**** 

  ***\*return\**** ***\*this\****.from ***\*-\**** that.from***\*;\**** 

***\*};\****

相等概念上的差异性会造成很多bug，最好将Range类的equals()和compareTo()方法中处理相等的逻辑保持一致。

**//根据下边界来对Range对象排序，如果下边界相等则比较上边界**

**//如果传入非Range值，则抛出异常**

**//当且仅当this.equals(that)时，才返回0**

Range.***\*prototype\****.compareTo ***\*=\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\**** 

  ***\*if\**** ***\*(!(\****that ***\*instanceof\**** Range***\*))\**** 

​    ***\*throw\**** ***\*new\**** Error***\*(\******"Can't compare a Range with "** ***\*+\**** that***\*);\**** 

  ***\*var\**** diff ***\*=\**** ***\*this\****.from ***\*-\**** that.from***\*;\**** **//比较下边界**

  ***\*if\**** ***\*(\****diff ***\*==\**** ***\*0\*******\*)\**** diff ***\*=\**** ***\*this\****.to ***\*-\**** that.to***\*;\**** **//如果相等，比较上边界**

  ***\*return\**** diff***\*;\****

***\*};\**** 

假定有了上文提到的compareTo()方法，就可以很方便地对Range对象组成的数组进行排序了:

ranges.***\*sort\*******\*(\*******\*function\*******\*(\****a ***\*,\****b***\*)\**** ***\*{\**** ***\*return\**** a.compareTo***\*(\****b***\*);\**** ***\*});\**** 

排序运算非常重要，如果已经为类定义了实例方法compareTo()，还应当参照这个方法定义一个可传入两个参数的比较函数。使用compareTo()方法可以非常轻松地定义这个函数

Range.bylowerBound ***\*=\**** ***\*function\*******\*(\****a***\*,\**** b***\*)\**** ***\*{\**** ***\*return\**** a.compareTo***\*(\****b***\*);\**** ***\*};\**** 

ranges.***\*sort\*******\*(\****Range.byLowerBound***\*);\**** 

***\*方法借用\****

如果以经典的面向对象语言的视角来看JavaScript的话，把一个类的方法用到其他的类中的做法也称做“多重继承”(multiple inheritance)。然而，JavaScript并不是经典的面向对象语言，我更倾向于将这种方法重用更正式地称为“方法借用”(borrowing)。

下例定义了泛型方法toString()和equals()，可以被Range、Complex和Card这些简单类使用。

***\*var\**** generic ***\*=\**** ***\*{\****

  **// Returns a string that includes the name of the constructor function**

  **// if available and the names and values of all noninherited, nonfunction**

  **// properties.**

  ***\*toString\*******\*:\**** ***\*function\*******\*()\**** ***\*{\****

​    ***\*var\**** s ***\*=\**** **'['\******;\****

​    **// If the object has a constructor and the constructor has a name,**

​    **// use that class name as part of the returned string.  Note that**

​    **// the name property of functions is nonstandard and not supported**

​    **// everywhere.**

​    ***\*if\**** ***\*(\*******\*this\****.constructor ***\*&&\**** ***\*this\****.constructor.***\*name\*******\*)\****

​      s ***\*+=\**** ***\*this\****.constructor.***\*name\**** ***\*+\**** **": "\******;\****

 

​    **// Now enumerate all noninherited, nonfunction properties**

​    ***\*var\**** n ***\*=\**** ***\*0\*******\*;\****

​    ***\*for\*******\*(\*******\*var\**** ***\*name\**** ***\*in\**** ***\*this\*******\*)\**** ***\*{\****

​      ***\*if\**** ***\*(!\*******\*this\****.hasOwnProperty***\*(\*******\*name\*******\*))\**** ***\*continue\*******\*;\****  **// skip inherited props**

​      ***\*var\**** ***\*value\**** ***\*=\**** ***\*this\*******\*[\*******\*name\*******\*];\****

​      ***\*if\**** ***\*(typeof\**** ***\*value\**** ***\*===\**** **"function"\******)\**** ***\*continue\*******\*;\**** **// skip methods**

​      ***\*if\**** ***\*(\****n***\*++)\**** s ***\*+=\**** **", "\******;\****

​      s ***\*+=\**** ***\*name\**** ***\*+\**** **'='** ***\*+\**** ***\*value\*******\*;\****

​    ***\*}\****

​    ***\*return\**** s ***\*+\**** **']'\******;\****

  ***\*},\****

 

  **// Tests for equality by comparing the constructors and instance properties**

  **// of this and that.  Only works for classes whose instance properties are**

  **// primitive values that can be compared with ===.**

  **// As a special case, ignore the special property added by the Set class.**

  equals***\*:\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****

​    ***\*if\**** ***\*(\****that ***\*==\**** ***\*null\*******\*)\**** ***\*return\**** ***\*false\*******\*;\****

​    ***\*if\**** ***\*(\*******\*this\****.constructor ***\*!==\**** that.constructor***\*)\**** ***\*return\**** ***\*false\*******\*;\****

​    ***\*for\*******\*(\*******\*var\**** ***\*name\**** ***\*in\**** ***\*this\*******\*)\**** ***\*{\****

​      ***\*if\**** ***\*(\*******\*name\**** ***\*===\**** **"|**objectid**|"\******)\**** ***\*continue\*******\*;\****   **// skip special prop.**

​      ***\*if\**** ***\*(!\*******\*this\****.hasOwnProperty***\*(\*******\*name\*******\*))\**** ***\*continue\*******\*;\****  **// skip inherited** 

​      ***\*if\**** ***\*(\*******\*this\*******\*[\*******\*name\*******\*]\**** ***\*!==\**** that***\*[\*******\*name\*******\*])\**** ***\*return\**** ***\*false\*******\*;\**** **// compare values**

​    ***\*}\****

​    ***\*return\**** ***\*true\*******\*;\**** **// If all properties matched, objects are equal.**

  ***\*}\****

***\*};\****

***\*私有状态\****

我们可以通过将变量（或参数）闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数（因此这个函数可以访问构造函数内部的参数和变量），并将这个函数赋值给新创建对象的属性。

//对Range类的读取端点方法的简单封装***\*function\**** Range***\*(\*******\*from\*******\*,\**** to***\*)\**** ***\*{\****  // Don't store the endpoints as properties of this object. Instead  // define accessor functions that return the endpoint values.  // These values are stored in the closure.  ***\*this\*******\*.\*******\*from\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*from\*******\*;\**** ***\*};\****  ***\*this\*******\*.\****to ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** to***\*;\**** ***\*};\*******\*}\**** // The methods on the prototype can't see the endpoints directly: they have// to invoke the accessor methods just like everyone else.Range***\*.\*******\*prototype\**** ***\*=\**** ***\*{\****  ***\*constructor\*******\*:\**** Range***\*,\****  includes***\*:\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\*******\*from\*******\*()\**** ***\*<=\**** x ***\*&&\**** x ***\*<=\**** ***\*this\*******\*.\****to***\*();\**** ***\*},\****  foreach***\*:\**** ***\*function\*******\*(\****f***\*)\**** ***\*{\****    ***\*for\*******\*(\*******\*var\**** x***\*=\****Math***\*.\****ceil***\*(\*******\*this\*******\*.\*******\*from\*******\*()),\**** max***\*=\*******\*this\*******\*.\****to***\*();\**** x ***\*<=\**** max***\*;\**** x***\*++)\**** f***\*(\****x***\*);\****  ***\*},\****  toString***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** "(" ***\*+\**** ***\*this\*******\*.\*******\*from\*******\*()\**** ***\*+\**** "..." ***\*+\**** ***\*this\*******\*.\****to***\*()\**** ***\*+\**** ")"***\*;\**** ***\*}\*******\*};\****

这个新的Range类定义了用以读取范围端点的方法，但没有定义设置端点的方法或属性。这让类的实例看起来是不可修改的，如果使用正确的话，一旦创建Range对象，端点数据就不可修改了。除非使用ECMAScript 5中的某些特性，但from和to属性依然是可写的，并且Range对象实际上并不是真正不可修改的: 可以使用***\*方法替换\****来修改端点。需要注意的是，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢，并占用更多内存。

***\*var\**** r = new Range(1,5);      //一个不可修改的范围

r.from = ***\*function\****(){ ***\*return\**** o; }; //通过方法替换来修改它

***\*构造函数的重载和工厂方法\****

***\*function\**** Set***\*()\**** ***\*{\**** ***\*this\*******\*.\****values  ***\*=\**** ***\*{};\**** //用这个对象的属性来保存这个集合	***\*this\*******\*.\****n  ***\*=\**** 0***\*;\**** //集合中值的个数	//如果传入一个类数组的对象，将这个元素添加至集合中	//否则，将所有的参数都添加至集合中	***\*if\**** ***\*(\****arguments***\*.\****length ***\*==\**** 1 ***\*&&\**** isArrayLike***\*(\****arguments***\*[\****o***\*]))\**** 	***\*this\*******\*.\****add***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*[\****0***\*]);\**** ***\*else\**** ***\*if\**** ***\*(\****arguments***\*.\****length ***\*>\**** 0***\*)\**** 	***\*this\*******\*.\****add***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\*******\*}\****	

这段代码所定义的Set()构造函数可以显式将一组元素作为参数列表传入，也可以传入元素组成的数组。但是这个构造函数有多义性，如果集合的某个成员是一个数组就无法通过这个构造函数来创建这个集合了(为了做到这一点，需要首先创建一个空集合，然后显式调用add()方法)。

在使用极坐标来初始化复数的例子中，实际上并没有看到有函数重载。代表复数两个维度的数字都是浮点数，除非给构造函数传入第三个参数，否则构造函数无住识别到底传入的是极坐标参数还是直角坐标参数。相反，可以写一个工厂方法——一个类的方法用以返回类的一个实例。下面的例子即是使用工厂方法来返回一个使用极坐标初始化的Complex对象:

Complex***\*.\****polar ***\*=\**** ***\*function\*******\*(\****r***\*,\**** theta***\*)\**** ***\*{\**** ***\*return\**** ***\*new\**** Complex***\*(\****r***\**\****Math***\*.\****cos***\*(\****theta***\*),\**** r***\**\****Math***\*.\****sin***\*(\****theta***\*));\**** ***\*};\****

下面这个工厂方法用来通过数组初始化Set对象:

Set***\*.\****fromArray ***\*=\**** ***\*function\*******\*(\****a***\*)\**** ***\*{\**** s ***\*=\**** ***\*new\**** Set***\*();\**** //创建一个空集合	s***\*.\****add***\*.\****apply***\*(\****s***\*,\**** a***\*);\**** //将数组a的成员作为参数传人add()方法	***\*return\**** s***\*;\****//返回这个新集合***\*};\****	

可以给工厂方法定义任意的名字，不同名字的工厂方法用以执行不同的初始化。但由于构造函数是类的公有标识，因此每个类只能有一个构造函数。但这并不是一个“必须遵守”的规则。在JavaScript中是可以定义多个构造函数继承自一个原型对象的，如果这样做的话，由这些构造函数的任意一个所创建的对象都属于同一类型。并不推荐这种技术，但下面的示例代码使用这种技术定义了该类型的一个辅助构造函数:

// Set类的一个辅助构造函数***\*function\**** SetFromArray***\*(\****a***\*)\**** ***\*{\**** //通过以函数的形式调用Set()来初始化这个新对象	//将a的元素作为参数传入	Set***\*.\****apply***\*(\*******\*this\*******\*,\**** a***\*);\**** ***\*}\**** //设置原型，以便SetFromArray能创建Set的实例SetFromArray***\*.\*******\*prototype\**** ***\*=\**** Set***\*.\*******\*prototype\*******\*;\*******\*var\**** s ***\*=\**** ***\*new\**** SetFromArray***\*([\****1***\*,\****2***\*,\****3***\*]);\**** s ***\*instanceof\**** Set  // => true

### ***\*子类\****

在面向对象编程中，类B可以继承自另外一个类A。我们将A称为父类 (superclass)，将B称为子类 (subclass)。  B的实例从A继承了所有的实例方法。类B可以定义自己的实例方法，有些方法可以重载类A中的同名方法，如果B的方法重载了A中的方法，B中的重载方法可能会调用A中的重载方法，这种做法称为“方法链”(method chaining)。同样，子类的构造函数B()有时需要调用父类的构造函数A()，这种做法称为“构造函数链”(constructor chaining)。子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类(abstract class)。抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的。

在JavaScript中创建子类的关键之处在于，采用合适的方法对原型对象进行初始化。如果类B继承自类A ， B.prototype必须是A.prototype的后嗣。B的实例继承自 B.prototype ，后者同样也继承自A.prototype。还会介绍类继承的替代方案“组合”(composition) 。

***\*定义子类\****

JavaScript的对象可以从类的原型对象中继承属性(通常继承的是方法)。如果o是类B的实例，B是A的子类，那么o也一定从A中继承了属性。为此，首先要确保B的原型对象继承自A的原型对象。通过inherit()函数，可以这样来实现:

B***\*.\*******\*prototype\**** ***\*=\**** inherit***\*(\****A***\*.\*******\*prototype\*******\*);\**** //子类派生自父类B***\*.\*******\*prototype\*******\*.\*******\*constructor\**** ***\*=\**** B***\*;\**** //重载继承来的constructor属性

这两行代码是在JavaScript中创建子类的关键。如果不这样做，原型对象仅仅是一个普通对象，它只继承自 Object.prototype，这意味着你的类和所有的类一样是Object的子类。

将这两行代码添加至defineClass()函数中，可以将它变成下例中的defineSubclass()函数和Function.prototype.extend()方法：

// A simple function for creating simple subclasses***\*function\**** defineSubclass***\*(\****superclass***\*,\**** // Constructor of the superclass            ***\*constructor\*******\*,\**** // The constructor for the new subclass            methods***\*,\****   // Instance methods: copied to prototype            statics***\*)\****   // Class properties: copied to constructor***\*{\****  // Set up the prototype object of the subclass  ***\*constructor\*******\*.\*******\*prototype\**** ***\*=\**** inherit***\*(\****superclass***\*.\*******\*prototype\*******\*);\****  ***\*constructor\*******\*.\*******\*prototype\*******\*.\*******\*constructor\**** ***\*=\**** ***\*constructor\*******\*;\****  // Copy the methods and statics as we would for a regular class  ***\*if\**** ***\*(\****methods***\*)\**** extend***\*(\*******\*constructor\*******\*.\*******\*prototype\*******\*,\**** methods***\*);\****  ***\*if\**** ***\*(\****statics***\*)\**** extend***\*(\*******\*constructor\*******\*,\**** statics***\*);\****  // Return the class  ***\*return\**** ***\*constructor\*******\*;\*******\*}\**** // We can also do this as a method of the superclass constructorFunction***\*.\*******\*prototype\*******\*.\****extend ***\*=\**** ***\*function\*******\*(\*******\*constructor\*******\*,\**** methods***\*,\**** statics***\*)\**** ***\*{\****  ***\*return\**** defineSubclass***\*(\*******\*this\*******\*,\**** ***\*constructor\*******\*,\**** methods***\*,\**** statics***\*);\*******\*};\**** //展示了不使用defineSubclass() 函数如何“手动”实现子类。 // 一个继承的简单实现，实现了核心的Set方法，但从父类中继承了toString()、toArray()和equals()方法。定义子类就是为了继承这些方法。// The constructor function ***\*function\**** SingletonSet***\*(\****member***\*)\**** ***\*{\****  ***\*this\*******\*.\****member ***\*=\**** member***\*;\****  // Remember the single member of the set***\*}\**** // Create a prototype object that inherits from the prototype of Set.SingletonSet***\*.\*******\*prototype\**** ***\*=\**** inherit***\*(\****Set***\*.\*******\*prototype\*******\*);\**** // Now add properties to the prototype.// These properties override the properties of the same name from Set.prototype.extend***\*(\****SingletonSet***\*.\*******\*prototype\*******\*,\**** ***\*{\****      // Set the constructor property appropriately      ***\*constructor\*******\*:\**** SingletonSet***\*,\****      // This set is read-only: add() and remove() throw errors      add***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*throw\**** "read-only set"***\*;\**** ***\*},\****        remove***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*throw\**** "read-only set"***\*;\**** ***\*},\****      // A SingletonSet always has size 1      size***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** 1***\*;\**** ***\*},\****              // Just invoke the function once, passing the single member.      foreach***\*:\**** ***\*function\*******\*(\****f***\*,\**** context***\*)\**** ***\*{\**** f***\*.\****call***\*(\****context***\*,\**** ***\*this\*******\*.\****member***\*);\**** ***\*},\****      // The contains() method is simple: true only for one value      contains***\*:\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x ***\*===\**** ***\*this\*******\*.\****member***\*;\**** ***\*}\****    ***\*});\****

***\*构造函数和方法链\****

定义子类时，我们往往希望对父类的行为进行修改或扩充，而不是完全替换。在子类中调用父类的构造函数和方法

/* * NonNullSet is a subclass of Set that does not allow null and undefined * as members of the set. */****function\**** NonNullSet***\*()\**** ***\*{\****  // Just chain to our superclass.  // Invoke the superclass constructor as an ordinary function to initialize  // the object that has been created by this constructor invocation.  Set***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\*******\*}\**** // Make NonNullSet a subclass of Set:NonNullSet***\*.\*******\*prototype\**** ***\*=\**** inherit***\*(\****Set***\*.\*******\*prototype\*******\*);\****NonNullSet***\*.\*******\*prototype\*******\*.\*******\*constructor\**** ***\*=\**** NonNullSet***\*;\**** // To exclude null and undefined, we only have to override the add() methodNonNullSet***\*.\*******\*prototype\*******\*.\****add ***\*=\**** ***\*function\*******\*()\**** ***\*{\****  // Check for null or undefined arguments  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** 0***\*;\**** i ***\*<\**** arguments***\*.\****length***\*;\**** i***\*++)\****    ***\*if\**** ***\*(\****arguments***\*[\****i***\*]\**** ***\*==\**** ***\*null\*******\*)\****      ***\*throw\**** ***\*new\**** Error***\*(\****"Can't add null or undefined to a NonNullSet"***\*);\****   // Chain to the superclass to perform the actual insertion  ***\*return\**** Set***\*.\*******\*prototype\*******\*.\****add***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\*******\*};\****

让我们将这个非null集合的概念推而广之，称为“过滤后的集合”，这个集合中的成员必须首先传入一个过滤函数再执行添加操作。

//定义一个只能保存字符串的“集合”类***\*var\**** StringSet ***\*=\**** flteredSetSubclass***\*(\****Set***\*,\*******\*function\*******\*(\****x***\*)\**** ***\*{\*******\*return\**** ***\*typeof\**** x***\*===\****"string"***\*;});\**** //这个集合类的成员不能是null、undefined或函数***\*var\**** MySet ***\*=\**** filteredSetSubclass***\*(\****NonNullSet***\*,\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\*******\*return\**** ***\*typeof\**** x ***\*!==\**** "function"***\*;});\****

下例是这个类工厂函数的实现代码。注意，这个例子中的方法链和构造函数链和NonNullset中的实现是一样的。

类工厂和方法链：

/* * This function returns a subclass of specified Set class and overrides  * the add() method of that class to apply the specified filter. */****function\**** filteredSetSubclass***\*(\****superclass***\*,\**** filter***\*)\**** ***\*{\****  ***\*var\**** ***\*constructor\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\****     // The subclass constructor    superclass***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\**** // Chains to the superclass  ***\*};\****  ***\*var\**** proto ***\*=\**** ***\*constructor\*******\*.\*******\*prototype\**** ***\*=\**** inherit***\*(\****superclass***\*.\*******\*prototype\*******\*);\****  proto***\*.\*******\*constructor\**** ***\*=\**** ***\*constructor\*******\*;\****  proto***\*.\****add ***\*=\**** ***\*function\*******\*()\**** ***\*{\****    // Apply the filter to all arguments before adding any    ***\*for\*******\*(\*******\*var\**** i ***\*=\**** 0***\*;\**** i ***\*<\**** arguments***\*.\****length***\*;\**** i***\*++)\**** ***\*{\****      ***\*var\**** v ***\*=\**** arguments***\*[\****i***\*];\****      ***\*if\**** ***\*(!\****filter***\*(\****v***\*))\**** ***\*throw\*******\*(\****"value " ***\*+\**** v ***\*+\**** " rejected by filter"***\*);\****    ***\*}\****    // Chain to our superclass add implementation    superclass***\*.\*******\*prototype\*******\*.\****add***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\****  ***\*};\****  ***\*return\**** ***\*constructor\*******\*;\*******\*}\****

一个比较有趣的事情是，用一个函数将创建子类的代码包装起来，这样就可以在构造函数和方法链中使用父类的参数，而不是通过写死某个父类的名字来使用它的参数。也就是说如果想修改父类，只须修改一处代码即可，而不必对每个用到父类类名的地方都做修改。已经有充足的理由证明这种技术的可行性，即使在不是定义类工厂的场景中，这种技术也是值得提倡使用的。比如，可以这样使用包装函数和Function.prototype.extend()方法来重写NonNullSet:

***\*var\**** NonNullSet ***\*=\**** ***\*(\*******\*function\*******\*()\**** ***\*{\**** //定义并立即调用这个函数	***\*var\**** superclass ***\*=\**** Set***\*;\**** //仅指定父类	***\*return\**** superclass***\*.\****extend***\*(\**** 	***\*function\*******\*()\**** ***\*{\**** superclass***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\**** ***\*},\**** //构造函数		***\*{\****//方法			add***\*:\**** ***\*function\*******\*()\**** ***\*{\**** 			//检查参数是否是null或undefined				***\*for\**** ***\*(\*******\*var\**** i ***\*=\**** 0***\*;\**** i ***\*<\**** arguments***\*.\****length***\*;\**** i***\*++)\**** 				***\*if\**** ***\*(\****arguments***\*[\****i***\*]\**** ***\*==\**** ***\*null\*******\*)\**** 					***\*throw\**** ***\*new\**** Error***\*(\****"Can't add null or undefined"***\*);\**** 			//调用父类的add()方法以执行实际插入操作				***\*return\**** superclass***\*.\*******\*prototype\*******\*.\****add***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\**** 		***\*}\****		***\*});\*******\*}\**** ***\*());\****

最后，值得强调的是，类似这种创建类工厂的能力是JavaScript语言动态特性的一个体现，类工厂是一种非常强大和有用的特性，这在Java和C++等语言中是没有的。

***\*组合 vs 子类\****

在上面，定义的集合可以根据特定的标准对集合成员做限制，而且使用了子类的技术来实现这种功能，所创建的自定义子类使用了特定的过滤函数来对集合中的成员做限制。父类和过滤函数的每个组合都需要创建一个新的类。然而还有另一种更好的方法来完成这种需求，即面向对象编程中一条广为人知的设计原则“组合优于继承”。这样，可以利用组合的原理定义一个新的集合实现，它“包装”了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个(包装的)集合对象。

/* * A FilteredSet wraps a specified set object and applies a specified filter * to values passed to its add() method.  All of the other core set methods  * simply forward to the wrapped set instance. */****var\**** FilteredSet ***\*=\**** Set***\*.\****extend***\*(\****  ***\*function\**** FilteredSet***\*(\****set***\*,\**** filter***\*)\**** ***\*{\**** // The constructor    ***\*this\*******\*.\****set ***\*=\**** set***\*;\****    ***\*this\*******\*.\****filter ***\*=\**** filter***\*;\****  ***\*},\****   ***\*{\**** // The instance methods    add***\*:\**** ***\*function\*******\*()\**** ***\*{\****      // If we have a filter, apply it      ***\*if\**** ***\*(\*******\*this\*******\*.\****filter***\*)\**** ***\*{\****        ***\*for\*******\*(\*******\*var\**** i ***\*=\**** 0***\*;\**** i ***\*<\**** arguments***\*.\****length***\*;\**** i***\*++)\**** ***\*{\****          ***\*var\**** v ***\*=\**** arguments***\*[\****i***\*];\****          ***\*if\**** ***\*(!\*******\*this\*******\*.\****filter***\*(\****v***\*))\****            ***\*throw\**** ***\*new\**** Error***\*(\****"FilteredSet: value " ***\*+\**** v ***\*+\**** " rejected by filter"***\*);\****        ***\*}\****      ***\*}\****      // Now forward the add() method to this.set.add()      ***\*this\*******\*.\****set***\*.\****add***\*.\****apply***\*(\*******\*this\*******\*.\****set***\*,\**** arguments***\*);\****      ***\*return\**** ***\*this\*******\*;\****    ***\*},\****    // The rest of the methods just forward to this.set and do nothing else.    remove***\*:\**** ***\*function\*******\*()\**** ***\*{\****      ***\*this\*******\*.\****set***\*.\****remove***\*.\****apply***\*(\*******\*this\*******\*.\****set***\*,\**** arguments***\*);\****      ***\*return\**** ***\*this\*******\*;\****    ***\*},\****    contains***\*:\**** ***\*function\*******\*(\****v***\*)\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\****set***\*.\****contains***\*(\****v***\*);\**** ***\*},\****    size***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\****set***\*.\****size***\*();\**** ***\*},\****    foreach***\*:\**** ***\*function\*******\*(\****f***\*,\****c***\*)\**** ***\*{\**** ***\*this\*******\*.\****set***\*.\****foreach***\*(\****f***\*,\****c***\*);\**** ***\*}\****  ***\*});\****

在这个例子中使用组合的一个好处是，只须创建一个单独的FilteredSet子类即可。可以利用这个类的实例来创建任意带有成员限制的集合实例。比如，不用上文中定义的NonNullSet类，可以这样做:

***\*var\**** s = new FilteredSet(new Set(), ***\*function\****(x) { ***\*return\**** x !== ***\*null\****; }); 

甚至还可以对已经过滤后的集合进行过滤:

***\*var\**** t = new FilteredSet(s, ***\*function\****(x) { ***\*return\**** !(x ***\*instanceof\**** Set); });

***\*类的层次结构和抽象类\****

“从实现中抽离出接口”

// A convenient function that can be used for any abstract method***\*function\**** abstractmethod***\*()\**** ***\*{\**** ***\*throw\**** ***\*new\**** Error***\*(\****"abstract method"***\*);\**** ***\*}\**** /* * The AbstractSet class defines a single abstract method, contains(). */****function\**** AbstractSet***\*()\**** ***\*{\**** ***\*throw\**** ***\*new\**** Error***\*(\****"Can't instantiate abstract classes"***\*);}\****AbstractSet***\*.\*******\*prototype\*******\*.\****contains ***\*=\**** abstractmethod***\*;\**** /* * NotSet is a concrete subclass of AbstractSet. * The members of this set are all values that are not members of some * other set. Because it is defined in terms of another set it is not * writable, and because it has infinite members, it is not enumerable. * All we can do with it is test for membership. * Note that we're using the Function.prototype.extend() method we defined * earlier to define this subclass. */****var\**** NotSet ***\*=\**** AbstractSet***\*.\****extend***\*(\****  ***\*function\**** NotSet***\*(\****set***\*)\**** ***\*{\**** ***\*this\*******\*.\****set ***\*=\**** set***\*;\**** ***\*},\****  ***\*{\****    contains***\*:\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** ***\*!\*******\*this\*******\*.\****set***\*.\****contains***\*(\****x***\*);\**** ***\*},\****    toString***\*:\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** "~" ***\*+\**** ***\*this\*******\*.\****set***\*.\****toString***\*();\**** ***\*},\****    equals***\*:\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****      ***\*return\**** that ***\*instanceof\**** NotSet ***\*&&\**** ***\*this\*******\*.\****set***\*.\****equals***\*(\****that***\*.\****set***\*);\****    ***\*}\****  ***\*}\*******\*);\**** /* * AbstractEnumerableSet is an abstract subclass of AbstractSet. * It defines the abstract methods size() and foreach(), and then implements * concrete isEmpty(), toArray(), to[Locale]String(), and equals() methods * on top of those. Subclasses that implement contains(), size(), and foreach()  * get these five concrete methods for free. */****var\**** AbstractEnumerableSet ***\*=\**** AbstractSet***\*.\****extend***\*(\****  ***\*function\*******\*()\**** ***\*{\**** ***\*throw\**** ***\*new\**** Error***\*(\****"Can't instantiate abstract classes"***\*);\**** ***\*},\****   ***\*{\****    size***\*:\**** abstractmethod***\*,\****    foreach***\*:\**** abstractmethod***\*,\****    isEmpty***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\****size***\*()\**** ***\*==\**** 0***\*;\**** ***\*},\****    toString***\*:\**** ***\*function\*******\*()\**** ***\*{\****      ***\*var\**** s ***\*=\**** "{"***\*,\**** i ***\*=\**** 0***\*;\****      ***\*this\*******\*.\****foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\****               ***\*if\**** ***\*(\****i***\*++\**** ***\*>\**** 0***\*)\**** s ***\*+=\**** ", "***\*;\****               s ***\*+=\**** v***\*;\****             ***\*});\****      ***\*return\**** s ***\*+\**** "}"***\*;\****    ***\*},\****    toLocaleString ***\*:\**** ***\*function\*******\*()\**** ***\*{\****      ***\*var\**** s ***\*=\**** "{"***\*,\**** i ***\*=\**** 0***\*;\****      ***\*this\*******\*.\****foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\****               ***\*if\**** ***\*(\****i***\*++\**** ***\*>\**** 0***\*)\**** s ***\*+=\**** ", "***\*;\****               ***\*if\**** ***\*(\****v ***\*==\**** ***\*null\*******\*)\**** s ***\*+=\**** v***\*;\**** // null & undefined               ***\*else\**** s ***\*+=\**** v***\*.\****toLocaleString***\*();\**** // all others             ***\*});\****      ***\*return\**** s ***\*+\**** "}"***\*;\****    ***\*},\****    toArray***\*:\**** ***\*function\*******\*()\**** ***\*{\****      ***\*var\**** a ***\*=\**** ***\*[];\****      ***\*this\*******\*.\****foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\**** a***\*.\****push***\*(\****v***\*);\**** ***\*});\****      ***\*return\**** a***\*;\****    ***\*},\****    equals***\*:\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****      ***\*if\**** ***\*(!(\****that ***\*instanceof\**** AbstractEnumerableSet***\*))\**** ***\*return\**** ***\*false\*******\*;\****      // If they don't have the same size, they're not equal      ***\*if\**** ***\*(\*******\*this\*******\*.\****size***\*()\**** ***\*!=\**** that***\*.\****size***\*())\**** ***\*return\**** ***\*false\*******\*;\****      // Now check whether every element in this is also in that.      ***\*try\**** ***\*{\****        ***\*this\*******\*.\****foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\*******\*if\**** ***\*(!\****that***\*.\****contains***\*(\****v***\*))\**** ***\*throw\**** ***\*false\*******\*;});\****        ***\*return\**** ***\*true\*******\*;\**** // All elements matched: sets are equal.      ***\*}\**** ***\*catch\**** ***\*(\****x***\*)\**** ***\*{\****        ***\*if\**** ***\*(\****x ***\*===\**** ***\*false\*******\*)\**** ***\*return\**** ***\*false\*******\*;\**** // Sets are not equal        ***\*throw\**** x***\*;\**** // Some other exception occurred: rethrow it.      ***\*}\****    ***\*}\****  ***\*});\**** /* * SingletonSet is a concrete subclass of AbstractEnumerableSet. * A singleton set is a read-only set with a single member. */****var\**** SingletonSet ***\*=\**** AbstractEnumerableSet***\*.\****extend***\*(\****  ***\*function\**** SingletonSet***\*(\****member***\*)\**** ***\*{\**** ***\*this\*******\*.\****member ***\*=\**** member***\*;\**** ***\*},\****  ***\*{\****    contains***\*:\**** ***\*function\*******\*(\****x***\*)\**** ***\*{\**** ***\*return\**** x ***\*===\**** ***\*this\*******\*.\****member***\*;\**** ***\*},\****    size***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** 1***\*;\**** ***\*},\****    foreach***\*:\**** ***\*function\*******\*(\****f***\*,\****ctx***\*)\**** ***\*{\**** f***\*.\****call***\*(\****ctx***\*,\**** ***\*this\*******\*.\****member***\*);\**** ***\*}\****  ***\*}\*******\*);\**** /* * AbstractWritableSet is an abstract subclass of AbstractEnumerableSet. * It defines the abstract methods add() and remove(), and then implements * concrete union(), intersection(), and difference() methods on top of them. */****var\**** AbstractWritableSet ***\*=\**** AbstractEnumerableSet***\*.\****extend***\*(\****  ***\*function\*******\*()\**** ***\*{\**** ***\*throw\**** ***\*new\**** Error***\*(\****"Can't instantiate abstract classes"***\*);\**** ***\*},\****   ***\*{\****    add***\*:\**** abstractmethod***\*,\****    remove***\*:\**** abstractmethod***\*,\****    union***\*:\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****      ***\*var\**** ***\*self\**** ***\*=\**** ***\*this\*******\*;\****      that***\*.\****foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\**** ***\*self\*******\*.\****add***\*(\****v***\*);\**** ***\*});\****      ***\*return\**** ***\*this\*******\*;\****    ***\*},\****    intersection***\*:\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****      ***\*var\**** ***\*self\**** ***\*=\**** ***\*this\*******\*;\****      ***\*this\*******\*.\****foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\**** ***\*if\**** ***\*(!\****that***\*.\****contains***\*(\****v***\*))\**** ***\*self\*******\*.\****remove***\*(\****v***\*);});\****      ***\*return\**** ***\*this\*******\*;\****    ***\*},\****    difference***\*:\**** ***\*function\*******\*(\****that***\*)\**** ***\*{\****      ***\*var\**** ***\*self\**** ***\*=\**** ***\*this\*******\*;\****      that***\*.\****foreach***\*(\*******\*function\*******\*(\****v***\*)\**** ***\*{\**** ***\*self\*******\*.\****remove***\*(\****v***\*);\**** ***\*});\****      ***\*return\**** ***\*this\*******\*;\****    ***\*}\****  ***\*});\**** /* * An ArraySet is a concrete subclass of AbstractWritableSet. * It represents the set elements as an array of values, and uses a linear * search of the array for its contains() method. Because the contains() * method is O(n) rather than O(1), it should only be used for relatively * small sets. Note that this implementation relies on the ES5 Array methods * indexOf() and forEach(). */****var\**** ArraySet ***\*=\**** AbstractWritableSet***\*.\****extend***\*(\****  ***\*function\**** ArraySet***\*()\**** ***\*{\****    ***\*this\*******\*.\****values ***\*=\**** ***\*[];\****    ***\*this\*******\*.\****add***\*.\****apply***\*(\*******\*this\*******\*,\**** arguments***\*);\****  ***\*},\****  ***\*{\****    contains***\*:\**** ***\*function\*******\*(\****v***\*)\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\****values***\*.\****indexOf***\*(\****v***\*)\**** ***\*!=\**** ***\*-\****1***\*;\**** ***\*},\****    size***\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\*******\*.\****values***\*.\****length***\*;\**** ***\*},\****    foreach***\*:\**** ***\*function\*******\*(\****f***\*,\****c***\*)\**** ***\*{\**** ***\*this\*******\*.\****values***\*.\****forEach***\*(\****f***\*,\**** c***\*);\**** ***\*},\****    add***\*:\**** ***\*function\*******\*()\**** ***\*{\****       ***\*for\*******\*(\*******\*var\**** i ***\*=\**** 0***\*;\**** i ***\*<\**** arguments***\*.\****length***\*;\**** i***\*++)\**** ***\*{\****        ***\*var\**** arg ***\*=\**** arguments***\*[\****i***\*];\****        ***\*if\**** ***\*(!\*******\*this\*******\*.\****contains***\*(\****arg***\*))\**** ***\*this\*******\*.\****values***\*.\****push***\*(\****arg***\*);\****      ***\*}\****      ***\*return\**** ***\*this\*******\*;\****    ***\*},\****    remove***\*:\**** ***\*function\*******\*()\**** ***\*{\****      ***\*for\*******\*(\*******\*var\**** i ***\*=\**** 0***\*;\**** i ***\*<\**** arguments***\*.\****length***\*;\**** i***\*++)\**** ***\*{\****        ***\*var\**** p ***\*=\**** ***\*this\*******\*.\****values***\*.\****indexOf***\*(\****arguments***\*[\****i***\*]);\****        ***\*if\**** ***\*(\****p ***\*==\**** ***\*-\****1***\*)\**** ***\*continue\*******\*;\****        ***\*this\*******\*.\****values***\*.\****splice***\*(\****p***\*,\**** 1***\*);\****      ***\*}\****      ***\*return\**** ***\*this\*******\*;\****    ***\*}\****  ***\*}\*******\*);\****

### ***\*ECMAScript 5 中的类\****

ES5给属性特性增加了方法支持（getter、setter、可枚举性、可写性、可配置型和可扩展性）

***\*让属性不可枚举\****

JS中的数组（或对象）在遍历元素（或属性）过程中，可以动态地增删（C#是不允许的）。

下例展示了如何通过Object.defineProperty() 来让属性不会遍历到，同时也展示了如何定义一个getter函数以及检测对象是否是可扩展的 (extensible) 。

// Wrap our code in a function so we can define variables in the function scope***\*(\*******\*function\*******\*()\**** ***\*{\****   // Define objectId as a nonenumerable property inherited by all objects.   // When this property is read, the getter function is invoked.   // It has no setter, so it is read-only.   // It is nonconfigurable, so it can't be deleted.   Object***\*.\****defineProperty***\*(\****Object***\*.\*******\*prototype\*******\*,\**** "objectId"***\*,\**** ***\*{\****                get***\*:\**** idGetter***\*,\****    // Method to get value                enumerable***\*:\**** ***\*false\*******\*,\****  // Nonenumerable                configurable***\*:\**** ***\*false\**** // Can't delete it              ***\*});\****   // This is the getter function called when objectId is read   ***\*function\**** idGetter***\*()\**** ***\*{\****       // A getter function to return the id     ***\*if\**** ***\*(!(\****idprop ***\*in\**** ***\*this\*******\*))\**** ***\*{\****   // If object doesn't already have an id       ***\*if\**** ***\*(!\****Object***\*.\****isExtensible***\*(\*******\*this\*******\*))\**** // And if we can add a property         ***\*throw\**** Error***\*(\****"Can't define id for nonextensible objects"***\*);\****       Object***\*.\****defineProperty***\*(\*******\*this\*******\*,\**** idprop***\*,\**** ***\*{\****     // Give it one now.                    value***\*:\**** nextid***\*++,\****  // This is the value                    writable***\*:\**** ***\*false\*******\*,\****  // Read-only                    enumerable***\*:\**** ***\*false\*******\*,\**** // Nonenumerable                    configurable***\*:\**** ***\*false\**** // Nondeletable                  ***\*});\****     ***\*}\****     ***\*return\**** ***\*this\*******\*[\****idprop***\*];\****     // Now return the existing or new value   ***\*};\****   // These variables are used by idGetter() and are private to this function   ***\*var\**** idprop ***\*=\**** "|**objectId**|"***\*;\****  // Assume this property isn't in use   ***\*var\**** nextid ***\*=\**** 1***\*;\****          // Start assigning ids at this # ***\*}());\**** // Invoke the wrapper function to run the code right away

***\*定义不可变的类\****

创建一个不可变的类，它的属性和方法都是只读的

**// This function works with or without 'new': a constructor and factory function**

***\*function\**** Range***\*(\****from***\*,\****to***\*)\**** ***\*{\****

  **// These are descriptors for the read-only from and to properties.**

  ***\*var\**** props ***\*=\**** ***\*{\****

​    from***\*:\**** ***\*{\*******\*value\*******\*:\****from***\*,\**** enumerable***\*:\*******\*true\*******\*,\**** writable***\*:\*******\*false\*******\*,\**** configurable***\*:\*******\*false\*******\*},\****

​    to***\*:\**** ***\*{\*******\*value\*******\*:\****to***\*,\**** enumerable***\*:\*******\*true\*******\*,\**** writable***\*:\*******\*false\*******\*,\**** configurable***\*:\*******\*false\*******\*}\****

  ***\*};\****

  ***\*if\**** ***\*(\*******\*this\**** ***\*instanceof\**** Range***\*)\****        **// If invoked as a constructor**

​    ***\*Object\****.defineProperties***\*(\*******\*this\*******\*,\**** props***\*);\**** **// Define the properties**

  ***\*else\****                   **// Otherwise, as a factory** 

​    ***\*return\**** ***\*Object\****.create***\*(\****Range.***\*prototype\*******\*,\**** **// Create and return a new**

​               props***\*);\****     **// Range object with props**

***\*}\****

 

**// If we add properties to the Range.prototype object in the same way,**

**// then we can set attributes on those properties.  Since we don't specify**

**// enumerable, writable, or configurable, they all default to false.**

***\*Object\****.defineProperties***\*(\****Range.***\*prototype\*******\*,\**** ***\*{\****

  includes***\*:\**** ***\*{\****

​    ***\*value\*******\*:\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** ***\*return\**** ***\*this\****.from <***\*=\**** ***\*x\**** ***\*&&\**** ***\*x\**** <***\*=\**** ***\*this\****.to***\*;\**** ***\*}\****

  ***\*},\****

  foreach***\*:\**** ***\*{\****

​    ***\*value\*******\*:\**** ***\*function\*******\*(\****f***\*)\**** ***\*{\****

​      ***\*for\*******\*(\*******\*var\**** ***\*x\**** ***\*=\**** ***\*Math\****.***\*ceil\*******\*(\*******\*this\****.from***\*);\**** ***\*x\**** <***\*=\**** ***\*this\****.to***\*;\**** ***\*x\*******\*++)\**** f***\*(\*******\*x\*******\*);\****

​    ***\*}\****

  ***\*},\****

  ***\*toString\*******\*:\**** ***\*{\****

​    ***\*value\*******\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** **"("** ***\*+\**** ***\*this\****.from ***\*+\**** **"..."** ***\*+\**** ***\*this\****.to ***\*+\**** **")"\******;\**** ***\*}\****

  ***\*}\****

***\*});\****

属性描述符对象让代码可读性变得更差，一种改进做法是将修改这个已定义属性的特性的操作定义为一个工具函数。

**// Make the named (or all) properties of o nonwritable and nonconfigurable.**

***\*function\**** freezeProps***\*(\****o***\*)\**** ***\*{\****

  ***\*var\**** props ***\*=\**** ***\*(\*******\*arguments\****.***\*length\**** ***\*==\**** ***\*1\*******\*)\****       **// If 1 arg**

​    ***\*?\**** ***\*Object\****.getOwnPropertyNames***\*(\****o***\*)\****       **//  use all props**

​    ***\*:\**** ***\*Array\****.***\*prototype\****.***\*splice\****.***\*call\*******\*(\*******\*arguments\*******\*,\**** ***\*1\*******\*);\**** **//  else named props**

  props.forEach***\*(\*******\*function\*******\*(\****n***\*)\**** ***\*{\**** **// Make each one read-only and permanent**

​    **// Ignore nonconfigurable properties**

​    ***\*if\**** ***\*(!\*******\*Object\****.getOwnPropertyDescriptor***\*(\****o***\*,\****n***\*)\****.configurable***\*)\**** ***\*return\*******\*;\****

​    ***\*Object\****.defineProperty***\*(\****o***\*,\**** n***\*,\**** ***\*{\**** writable***\*:\**** ***\*false\*******\*,\**** configurable***\*:\**** ***\*false\**** ***\*});\****

  ***\*});\****

  ***\*return\**** o***\*;\**** **// So we can keep using it**

***\*}\****

 

**// Make the named (or all) properties of o nonenumerable, if configurable.**

***\*function\**** hideProps***\*(\****o***\*)\**** ***\*{\****

  ***\*var\**** props ***\*=\**** ***\*(\*******\*arguments\****.***\*length\**** ***\*==\**** ***\*1\*******\*)\****       **// If 1 arg**

​    ***\*?\**** ***\*Object\****.getOwnPropertyNames***\*(\****o***\*)\****       **//  use all props**

​    ***\*:\**** ***\*Array\****.***\*prototype\****.***\*splice\****.***\*call\*******\*(\*******\*arguments\*******\*,\**** ***\*1\*******\*);\**** **//  else named props**

  props.forEach***\*(\*******\*function\*******\*(\****n***\*)\**** ***\*{\**** **// Hide each one from the for/in loop**

​    **// Ignore nonconfigurable properties**

​    ***\*if\**** ***\*(!\*******\*Object\****.getOwnPropertyDescriptor***\*(\****o***\*,\****n***\*)\****.configurable***\*)\**** ***\*return\*******\*;\****

​    ***\*Object\****.defineProperty***\*(\****o***\*,\**** n***\*,\**** ***\*{\**** enumerable***\*:\**** ***\*false\**** ***\*});\****

  ***\*});\****

  ***\*return\**** o***\*;\****

***\*}\****

Object.defineProperty() 和Object.defineProperties() 可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。但当用它们修改已经存在的属性时，默认的属性特性依然保持不变。

使用这些工具函数，利用ES5的特性可以很容易实现一个简单的不可变的类

***\*function\**** Range***\*(\****from***\*,\**** to***\*)\**** ***\*{\****  **// Constructor for an immutable Range class**

  ***\*this\****.from ***\*=\**** from***\*;\****

  ***\*this\****.to ***\*=\**** to***\*;\****

  freezeProps***\*(\*******\*this\*******\*);\****    **// Make the properties immutable**

***\*}\****

 

Range.***\*prototype\**** ***\*=\**** hideProps***\*({\**** **// Define prototype with nonenumerable properties**

  constructor***\*:\**** Range***\*,\****

  includes***\*:\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** ***\*return\**** ***\*this\****.from <***\*=\**** ***\*x\**** ***\*&&\**** ***\*x\**** <***\*=\**** ***\*this\****.to***\*;\**** ***\*},\****

  foreach***\*:\**** ***\*function\*******\*(\****f***\*)\**** ***\*{\*******\*for\*******\*(\*******\*var\**** ***\*x\*******\*=\*******\*Math\****.***\*ceil\*******\*(\*******\*this\****.from***\*);\*******\*x\****<***\*=\*******\*this\****.to***\*;\*******\*x\*******\*++)\**** f***\*(\*******\*x\*******\*);},\****

  ***\*toString\*******\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** **"("** ***\*+\**** ***\*this\****.from ***\*+\**** **"..."** ***\*+\**** ***\*this\****.to ***\*+\**** **")"\******;\**** ***\*}\****

***\*});\****

***\*封装对象状态\****

构造函数中的变量和参数可以用做它创建的对象的私有状态。该方法在ECMAScript 3 中的一个缺点是，访问这些私有状态的存取器方法是可以替换的。在ECMAScript 5 中可以通过定义属性getter和setter方法将状态变量更健壮地封装起来，这两个方法是无法删除的。

示例：将Range类的端点严格封装起来

**// This version of the Range class is mutable but encapsulates its endpoint**

**// variables to maintain the invariant that from <= to.**

***\*function\**** Range***\*(\****from***\*,\**** to***\*)\**** ***\*{\****

  **// Verify that the invariant holds when we're created**

  ***\*if\**** ***\*(\****from ***\*>\**** to***\*)\**** ***\*throw\**** ***\*new\**** Error***\*(\******"Range: from must be <= to"\******);\****

 

  **// Define the accessor methods that maintain the invariant**

  ***\*function\**** getFrom***\*()\**** ***\*{\**** ***\*return\**** from***\*;\**** ***\*}\****

  ***\*function\**** getTo***\*()\**** ***\*{\**** ***\*return\**** to***\*;\**** ***\*}\****

  ***\*function\**** setFrom***\*(\****f***\*)\**** ***\*{\**** **// Don't allow from to be set > to**

​    ***\*if\**** ***\*(\****f <***\*=\**** to***\*)\**** from ***\*=\**** f***\*;\****

​    ***\*else\**** ***\*throw\**** ***\*new\**** Error***\*(\******"Range: from must be <= to"\******);\****

  ***\*}\****

  ***\*function\**** setTo***\*(\****t***\*)\**** ***\*{\****  **// Don't allow to to be set < from**

​    ***\*if\**** ***\*(\****t ***\*>=\**** from***\*)\**** to ***\*=\**** t***\*;\****

​    ***\*else\**** ***\*throw\**** ***\*new\**** Error***\*(\******"Range: to must be >= from"\******);\****

  ***\*}\****

 

  **// Create enumerable, nonconfigurable properties that use the accessors**

  ***\*Object\****.defineProperties***\*(\*******\*this\*******\*,\**** ***\*{\****

​    from***\*:\**** ***\*{\*******\*get\*******\*:\**** getFrom***\*,\**** set***\*:\**** setFrom***\*,\**** enumerable***\*:\*******\*true\*******\*,\**** configurable***\*:\*******\*false\*******\*},\****

​    to***\*:\**** ***\*{\**** ***\*get\*******\*:\**** getTo***\*,\**** set***\*:\**** setTo***\*,\**** enumerable***\*:\*******\*true\*******\*,\**** configurable***\*:\*******\*false\**** ***\*}\****

  ***\*});\****

***\*}\****

 

**// The prototype object is unchanged from previous examples.**

**// The instance methods read from and to as if they were ordinary properties.**

Range.***\*prototype\**** ***\*=\**** hideProps***\*({\****

  constructor***\*:\**** Range***\*,\****

  includes***\*:\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** ***\*return\**** ***\*this\****.from <***\*=\**** ***\*x\**** ***\*&&\**** ***\*x\**** <***\*=\**** ***\*this\****.to***\*;\**** ***\*},\****

  foreach***\*:\**** ***\*function\*******\*(\****f***\*)\**** ***\*{\*******\*for\*******\*(\*******\*var\**** ***\*x\*******\*=\*******\*Math\****.***\*ceil\*******\*(\*******\*this\****.from***\*);\*******\*x\****<***\*=\*******\*this\****.to***\*;\*******\*x\*******\*++)\**** f***\*(\*******\*x\*******\*);},\****

  ***\*toString\*******\*:\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** **"("** ***\*+\**** ***\*this\****.from ***\*+\**** **"..."** ***\*+\**** ***\*this\****.to ***\*+\**** **")"\******;\**** ***\*}\****

***\*});\****

***\*防止类的扩展\****

Object.preventExtensions()可以将对象设置为不可扩展的，也就是说不能给对象添加任何新属性。Object.seal()则更加强大，它除了能阻止用户给对象添加新属性，还能将当前已有的属性设置为不可配置的，这样就不能删除这些属性了（但不可配置的属性可以是可写的，也可以转换为只读属性）。

JavaScript的另外一个动态特性是"对象的方法可以随时替换"(或称为"monkey­patch"):

***\*var\**** original_sort_method ***\*=\**** ***\*Array\****.***\*prototype\****.***\*sort\*******\*;\**** 

***\*Array\****.***\*prototype\****.***\*sort\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** 

 ***\*var\**** start ***\*=\**** ***\*new\**** ***\*Date\*******\*();\****

 original_sort_method.***\*apply\*******\*(\*******\*this\*******\*,\**** ***\*arguments\*******\*);\**** 

 ***\*var\**** end ***\*=\**** ***\*new\**** ***\*Date\*******\*();\**** 

 console.***\*log\*******\*(\******"Array sort took "** ***\*+\**** ***\*(\****end ***\*-\**** start***\*)\**** ***\*+\**** **" milliseconds."\******);\****

***\*};\**** 

可以通过将实例方法设置为只读来防止这类修改，一种方法就是使用上面代码所定义的freezeProps()工具函数。另外一种方法是使用Object.freeze()，它的功能和Object.seal()完全一样，它同样会把所有属性都设置为只读的和不可配置的。

理解类的只读属性的特性至关重要。如果对象o继承了只读属性p，那么给o.p的赋值操作将会失败，就不会给o创建新属性。如果你想重写一个继承来的只读属性，就必须使用Object.definePropertiy()、Object.defineProperties()或Object.create()来创建这个新属性。也就是说，如果将类的实例方法设置为只读的，那么重写它的子类的这些方法的难度会更大。

***\*子类和ECMAScript 5\****

示例StringSet: 利用ECMAScript 5的特性定义的子类，困难之处在于需要使用难看的属性描述符。

***\*function\**** StringSet***\*()\**** ***\*{\****

  ***\*this\****.set ***\*=\**** ***\*Object\****.create***\*(\*******\*null\*******\*);\**** **// Create object with no proto**

  ***\*this\****.n ***\*=\**** ***\*0\*******\*;\****

  ***\*this\****.add.***\*apply\*******\*(\*******\*this\*******\*,\**** ***\*arguments\*******\*);\****

***\*}\****

 

**// Note that with Object.create we can inherit from the superclass prototype**

**// and define methods in a single call. Since we don't specify any of the**

**// writable, enumerable, and configurable properties, they all default to false.**

**// Readonly methods makes this class trickier to subclass.**

StringSet.***\*prototype\**** ***\*=\**** ***\*Object\****.create***\*(\****AbstractWritableSet.***\*prototype\*******\*,\**** ***\*{\****

  constructor***\*:\**** ***\*{\**** ***\*value\*******\*:\**** StringSet ***\*},\****

  ***\*contains\*******\*:\**** ***\*{\**** ***\*value\*******\*:\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** ***\*return\**** ***\*x\**** ***\*in\**** ***\*this\****.set***\*;\**** ***\*}\**** ***\*},\****

  size***\*:\**** ***\*{\**** ***\*value\*******\*:\**** ***\*function\*******\*(\*******\*x\*******\*)\**** ***\*{\**** ***\*return\**** ***\*this\****.n***\*;\**** ***\*}\**** ***\*},\****

  foreach***\*:\**** ***\*{\**** ***\*value\*******\*:\**** ***\*function\*******\*(\****f***\*,\****c***\*)\**** ***\*{\**** ***\*Object\****.keys***\*(\*******\*this\****.set***\*)\****.forEach***\*(\****f***\*,\****c***\*);\**** ***\*}\**** ***\*},\****

  add***\*:\**** ***\*{\****

​    ***\*value\*******\*:\**** ***\*function\*******\*()\**** ***\*{\****

​      ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\****

​        ***\*if\**** ***\*(!(\*******\*arguments\*******\*[\****i***\*]\**** ***\*in\**** ***\*this\****.set***\*))\**** ***\*{\****

​          ***\*this\****.set***\*[\*******\*arguments\*******\*[\****i***\*]]\**** ***\*=\**** ***\*true\*******\*;\****

​          ***\*this\****.n***\*++;\****

​        ***\*}\****

​      ***\*}\****

​      ***\*return\**** ***\*this\*******\*;\****

​    ***\*}\**** 

  ***\*},\****

  remove***\*:\**** ***\*{\****

​    ***\*value\*******\*:\**** ***\*function\*******\*()\**** ***\*{\****

​      ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*arguments\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\****

​        ***\*if\**** ***\*(\*******\*arguments\*******\*[\****i***\*]\**** ***\*in\**** ***\*this\****.set***\*)\**** ***\*{\****

​          ***\*delete\**** ***\*this\****.set***\*[\*******\*arguments\*******\*[\****i***\*]];\****

​          ***\*this\****.n***\*--;\****

​        ***\*}\****

​      ***\*}\****

​      ***\*return\**** ***\*this\*******\*;\****

​    ***\*}\**** 

  ***\*}\****

***\*});\****

***\*属性描述符\****

ECMAScript 5属性描述符示例

**/\***

 *** Define a properties() method in Object.prototype that returns an**

 *** object representing the named properties of the object on which it**

 *** is invoked (or representing all own properties of the object, if**

 *** invoked with no arguments).  The returned object defines four useful** 

 *** methods: toString(), descriptors(), hide(), and show().**

 ***/**

***\*(\*******\*function\**** namespace***\*()\**** ***\*{\**** **// Wrap everything in a private function scope**

 

   **// This is the function that becomes a method of all object**

   ***\*function\**** properties***\*()\**** ***\*{\****

​     ***\*var\**** names***\*;\**** **// An array of property names**

​     ***\*if\**** ***\*(\*******\*arguments\****.***\*length\**** ***\*==\**** ***\*0\*******\*)\**** **// All own properties of this**

​       names ***\*=\**** ***\*Object\****.getOwnPropertyNames***\*(\*******\*this\*******\*);\****

​     ***\*else\**** ***\*if\**** ***\*(\*******\*arguments\****.***\*length\**** ***\*==\**** ***\*1\**** ***\*&&\**** ***\*Array\****.isArray***\*(\*******\*arguments\*******\*[\*******\*0\*******\*]))\****

​       names ***\*=\**** ***\*arguments\*******\*[\*******\*0\*******\*];\****  **// Or an array of names**

​     ***\*else\****            **// Or the names in the argument list**

​       names ***\*=\**** ***\*Array\****.***\*prototype\****.***\*splice\****.***\*call\*******\*(\*******\*arguments\*******\*,\**** ***\*0\*******\*);\****

 

​     **// Return a new Properties object representing the named properties**

​     ***\*return\**** ***\*new\**** Properties***\*(\*******\*this\*******\*,\**** names***\*);\****

   ***\*}\****

 

   **// Make it a new nonenumerable property of Object.prototype.**

   **// This is the only value exported from this private function scope.**

   ***\*Object\****.defineProperty***\*(\*******\*Object\****.***\*prototype\*******\*,\**** **"properties"\******,\**** ***\*{\****

​     ***\*value\*******\*:\**** properties***\*,\**** 

​     enumerable***\*:\**** ***\*false\*******\*,\**** writable***\*:\**** ***\*true\*******\*,\**** configurable***\*:\**** ***\*true\****

   ***\*});\****

 

   **// This constructor function is invoked by the properties() function above.**

   **// The Properties class represents a set of properties of an object.**

   ***\*function\**** Properties***\*(\****o***\*,\**** names***\*)\**** ***\*{\****

​     ***\*this\****.o ***\*=\**** o***\*;\****      **// The object that the properties belong to**

​     ***\*this\****.names ***\*=\**** names***\*;\****  **// The names of the properties**

   ***\*}\****

   

   **// Make the properties represented by this object nonenumerable**

   Properties.***\*prototype\****.hide ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

​     ***\*var\**** o ***\*=\**** ***\*this\****.o***\*,\**** ***\*hidden\**** ***\*=\**** ***\*{\**** enumerable***\*:\**** ***\*false\**** ***\*};\****

​     ***\*this\****.names.forEach***\*(\*******\*function\*******\*(\****n***\*)\**** ***\*{\****

​                ***\*if\**** ***\*(\****o.hasOwnProperty***\*(\****n***\*))\****

​                  ***\*Object\****.defineProperty***\*(\****o***\*,\**** n***\*,\**** ***\*hidden\*******\*);\****

​              ***\*});\****

​     ***\*return\**** ***\*this\*******\*;\****

   ***\*};\****

 

   **// Make these properties read-only and nonconfigurable**

   Properties.***\*prototype\****.freeze ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

​     ***\*var\**** o ***\*=\**** ***\*this\****.o***\*,\**** frozen ***\*=\**** ***\*{\**** writable***\*:\**** ***\*false\*******\*,\**** configurable***\*:\**** ***\*false\**** ***\*};\****

​     ***\*this\****.names.forEach***\*(\*******\*function\*******\*(\****n***\*)\**** ***\*{\****

​                ***\*if\**** ***\*(\****o.hasOwnProperty***\*(\****n***\*))\****

​                  ***\*Object\****.defineProperty***\*(\****o***\*,\**** n***\*,\**** frozen***\*);\****

​              ***\*});\****

​     ***\*return\**** ***\*this\*******\*;\****

   ***\*};\****

 

   **// Return an object that maps names to descriptors for these properties.**

   **// Use this to copy properties along with their attributes:**

   **//  Object.defineProperties(dest, src.properties().descriptors());**

   Properties.***\*prototype\****.descriptors ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

​     ***\*var\**** o ***\*=\**** ***\*this\****.o***\*,\**** desc ***\*=\**** ***\*{};\****

​     ***\*this\****.names.forEach***\*(\*******\*function\*******\*(\****n***\*)\**** ***\*{\****

​                ***\*if\**** ***\*(!\****o.hasOwnProperty***\*(\****n***\*))\**** ***\*return\*******\*;\****

​                desc***\*[\****n***\*]\**** ***\*=\**** ***\*Object\****.getOwnPropertyDescriptor***\*(\****o***\*,\****n***\*);\****

​              ***\*});\****

​     ***\*return\**** desc***\*;\****

   ***\*};\****

 

   **// Return a nicely formatted list of properties, listing the** 

   **// name, value and attributes. Uses the term "permanent" to mean**

   **// nonconfigurable, "readonly" to mean nonwritable, and "hidden"**

   **// to mean nonenumerable. Regular enumerable, writable, configurable** 

   **// properties have no attributes listed.**

   Properties.***\*prototype\****.***\*toString\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\****

​     ***\*var\**** o ***\*=\**** ***\*this\****.o***\*;\**** **// Used in the nested function below**

​     ***\*var\**** lines ***\*=\**** ***\*this\****.names.map***\*(\****nameToString***\*);\****

​     ***\*return\**** **"{\n  "** ***\*+\**** lines.***\*join\*******\*(\******",\n  "\******)\**** ***\*+\**** **"\n}"\******;\****

​     

​     ***\*function\**** nameToString***\*(\****n***\*)\**** ***\*{\****

​       ***\*var\**** s ***\*=\**** **""\******,\**** desc ***\*=\**** ***\*Object\****.getOwnPropertyDescriptor***\*(\****o***\*,\**** n***\*);\****

​       ***\*if\**** ***\*(!\****desc***\*)\**** ***\*return\**** **"nonexistent "** ***\*+\**** n ***\*+\**** **": undefined"\******;\****

​       ***\*if\**** ***\*(!\****desc.configurable***\*)\**** s ***\*+=\**** **"permanent "\******;\****

​       ***\*if\**** ***\*((\****desc.***\*get\**** ***\*&&\**** ***\*!\****desc.set***\*)\**** ***\*||\**** ***\*!\****desc.writable***\*)\**** s ***\*+=\**** **"readonly "\******;\****

​       ***\*if\**** ***\*(!\****desc.enumerable***\*)\**** s ***\*+=\**** **"hidden "\******;\****

​       ***\*if\**** ***\*(\****desc.***\*get\**** ***\*||\**** desc.set***\*)\**** s ***\*+=\**** **"accessor "** ***\*+\**** n

​       ***\*else\**** s ***\*+=\**** n ***\*+\**** **": "** ***\*+\**** ***\*((typeof\**** desc.***\*value\*******\*===\******"function"\******)?\******"function"**

​                                  ***\*:\****desc.***\*value\*******\*);\****

​       ***\*return\**** s***\*;\****

​     ***\*}\****

   ***\*};\****

 

   **// Finally, make the instance methods of the prototype object above** 

   **// nonenumerable, using the methods we've defined here.**

   Properties.***\*prototype\****.properties***\*()\****.hide***\*();\****

***\*}());\**** **// Invoke the enclosing function as soon as we're done defining it.**

### ***\*模块\****

将代码组织到类中的一个重要原因是，让代码更加“模块化”，可以在很多不同场景中实现代码的重用。但类不是唯一的模块化代码的方式。一般来讲，模块是一个独立的JavaScript文件。模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。只要以模块的形式编写代码，任何JavaScript代码段就可以当做一个模块。

模块化的目标是支持大规模的程序开发，处理分散源中代码的组装，并且能让代码正确运行，哪怕包含了作者所不期望出现的模块代码，也可以正确执行代码。为了做到这一点，不同的模块必须***\*避免修改全局执行上下文\****，因此后续模块应当在它们所期望运行的原始（或接近原始）上下文中执行。

***\*用做命名空间的对象\****

在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间将对象属性存储起来（可以通过全局变量引用），而不是定义全局函数和变量。

按照约定，模块的文件名应当和命名空间匹配。比如：使用命名空间com.colin.collections.sets的模块应当在文件com/colin/collections/sets.js中

***\*作为私有命名空间的函数\****

不希望对外公开的函数或方法可以利用函数作用域实现。

示例：模块函数中的Set类

**// Declare a global variable Set and assign it the return value of this function**

**// The open parenthesis and the function name below hint that the function** 

**// will be invoked immediately after being defined, and that it is the function**

**// return value, not the function itself, that is being assigned.**

**// Note that this is a function expression, not a statement, so the name**

**// "invocation" does not create a global variable.**

***\*var\**** Set ***\*=\**** ***\*(\*******\*function\**** invocation***\*()\**** ***\*{\****

  

  ***\*function\**** Set***\*()\**** ***\*{\**** **// This constructor function is a local variable.**

​    ***\*this\****.values ***\*=\**** ***\*{};\****   **// The properties of this object hold the set**

​    ***\*this\****.n ***\*=\**** ***\*0\*******\*;\****      **// How many values are in the set**

​    ***\*this\****.add.***\*apply\*******\*(\*******\*this\*******\*,\**** ***\*arguments\*******\*);\**** **// All arguments are values to add**

  ***\*}\****

 

  **// Now define instance methods on Set.prototype.**

  **// For brevity, code has been omitted here**

  Set.***\*prototype\****.***\*contains\**** ***\*=\**** ***\*function\*******\*(\*******\*value\*******\*)\**** ***\*{\****

​    **// Note that we call v2s(), not the heavily prefixed Set._v2s()**

​    ***\*return\**** ***\*this\****.values.hasOwnProperty***\*(\****v2s***\*(\*******\*value\*******\*));\****

  ***\*};\****

  Set.***\*prototype\****.size ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*return\**** ***\*this\****.n***\*;\**** ***\*};\****

  Set.***\*prototype\****.add ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** **/\* ... \*/** ***\*};\****

  Set.***\*prototype\****.remove ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** **/\* ... \*/** ***\*};\****

  Set.***\*prototype\****.foreach ***\*=\**** ***\*function\*******\*(\****f***\*,\**** context***\*)\**** ***\*{\**** **/\* ... \*/** ***\*};\****

 

  **// These are helper functions and variables used by the methods above**

  **// They're not part of the public API of the module, but they're hidden**

  **// within this function scope so we don't have to define them as a** 

  **// property of Set or prefix them with underscores.**

  ***\*function\**** v2s***\*(\****val***\*)\**** ***\*{\**** **/\* ... \*/** ***\*}\****

  ***\*function\**** objectId***\*(\****o***\*)\**** ***\*{\**** **/\* ... \*/** ***\*}\****

  ***\*var\**** nextId ***\*=\**** ***\*1\*******\*;\****

 

  **// The public API for this module is the Set() constructor function.**

  **// We need to export that function from this private namespace so that**

  **// it can be used on the outside.  In this case, we export the constructor**

  **// by returning it.  It becomes the value of the assignment expression**

  **// on the first line above.**

  ***\*return\**** Set***\*;\****

***\*}());\**** **// Invoke the function immediately after defining it.**

一且将模块代码封装进一个函数，就需要一些方法导出其公用API，以便在模块函数的外部调用它们。

**//创建一个全局变量用来存放集合相关的模块**

***\*var\**** collections***\*;\****

***\*if\**** ***\*(!\****collections***\*)\**** collections ***\*=\**** ***\*{};\**** 

**//定义sets模块**

collections.sets ***\*=\**** ***\*(\*******\*function\**** namespace***\*()\**** ***\*{\**** 

 **//在这里定义多种"集合"类，使用局部变量和函数**

 **//……这里省略很多代码……**

 **//通过返回命名空间对象将API导出**

 ***\*return\**** ***\*{\**** 

  **//导出的属性名: 局部变量名字**

  AbstractSet***\*:\**** AbstractSet***\*,\**** 

  NotSet***\*:\**** NotSet***\*,\**** 

  AbstractEnumerableSet***\*:\**** AbstractEnumerableSet***\*,\**** 

  SingletonSet***\*:\**** SingletonSet***\*,\**** 

  AbstractWritableSet***\*:\**** AbstractWritableSet***\*,\**** 

  ArraySet***\*:\**** ArraySet 

 ***\*};\****

***\*}());\****

另外一种类似的技术是将模块函数当做构造函数，通过new来调用，通过将它们赋值给this来将其导出

***\*var\**** collections***\*;\**** 

***\*if\**** ***\*(!\****collections***\*)\**** collections ***\*=\**** ***\*{};\**** 

collections.sets ***\*=\**** ***\*(new\**** ***\*function\**** namespace***\*()\**** ***\*{\**** 

 **//  ……这里省略很多代码…**

 **//将API导出至this对象**

 ***\*this\****.AbstractSet ***\*=\**** AbstractSet***\*;\**** 

 ***\*this\****.NotSet ***\*=\**** NotSet***\*;\**** **//……** 

 **//注意，这里没有返回值**

***\*}());\**** 

作为一种替代方案，如果已经定义了全局命名空间对象，这个模块函数可以直接设置那个对象的属性，不用返回任何内容:

***\*var\**** collections***\*;\**** 

***\*if\**** ***\*(!\****collections***\*)\**** collections ***\*=\**** ***\*{};\**** 

collections.sets ***\*=\**** ***\*{};\**** 

***\*(\*******\*function\**** namespace***\*()\**** ***\*{\**** 

 **//  ......这里省略很多代码……**

 **//将共用API导出到上面创建的命名空间对象上**

 collections.sets.AbstractSet ***\*=\**** AbstractSet***\*;\**** 

 collections.sets.NotSet ***\*=\**** NotSet***\*;\**** **//…** 

 **//导出的操作已经执行了，这里不需要再写return语句了**

***\*}());\**** 

 

***\*正则表达式的模式匹配\****

正则表达式 (regular expression) 是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式， String和RegExp都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。

### ***\*正则表达式的定义\****

正则表达式直接量定义为包含在一对斜杠(/)之间的字符：

***\*var\**** pattern ***\*=\**** ***\*/\****s$***\*/;\****

运行这段代码创建一个新的RegExp对象，并将它赋值给变量pattern。用构造函数RegExp()也可以定义一个与之等价的正则表达式，代码如下：

***\*var\**** pattern ***\*=\**** ***\*new\**** ***\*RegExp\*******\*(\******"s$"\******);\****

***\*直接量\*******\*字符\****

正则表达式中的所有字母和数字都是按照字面含义进行匹配的。JavaScript正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线()作为前缀进行转义。

***\*字符类\****

将直接量字符单独放进方括号内就组成了字符类(character class)。

***\*重复\****

示例：

/\d{2,4}/  //匹配2~4个数字

/\w{3}\d?/  //精确匹配三个单词和一个可选的数字

/\s+java\s+/ //匹配前后带有一个或多个空格的字符串"java"

/[^(]*/   //匹配一个或多个非左括号的字符

***\*非贪婪的重复\****

上例列出的匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为“贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只须在待匹配的字符后跟随一个问号即可。

比如，正则表达式/a+/可以匹配一个或多个连续的字母a。当使用"aaa"作为匹配字符串时，正则表达式会匹配它的三个字符。但是/a+?/也可以匹配一个或多个连续字母a，但它是尽可能少地匹配。我们同样将"aaa"作为匹配字符串，但后一个模式只能匹配第一个a。

***\*使用非贪婪的匹配模式所得到的结果可能和期望并不一致\****。考虑以下正则表达式/a+b/，它可以匹配一个或多个a，以及一个b。当使用"aaab"作为匹配字符串时，它会匹配整个字符串。现在再试一下非贪婪匹配的版本/a+?b/， 它匹配尽可能少的a和一个b。当用它来匹配"aaab"时，你期望它能匹配一个a和最后一个b。但实际上，这个模式却匹配了整个字符串，和i主模式的贪婪匹配一模一样。这是因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。

***\*选择、分组和引用\****

正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符。字符"|"用于分隔供选择的字符。例如，/ab|cd|ef/可以匹配字符串"ab"，也可以匹配字符串"cd"，还可以匹配字符串"ef"。/\d{3}|[a-z]{4}/匹配的是三位数字或者四个小写字母。

注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。因此，当正则表达式/a|ab/匹配字符串"ab"时，它只能匹配第一个字符。

正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用 "|"、"*"、"+"或者"?"等来对单元内的项进行处理。例如，/java(script)?/可以匹配字符串"java"，其后可以有 "script"也可以没有。/(ab|cd)+|ef/可以匹配字符串"ef"，也可以匹配字符串"ab"或"cd"的一次或多次重复。

在正则表达式中，圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分（匹配的子串）。例如，假定我们正在检索的模式是一个或多个小写字母后面跟随了一位或多位数字，则可以使用模式/[a-z]+\d+/。但假定我们真正关心的是每个匹配尾部的数字，那么如果将模式的数字部分放在括号中(/[a-z]+(\d+)/)，就可以从检索到的匹配中抽取数字了，之后我们会有详尽的解释。

带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。这是通过在字符""后加一位或多位数字来实现的。这个数字指定了带圆括号的子表达式在正则表达式中的位置。例如，\1引用的是第一个带圆括号的子表达式，\3引用的是第三个带圆括号的子表达式。注意，因为子表达式可以嵌套另一个子表达式，所以它的位置是参与计数的左括号的位置。例如，在下面的正则表达式中，嵌套的子表达式([Ss]cript)可以用\2来指代:

/([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/

***\*对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。\****这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。例如，下面的正则表达式匹配的就是位于单引号或双引号之内的0个或多个字符。但是，它并不要求左侧和右侧的引号匹配（即，加入的两个引号都是单引号或都是双引号）: 

/['"](#)*['"]/ 

如果要匹配左侧和右侧的引号，可以使用如下的引用:

/(['"])[^'"]*\1/ 

\1 匹配的是第一个带圆括号的子表达式所匹配的文本引用。在这个例子中，存在这样一条约束，那就是左侧的引号必须和右侧的引号相匹配。***\*正则表达式不允许用双引号括起的内容中有单引号，反之亦然。\****不能在字符类中使用这种引用，所以下面的写法是非法的:

/(['"])[^\1]*\1/

同样，在正则表达式中不用创建带数字编码的引用，也可以对子表达式进行分组。它不是以"("和")"进行分组，而是以"(?:"和")"来进行分组，比如，考虑下面这个模式:

/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/

这里，子表达式(?:[Ss]cript)仅仅用于分组，因此复制符号"?"可以应用到各个分组。这种改进的圆括号并不生成引用，所以在这个正则表达式中，\2引用了与(fun\W*)匹配的文本。

***\*正则表达式的选择、分组和引用字符\****

***\*指定匹配位置\****

有一些正则表达式的元素匹配的是字符之间的位置，而不是实际的字符。例如，***\*\b\****匹配一个单词的边界，即位于***\*\w\**** （ASCII单词）字符和\W（非ASCII单词）之间的边界，或位于一个ASCII单词与字符串的开始或结尾之间的边界。像\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为***\*正则表达式的锚\****，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是^，它用来匹配字符串的开始，锚元素$用以匹配字符串的结束。

可以使用正则表达式/\sJava\s/，匹配前后都有空格的单词"Java"。但是这样做有两个问题，第一，如果"Java"出现在字符串的开始或者结尾，就匹配不成功，除非开始和结尾处各有一个空格。第二个问题是，当找到了与之匹配的字符串时，它返回的匹配字符串的前端和后端都有空格，这并不是我们想要的。因此我们使用单词的边界\b来代替真正的空格符\s进行匹配（或定位）。这样正则表达式就写成了/\bJava\b/。元素\B将把匹配的锚点定位在不是单词的边界之处。因此，正则表达式/\B[Ss]cript/与"JavaScript"和"postscript"匹配，但不与"script"和"Scripting"匹配。

任意正则表达式都可以作为锚点条件。如果在符号"(?="和")"之间加入一个表达式，它就是一个先行断言，用以说明圆括号内的表达式必须正确匹配，但并不是真正意义上的匹配。"(?="和")"之间的表达式只用于指定一个位置，它是零宽的，这里提到的“断言”通常也称为“零宽断言”。比如，要匹配一种常用的程序设计语言的名字，但只在其后有冒号时才匹配，可以使用/[Jj]ava([Ss]cript)?(?=\:)/。这个正则表达式可以匹配"JavaScript:The Definitive Guide" 中的"JavaScript"，但是不能匹配"Java in a Nutshell"中的"Java"，因为它后面没有冒号。

带有"(?!"的断言是负向先行断言，用以指定接下来的字符都不必匹配。例如，/Java(?!Script)([A-Z]\w*)/可以匹配"Java"后跟随一个大写字母和任意多个ASCII单词，但Java后面不能跟随"Script"。它可以匹配"JavaBeans"，但不能匹配"Javanese"；它可以匹配"JavaScript"，但不能匹配"JavaScripter"。

***\*正则表达式申的锚字符\****

我们来看一个例子。有一个标签：<book>，我们想要得到标签<book>的标签名(book)，这个时候，我们就可以使用断言来处理。看下面这个表达式：(?<=<)(?<tag>\w*)(?=>)，使用这个表达式，可以匹配<和>之间的字符，也就是这里的book。使用断言还还可以写出更加复杂的表达式，这里就不再举例了。

还有一点非常重要，就是断言语法所使用的圆括号并不作为捕获组，所以不能使用编号或命名来对它进行引用。

***\*修饰符\****

正则表达式中的语法还有最后一个知识点，即正则表达式的修饰符，用以说明高级匹配模式的规则。和之前讨论的正则表达式语法不同，修饰符是放在"/"符号之外的，也就是说，它们不是出现在两条斜线之间，而是第二条斜线之后。JavaScript支持三个修饰符，修饰符"i"用以说明模式匹配是不区分大小写的。修饰符"g"说明模式匹配应该是全局的，也就是说，应该找出被检索字符串中所有的匹配。修饰符"m"用以在多行模式中执行匹配，在这种模式下，如果待检索的字符串包含多行，那么 ^ 和 $ 锚字符除了匹配整个字符串的开始和结尾之外，还能匹配每行的开始和结尾。比如正则表达式***\*/java$/im\****可以匹配 "java"也可以匹配"Java\nis fun"。

***\*正则表达式修饰符\****

### ***\*用于模式匹自己的String方法\****

String支持4种使用正则表达式的方法。最简单的是search()。它的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到匹配的子串，它将返回-1。

**"JavaScript"**.***\*search\*******\*(/\****script***\*/\****i***\*);\**** **// =>4**

如果search()的参数不是正则表达式，则首先会通过RegExp构造函数将它转换成正则表达式，search()方法不支持全局检索，因为它忽略正则表达式参数中的修饰符g。

replace()方法用以执行检索与替换操作。其中第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。这个方法会对调用它的字符串进行检索，使用指定的模式来匹配。如果正则表达式中设置了修饰符g，那么源字符串中所有与模式匹配的子串都将替换成第二个参数指定的字符串；如果不带修饰符g，则只替换所匹配的第一个子串。如果replace()的第一个参数是字符串而不是正则表达式，则replace()将直接搜索这个字符串，而不是像search()一样首先通过RegExp()将它转换为正则表达式。比如，可以使用下面的方法，利用replace()将文本中的所有javascript(不区分大小写)统一替换为"JavaScript":

**//将所有不区分大小写的javascript都替换成大小写正确的JavaScript**

***\*text\****.***\*replace\*******\*(/\****javascript***\*/\****gi***\*,\**** **"JavaScript"\******);\**** 

但replace()的功能远不止这些。回忆一下前文所提到的，正则表达式中使用圆括号括起来的子表达式是带有从左到右的索引编号的，而且正则表达式会记忆与每个子表达式匹配的文本。如果在替换字符串中出现了$加数字，那么replace()将用与指定的子表达式相匹配的文本来替换这两个字符。这是一个非常有用的特性。比如，可以用它将一个字符串中的英文引号替换为中文半角引号：

**//一段引用文本起始于引号，结束于引号**

**//中间的内容区域不能包含引号**

***\*var\**** quote ***\*=\**** ***\*/\******"([^"\******]\*)\******"/g;** 

**//用中文半角引号替换英文引号，同时要保持引号之间的内容(存储在$1中)没有被修改**

***\*text\****.***\*replace\*******\*(\****quote***\*,\**** **'“$1”'\******);\**** 

match()方法是最常用的String正则表达式方法。它的唯一参数就是一个正则表达式（或通过RegExp()构造函数将其转换为正则表达式），返回的是一个由匹配结果组成的数组。如果该正则表达式设置了修饰符g，则该方法返回的数组包含字符串中的所有匹配结果。例如：

**"1 plus 2 equals 3"**.***\*match\*******\*(/\****\d***\*+/\****g***\*)\**** **//返回["1", "2", "3"]** 

如果这个正则表达式没有设置修饰符g，match()就不会进行全局检索，它只检索第一个匹配。但即使match()执行的不是全局检索，它也返回一个数组。在这种情况下，数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果match()返回一个数组a，那么a[0]存放的是完整的匹配，a[1]存放的则是与第一个用圆括号括起来的表达式相匹配的子串，以此类推。为了和方法replace()保持一致，a[n]存放的是$n的内容。例如，使用如下的代码来解析一个URL：

***\*var\**** url ***\*=\**** ***\*/(\****\w***\*+):\********/\********/([\****\w.***\*]+)\********/(\****\S***\**)/;\**** 

***\*var\**** ***\*text\**** ***\*=\**** **"Visit my blog at http://www.example.com/~david"\******;\**** 

***\*var\**** result ***\*=\**** ***\*text\****.***\*match\*******\*(\****url***\*);\**** 

***\*if\**** ***\*(\****result ***\*!=\**** ***\*null\*******\*)\**** ***\*{\**** 

 ***\*var\**** fullurl ***\*=\**** result***\*[\****0***\*];\**** **//包含 "http://www.example.com/~david"**

 ***\*var\**** ***\*protocol\**** ***\*=\**** result***\*[\****1***\*];\**** **//包含 "http"**

 ***\*var\**** ***\*host\**** ***\*=\**** result***\*[\*******\*2\*******\*];\**** **//包含 "[www.example.com](www.example.com)"**

 ***\*var\**** ***\*path\**** ***\*=\**** result***\*[\*******\*3\*******\*];\**** **//包含 "~david"**

***\*}\****

值得注意的是，给字符串的match()方法传入一个非全局的正则表达式，实际上和给这个正则表达式的exec()方法传入的字符串是一模一样的，它返回的数组带有两个属性：index和input，接下来对exec()方法的讨论中会提到：

String对象的最后一个和正则表达式相关的方法是split()。这个方法用以将调用它的字符串拆分为一个子串组成的数组，使用的分隔符是split()的参数，例如：

**"123,456,789"**.***\*split\*******\*(\******","\******);\**** **//返回 ["123","456","789"]**

split()方法的参数也可以是一个正则表达式，这使得split()方法异常强大。例如，可以指定分隔符，允许两边可以留有任意多的空白符：

**"1, 2, 3, 4, 5"**.***\*split\*******\*(/\****\s***\**,\****\s***\**/);\**** **//返回 ["1","2","3","4","5"]**

### ***\*RegExp对象\****

RegExp()构造函数带有两个字符串参数，其中第二个参数是可选的，RegExp()用以创建新的RegExp对象。第一个参数包含正则表达式的主体部分，也就是正则表达式直接量中两条斜线之间的文本。需要注意的是，不论是字符串直接量还是正则表达式，都使用""字符作为转义字符的前缀，因此当给RegExp()传入一个字符串表述的正则表达式时，必须将""替换成"\"。RegExp()的第二个参数是可选的，如果提供第二个参数，它就指定正则表达式的修饰符。不过只能传入修饰符g、i、m或者它们的组合。比如:

//全局匹配字符串中的5个数字，注意这里使用了"\"，而不是""***\*var\**** zipcode ***\*=\**** ***\*new\**** RegExp***\*(\****"\d{5}"***\*,\**** "g"***\*);\****

RegExp()构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。其实通过eval()也可以实现运行时动态创建正则表达式，但不推荐使用eval()。

***\*RegExp的属性\****

每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读的布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读的布尔值，用以说明正则表达式是否带有修饰符i。属性multiline是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置，这个属性会被exec()和test()方法用到。

***\*RegExp的方法\****

RegExp最主要的执行模式匹配的方法是exec()。exec()方法对一个指定的字符串执行一个正则表达式，简言之，就是在一个字符串中执行匹配检索。如果它没有找到任何匹配，它就返回null，但如果它找到了一个匹配，它将返回一个数组，就像match()方法为非全局检索返回的数组一样。这个数组的第一个元素包含的是与正则表达式相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。属性index包含了发生匹配的字符位置，属性input引用的是正在检索的字符串。和match()方法不同，不管正则表达式是否具有全局修饰符g，exec()都会返回一样的数组。回忆一下，当match()的参数是一个全局正则表达式时，它返回由匹配结果组成的数组。相比之下，exec()总是返回一个匹配结果，并提供关于本次匹配的完整信息。当调用exec()的正则表达式对象具有修饰符g时，它将把当前正则表达式对象的lastIndex属性设置为紧挨着匹配子串的字符位置。当同一个正则表达式第二次调用exec()时，它将从lastIndex属性所指示的字符处开始检索。如果exec()没有发现任何匹配结果，它会将lastIndex重置为0（在任何时候都可以将lastIndex属性设置为0，每当在字符串中找最后一个匹配项后，在使用这个RegExp对象开始新的字符串查找之前，都应当将lastIndex设置为0）。这种特殊的行为使我们可以在用正则表达式匹配字符串的过程中反复调用exec()，比如：

***\*var\**** pattern ***\*=\**** ***\*/Java/g\*******\*;\**** ***\*var\**** ***\*text\**** ***\*=\**** "JavaScript is more fun than Java!"***\*;\**** ***\*var\**** result***\*;\**** ***\*while\*******\*((\****result ***\*=\**** pattern***\*.\****exec***\*(\*******\*text\*******\*))\**** ***\*!=\**** ***\*null\*******\*)\**** ***\*{\**** ***\*alert\*******\*(\****"Matched '" ***\*+\**** result***\*[\****0***\*]\**** ***\*+\**** "'" ***\*+\**** 		" at position " ***\*+\**** result***\*.\****index ***\*+\**** 		"; next search begins at " ***\*+\**** pattern***\*.\****lastIndex***\*);\*******\*}\****			

另外一个RegExp方法是test()，它比exec()更简单一些。它的参数是一个字符串，用test()对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回true：

***\*var\**** pattern ***\*=\**** ***\*/java/i\*******\*;\**** pattern***\*.\****test***\*(\****"JavaScript"***\*);\**** //返回true

调用test()和调用exec()等价，当exec()的返回结果不是null时，test()返回true。由于这种等价性，当一个全局正则表达式调用方法test()时，它的行为和exec()相同，因为它从lastIndex指定的位置处开始检索某个字符串，如果它找到了一个匹配结果，那么它就立即设置lastIndex为当前匹配子串的结束位置。这样一来，就可以使用test()来遍历字符串，就像用exec()方法一样。

与exec()和test()不同，String方法search()、replace()和match()并不会用到lastIndex属性。实际上， String方法只是简单地将lastIndex属性值重置为0。如果让一个带有修饰符g的正则表达式对多个字符串执行exec()或test()，要么在每个字符串中找出所有的匹配以便将lastIndex自动重置为零，要么显式将lastIndex手动设置为0（当最后一次检索失败时需要手动设置lastIndex）。如果忘了手动设置lastIndex的值，那么下一次对新字符串进行检索时，执行检索的起始位置可能就不是字符串的开始位置，而可能是任意位置。当然，如果RegExp不带有修饰符g，则不必担心会发生这种情况。同样要记住，在ECMAScript 5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新RegExp对象具有各自的lastIndex属性，这势必会大大减少“残留”lastIndex对程序造成的意外影响。

 

***\*JavaScript的子集\*******\*和扩展\****

http://en.wikipedia.org/wiki/SpiderMonkey

 

***\*服务器端JavaScript\****

可以说JavaScript是基于Web的编程语言，因为绝大部分JavaScript代码是为Web浏览器而编写。但是作为一门高效和通用的语言，JavaScript理所当然能用于其他编程工作。所以在过渡到服务端JavaScript之前，我们先快速了解一下另外两种JavaScript嵌入。

Rhino是基于Java的JavaScript解析器，实现了通过JavaScript程序访问整个Java API。

Node是Google的V8 JavaScript解析器的一个特别版本，它在底层绑定了POSIX(Unix)API，包括文件、进程、流和套接字等，并侧重于异步I/O、网络和HTTP。

 

 

 

 

***\*第二\*******\*部分\**** ***\*客户端Javascript\****

VBScript续行符"_"

JavaScript续行符”\”

DOM就是HTML页面的模型，将每个标签都做为一个对象，JS通过调用DOM中的属性和方法就可以对网页中的文本框、层等元素进行编程控制。

DOM也通过事件、属性、方法进行编程。

CSS + Javascript + DOM = DHTML

***\*Web浏览器中的JavaScript\****

http://www.w3school.com.cn/js/index.asp

 

### ***\*客户端JavaScript\****

 

### ***\*在HTML里嵌入JavaScript\****

在 HTML文档里嵌入客户端JavaScript代码有4种方法：

l 内联，放置在<script>和</script>标签对之间。

l 放置在由<script>标签的src属性指定的外部文件中。

l 放置在HTML事件处理程序中，该事件处理程序由onclick或onmouseover这样的HTML属性值指定。

l 放在一个URL里，这个URL使用特殊的 "javascript:" 协议。

有个编程哲学叫 "unobtrusive JavaScript" ，主张内容 (HTML) 和行为 (JavaScript代码)应该尽量地保持分离。根据这个编程哲学，JavaScript最好通过<script>元素的src属性来嵌入HTML文档里。

<script>元素

在XHTML中，<script>标签中的内容被当做其他内容一样对待。如果JavaScript代码包含了"<"或"&"字符，那么这些字符就被解释成为XML标记。因此，如果要使用XHTML，最好把所有的JavaScript代码放入到一个CDATA部分里：

<script><![CDATA[ 

**//这里是你的JavaScript代码**

***\*]]></\****script> 

<script src="../../scripts/util.js"></script> 

***\*外部\*******\*文件中的脚本\****

***\*注意，即使指定了src属性并且<script>和</script>标签之间没有JavaScript代码，结束的</script>标签也是不能丢的。\****在XHTML中，在此处可以使用简短的<script/>标签。

***\*使用src属性时，<script>和</script>标签之间的任何内容都会忽略。\****如果需要，可以在<script>标签之间添加代码的补充说明文档或版权信息。但是要注意，如果有任何不是空格或JavaScript注释的文本出现在<script src="">和</script>之间，HTML5校验器将会报错。

有时我们会看到诸如这种代码：

<script src="core.js"> 

 config ***\*=\**** ***\*{\****...***\*};\****

***\*</\****script>

看起来这段代码定义了一些配置项，由core.js来读取，这是一种将页面参数传入库文件的方法，在JavaScript库的开发中非常常见，其中<script>和</script>之间的代码是一段纯文本，在core.js执行时读取这段文本然后动态执行一次，浏览器不会自动执行<script>标签之间的代码。

***\*脚本\*******\*类型\****

JavaScript是Web的原始脚本语言，而在默认情况下，假定<script>元素包含或引用JavaScript代码。如果要使用不标准的脚本语言，如Microsoft的VBScript (只有IE支持)，就必须用type属性指定脚本的MIME类型。

type属性的默认值是"text/javascript" 。如果需要，可以显式指定此类型，但这完全没必要。

老的浏览器在<script>标记上用language属性代替type属性，这种情况现在也会经常看到，但是language属性已经废弃，不应该再使用了。

当Web浏览器遇到<script>元素，并且这个<script>元素包含其值不被浏览器识别的type属性时，它会解析这个元素但不会尝试显示或执行它的内容。这意味着可以使用<script>元素来嵌入任意的文本数据到文档里，只要用type属性为数据声明一个不可执行的类型。要获取数据，可以用表示script元素的HTMLElement对象的text属性。但是，要注意这些数据嵌入技术只对内联脚本生效。

如果同时指定src属性和一个未知的类型，那这个脚本会被忽略，并且不会从指定的URL里下载任何内容。

***\*HTML\*******\*中的事件处\*******\*理程\*******\*序\****

当脚本所在的HTML文件被载入浏览器时，这个脚本里的JavaScript代码只会执行一次。为了可交互，JavaScript程序必须定义事件处理程序——Web浏览器先注册JavaScript 函数，并在之后调用它作为事件的响应(比如用户输入)。实际上，很多Web开发者认为使用HTML事件处理程序的属性是不好的习惯，他们更喜欢保持内容和行为的分离。

***\*URL\*******\*中的JavaScript\****

在URL后面跟一个javascript: 协议限定符，是另一种嵌入JavaScript代码到客户端的方式。这种特殊的协议类型指定URL内容为任意字符串，这个字符串是会被JavaScript解释器运行的JavaScript代码。它被当做单独的一行代码对待，这意味着语句之间必须用分号隔开，而注释//必须用/* */注释代替。javascript: URL能识别的“资源”是转换成字符串的执行代码的返回值。如果代码返回undefined ，那么这个资源是没有内容的。超链接里的JavaScript URL可以是这样：

<a href="javascript:new Date().toLocaleTimeString();"> 

 What time is it? 

***\*</a>\**** 

部分浏览器(比如Firefox) 会执行URL里的代码，并使用返回的字符串作为待显示新文档的内容（所以很多时候，会使用void操作符强制函数调用或给表达式赋予undefined值）。就像单击一个http:URL链接，浏览器会擦除当前文档并显示新文挡。以上代码的返回值并不包含任何HTML标签，但是如果有，浏览器会像渲染通常载入的等价HTML文档一样渲染它们。其他浏览器(比如Chrome和Safari)不允许URL像上面一样覆盖当前文档，它们会忽略代码的返回值。

JavaScript URL是Web早期的遗物，通常应该避免在现代HTML里使用。但javascript: URL在HTML文档之外确实有着重要的角色。如果要测试一小段JavaScript代码，那么可以在浏览器地址栏里直接输入javascript: URL。下面介绍javascript: URL 另一个正统(且强大的)的用法：浏览器书签。

在Web浏览器中，“书签”就是一个保存起来的URL。如果书签是javascript:URL，那么保存的就是一小段脚本，叫做bookmarklet。bookmarklet是一个小型程序，很容易就可以从浏览器的菜单或工具栏里启动。bookmarklet里的代码执行起来就像页面上的脚本一样，可以查询和设置文档的内容、呈现和行为。只要书签不返回值，它就可以操作当前显示的任何文档，而不把文档替换成新的内容。

下面<a>标签里的javascript: URL。单击链接会打开一个简单的JavaScript表达式计算器，它允许在页面环境中计算表达式和执行语句：

<a href='javascript:

 var e ***\*=\**** "" , r ***\*=\**** ""***\*;\**** /* 需要计算的表达式和结果 */

 do { 

  /* 输出表达式和结果，并要求输入新的表达式 */

  e ***\*=\**** prompt("Expression: " + e + "\n" + r + "\n", e)***\*;\**** 

  try { r ***\*=\**** "Result: " + eval(e)***\*;\**** } /*尝试计算这个表达式*/

  catch(ex) { r ***\*=\**** ex***\*;\**** }  /*否则记住这个错误*/

 } while(e)***\*;\**** /*直到没有输入表达式或者单击了Cancel按钮才会停止，否则一直循环执行*/

 void 0***\*;\**** /*这句代码用以防止当前文档被覆盖*/

'***\*>\****

JavaScript Evaluator 

***\*</a>\**** 

***\*注意\****，即便这个JavaScript URL是写成多行的，HTML解析器仍将它作为单独的一行对待，并且其中的单行//注释也是无效的。还有，要记住代码是单引号中的HTML属性的一部分，所以代码不可以包含任何单引号。

在开发时，把这样的链接硬编码在页面中是有用的；而把它另存为可以在任何页面上运行的书签，就更有用了。通常，在浏览器里把超链接的地址加入书签可以这样做，在链接上右击并选择类似"Bookmark Link"的选项，或者拖动链接到书签工具栏。

### ***\*JavaScript程序的执行\****

JavaScript程序的执行有两个阶段。

在第一阶段，载入文档内容，并执行<script>元素里的代码（包括内联脚本和外部脚本）。脚本通常会按它们在文档里的出现顺序执行。所有脚本里的JavaScript代码都是从上往下，按照它在条件、循环以及其他控制语句中的出现顺序执行。

当文档载入完成，并且所有脚本执行完成后，JavaScript执行就进入它的第二阶段。这个阶段是异步的，而且由事件驱动。在事件驱动阶段，Web浏览器调用事件处理程序函数（由第一阶段里执行的脚本指定的HTML事件处理程序，或之前调用的事件处理程序来定义），来响应异步发生的事件。调用事件处理程序通常是响应用户输入（如鼠标单击，键盘按下等）。但是，还可以由网络活动、运行时间或者JavaScript代码中的错误来触发。注意，嵌入在Web页面里的javascript: URL也可以被当做是一种事件处理程序，因为直到用户通过单击链接或提交表单来激活之后它们才会有效果。

事件驱动阶段里发生的第一个事件是load事件，指示文档已经完全载入，并可以操作。在文档载入完成之后，只要Web浏览器显示文档，事件驱动阶段就会一直持续下去。因为这个阶段是异步的和事件驱动的，所以可能有长时间处于不活动状态，没有JavaScript被执行，被用户或网络事件触发的活动打断。核心JavaScript和客户端JavaScript都有一个单线程执行模型。脚本和事件处理程序（无论如何）在同一个时间只能执行一个，没有并发性。这保持了JavaScript编程的简单性。

***\*同步、异步和延迟的脚本\****

JavaScript第一次添加到Web浏览器时，还没有API可以用来遍历和操作文挡的结构和内容。当文档还在载入时， JavaScript影响文档内容的唯一方法是快速生成内容。它使用document.write()方法完成上述任务。

当HTML解析器遇到<script>元素时，它默认必须先执行脚本，然后再恢复文档的解析和渲染。这对于内联脚本没什么问题，但如果脚本源代码是一个由src属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之前，都不会出现在浏览器中。所谓“不会出现在浏览器中”是指文档的文本内容已经载入，但是并未被浏览器引擎解析为DOM树，而DOM树的生成是受JavaScript代码执行的影响的，JavaScript代码会“阻塞”页面UI的渲染。

脚本的执行只在默认情况下是同步和阻塞的。<script>标签可以有defer和async属性，这（在支持它们的浏览器里）可以改变脚本的执行方式。HTML5说这些属性只在和src属性联合使用时才有效，但有些浏览器还支持延迟的内联脚本：

<script defer src="deferred.js"></script> 

<script async src="async.js"></script> 

defer属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。

async属性使得浏览器可以尽快地执行脚本，而不用在下载脚本时阻塞文档解析。

如果<script>标签同时有两个属性，同时支持两者的浏览器会遵从async属性并忽略defer属性。

注意，延迟的脚本会按它们在文档里的出现顺序执行。而异步脚本在它们载入后执行，这意味着它们可能会无序执行。

甚至可以在不支持async属性的浏览器里，通过动态创建<script>元素并把它插入到文档中，来实现脚本的异步载入和执行，如下例：

**// Asynchronously load and execute a script from a specified URL**

***\*function\**** loadasync***\*(\****url***\*)\**** ***\*{\**** 

  ***\*var\**** head ***\*=\**** ***\*document\****.getElementsByTagName***\*(\******"head"\******)[\*******\*0\*******\*];\**** **// Find document <head>**

  ***\*var\**** s ***\*=\**** ***\*document\****.createElement***\*(\******"script"\******);\**** **// Create a <script> element**

  s.***\*src\**** ***\*=\**** url***\*;\****                **// Set its src attribute** 

  head.appendChild***\*(\****s***\*);\****            **// Insert the <script> into head**

***\*}\****

注意这个loadasync()函数会动态地载入脚本一一脚本载入到文档中，成为正在执行的JavaScript程序的一部分，既不是通过Web页面内联包含，也不是来自 Web页面的静态引用。

***\*事件驱动的JavaScript\****

当我们谈论事件的时候，必须同时指定事件类型（名字）和目标：比如，一个单击事件发生在HTMLButtonElement对象上，或者一个readystatechange事件发生在XMLHttpRequest对象上。如果想要程序响应一个事件，写一个函数，叫做“事件处理程序”，“事件监听器”或“回调”。然后注册这个函数，这样他就会在事件发生时调用它。

​	对于大部分浏览器中的大部分事件来说，会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给单击事件的对象，会有一个属性说明鼠标的哪个按钮被单击。（在IE里，这些事件信息被存储在全局event对象里，而不是传递给处理程序函数）。事件处理程序的返回值有时用来指示函数是否充分处理了事件，以及阻止浏览器执行它默认会进行的各种操作。

有些事件的目标是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”。例如，如果用户在<button>元素上单击鼠标，单击事件就会在按钮上触发。如果注册在按钮上的函数没有处理（并且冒泡停止）该事件，事件会冒泡到按钮嵌套的容器元素，这样，任何注册在容器元素上的单击事件都会调用。

大部分可以成为事件目标的对象都有一个叫做addEventListaner()的方法，允许注册多个监听器。

***\*window\****. addEventListener***\*(\******"load"\******,\**** ***\*function\*******\*()\**** ***\*{\****...***\*},\**** ***\*false\*******\*);\**** 

request.addEventListener***\*(\******"readystatechange"\******,\**** ***\*function\*******\*()\**** ***\*{\****...***\*},\**** ***\*false\*******\*);\**** 

在IE8以及之前的浏览器中，必须使用一个相似的方法，叫做attachEvent():

***\*window\****.attachEvent***\*(\******"onload"\******,\**** ***\*function\*******\*(){\****...***\*});\**** 

客户端JavaScript程序还使用异步通知类型，这些类型往往不是事件。如果设置Window对象的onerror属性为一个函数，会在发生JavaScript错误（或其他未捕获的异常）时调用函数。还有，setTi meout() 和setInterval() 函数（这些是Window对象的方法，因此是客户端JavaScript的全局函数）会在指定的一段时间之后触发指定函数的调用。传递给setTimeout() 的函数和真实事件处理程序的注册不同，它们通常叫做“回调逻辑”而不是“处理程序”，但它们和事件处理程序一样，也是异步的。

示例：onLoad()，当文档载入完成时调用一个函数

**// Register the function f to run when the document finishes loading.**

**// If the document has already loaded, run it asynchronously ASAP.**

***\*function\**** onLoad***\*(\****f***\*)\**** ***\*{\****

  ***\*if\**** ***\*(\****onLoad.loaded***\*)\****         **// If document is already loaded**

​    ***\*window\****.***\*setTimeout\*******\*(\****f***\*,\**** ***\*0\*******\*);\****    **// Queue f to be run as soon as possible**

  ***\*else\**** ***\*if\**** ***\*(\*******\*window\****.addEventListener***\*)\****  **// Standard event registration method**

​    ***\*window\****.addEventListener***\*(\******"load"\******,\**** f***\*,\**** ***\*false\*******\*);\****

  ***\*else\**** ***\*if\**** ***\*(\*******\*window\****.attachEvent***\*)\****    **// IE8 and earlier use this instead**

​    ***\*window\****.attachEvent***\*(\******"onload"\******,\**** f***\*);\****

***\*}\****

**// Start by setting a flag that indicates that the document is not loaded yet.**

onLoad.loaded ***\*=\**** ***\*false\*******\*;\****

**// And register a function to set the flag when the document does load.**

onLoad***\*(\*******\*function\*******\*()\**** ***\*{\**** onLoad.loaded ***\*=\**** ***\*true\*******\*;\**** ***\*});\****

***\*客户端JavaScript线程模型\****

JavaScript语言核心并不包含任何线程机制，并且客户端JavaScript传统上也没有定义任何线程机制。HTML5 定义了一种作为后台线程的"WebWorker" ，但是客户端JavaScript还像严格的单线程一样工作。甚至当可能并发执行的时候，客户端JavaScript也不会知晓是否真的有并行逻辑的执行。

单线程执行是为了让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻运行，操作文档内容时也不必担心会有其他线程试图同时修改文档，并且永远不需要在写JavaScript代码的时候担心锁、死锁和竟态条件(race condition) 。

单线程执行意味着浏览器必须在脚本和事件处理程序执行的时候停止响应用户输入。这为JavaScript程序员带来了负担，它意味着JavaScript脚本和事件处理程序不能运行太长时间。如果一个脚本执行计算密集的任务，它将会给文档载入带来延迟，而用户无法在脚本完成前看到文档内容。如果事件处理程序执行计算密集的任务，浏览器可能变得无法响应，可能会导致用户认为浏览器奔溃了。

如果应用程序不得不执行太多的计算而导致明显的延迟，应该允许文档在执行这个计算之前完全载入，并确保能够告知用户计算正在进行并且浏览器没有挂起。如果可能将计算分解为离散的子任务，可以使用setTimeout()和setInterval()方法在后台运行子任务，同时更新一个进度指示器向用户显示反馈。

HTML5定义了一种并发的控制方式，叫做"Web worker"。Web worker是一个用来执行计算密集任务而不冻结用户界面的后台线程。运行在Web worker线程里的代码不能访问文档内容，不能和主线程或其他worker共享状态，只可以和主线程和其他worker通过异步事件进行通信，所以主线程不能检测并发性，并且Web worker不能修改JavaScript程序的基础单线程执行模型。

***\*客户端JavaScript时间线\****

\1. Web浏览器创建Document对象，并且开始解析Web页面，解析HTML元素和它们的文本内容后添加Element对象和Text节点到文档中。在这个阶段document.readystate属性的值是"loading" 。

\2. 当HTML解析器遇到没有async和defer属性的<script>元素时，它把这些元素添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载（如果需要）和执行时解析器会暂停。这样脚本就可以用document.write()来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的<script>元素和它们之前的文档内容。

\3. 当解析器遇到设置了async属性的<script>元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用document.write()方法。它们可以看到自己的<script>元素和它之前的所有文档元素，并且可能或干脆不能访问其他的文档内容。

\4. 当文档完成解析，document.readyState属性变成"interactive"。

\5. 所有有defer属性的脚本，会按它们在文档的里的出现顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用document.write()方法。

\6. 浏览器在Document对象上触发DOMContentLoaded事件。这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。

\7. 这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，如图片。当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，document.readyState属性改变为"complete"，Web浏览器触发Window对象上的load事件。

\8. 从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等。

这是一条理想的时间线，但是所有浏览器都没有支持它的全部细节。所有浏览器普遍都支持load事件，都会触发它，它是决定文档完全载入并可以操作最通用的技术。DOMContentLoaded事件在load事件之前触发，当前所有浏览器都支持这个事件，除了IE之外，document.readyState属性在写本书时已被大部分浏览器实现，但是属性的值在浏览器之间有细微的差别。defer属性被所有当前版本的IE支持，但是现在还未被其他浏览器实现。async属性的支持在写本书时还不通用。

### ***\*兼容性和互用性\****

​	浏览器信息：

https://developer.mozilla.org   Mozilla开发者中心

http://msdn.microsoft.com      Microsoft开发者网络

http://developer.apple.com/safari Apple开发者网络里的Safari开发者中心

http://code.google.com/doctype   Google把Doctype项目介绍为“开放Web的一本百科全书”。这个用户可以编辑的站点包含客户端JavaScript的各种兼容性表格。在写本书的时候，这些表格只报告了每个浏览器里是否存在各种属性和方法，而事实上没有说它们是否工作正常。

http://en.wikipedia.org/wiki/Comparison_of_layout_engines_(HTML_5) 

Wikipedia文章跟踪了HTML5特性和API在各个浏览器里的实现状态。

http://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Document_Object_Model) 

一篇简单的文章，跟踪DOM特性的实现状态。

http://a.deveria.com/caniuse 

这个“何时可用……”站点跟踪重要Web特性的实现状态，允许根据各种标准进行过滤，并在某个特性只剩下少量已部署的浏览器不支持时推荐使用。

http://www.quirksmode.org/dom

根据W3C标准列出的各种浏览器的DOM兼容性表格。

http://webdevout.net/browser-support 

另一个跟踪浏览器开发商对于Web标准的实现的站点。

***\*处理兼容性问题的类库\****

处理不兼容问题其中一种最简单的方法是使用类库。

IE是唯一不支持<canvas>特性的当前浏览器，它支持一种晦涩的客户端图形语言，叫做VML。开源的"explorer canvas"项目在http://code.google.com/p/explorercanvas上发布了一个类库，引入一个excanvas.js，然后IE就会看起来像它支持<canvas>元素一样。

在实际的开发工作中，今天不少Web开发者在它们所有的Web页面上用了客户端JavaScript框架，比如jQuery。使这些框架必不可少的一个重要功能是：它们定义了新的客户端API并兼容所有浏览器。

分级浏览器 (graded browser support) 是由Yahoo!率先提出的一种测试技术。从某种维度对浏览器厂商/版本/操作系统变体进行分级。分级浏览器中的A级要通过所有的功能测试用例。对于C级浏览器来说则不必所有用例都通过测试。 A级浏览器需要网页完全可用， C级浏览器只需在HTML完整情况下可用即可，而不需要JavaScript和CSS都正常工作。那些不是A级和C级的浏览器都称做X级浏览器。

你可以在http://developer.yahoo.com/yui/articles/gbs阅读更多关于Yahoo!的分级浏览器支持情况。

功能测试 (capability testing)是解决不兼容性问题的一种强大技术。如果你想试用某个功能，但又不清楚这个功能是否在所有的浏览器中都有比较好的兼容性，则需要在脚本中添加相应的代码来检测是否在浏览器中支持该功能。

***\*怪异模式和标准模式\****

渲染模式的选择依赖于HTML文件顶部的DOCTYPE声明，在IE6 中打开没有DOCTYPE的页面和声明了某些权限Doctype的页面都会按照怪异模式进行渲染，定义了严格的Doctype的页面（或者为了做到前向兼容性而添加了未知的Doctype的页面）会按照标准模式进行渲染，定义了HTML5 Doctype (<! DOCTYPE  html>)的页面在所有现代浏览器中都会按照标准模式渲染。

怪异模式和标准模式之间的差异对于HTML和CSS开发者影响最大。但客户端JavaScript代码则是需要知道文档以哪种模式进行渲染的。要进行这种渲染模式的特性检测，通常检查document.compatMode属性。如果其值为 "CSS1Compat" ，则说明浏览器工作在标准模式；如果值为 "BackCompat" （或undefined，说明属性根本不存在），则说明浏览器工作在怪异模式。所有现代浏览器都实现了compatMode属性，并且HTML5规范对它进行了标准化。

***\*浏览器测试\****

在客户端JavaScript中检测浏览器类型和版本的方住就是使用Navigator对象。确定当前浏览器的厂商和版本的代码通常叫做浏览器嗅探器(browser sniffer)或者客户端嗅探器(client sniffer)。需要注意的是，客户端嗅探也可以在服务器端完成，Web服务器根据User-Agent头部可以有选择地返回特定的JavaScript代码给客户端。

***\*IE里\*******\*的条件注释\****

IE支持条件注释（由IE5引入），尽管这种做法并不符合标准规范，但是在处理不兼容性时非常有用。示例：

***\*<!--[\*******\*if\**** IE***\*]>\****<script ***\*src\*******\*=\******"excanvas.js"\******></\****script>***\*<![\****endif***\*]-->\****

 

<!--[if IE 6]>

This content is actually inside an HTML comment

It will only be displayed in IE 6.

<![endif]-->

 

<!--[if lte IE 7]>

This content will only be displayed by IE 5, 6 and 7 and earlier.

lte stands for "less than or equal". You can also use "lt", "gt" and "gte".

<![endif]-->

 

<!--[if !IE]>

This is normal HTML content, but IE will not display it

because of the comment above and the comment below

<![endif]-->

IE的JavaScript解释器也支持条件注释，以文本/*@cc_on开头，以文本@*/结束 (cc_on stands中的cc表示条件编译)。

**/\*@cc_on** 

 **@if (@_jscript)** 

 **//这里的代码在一条条件注释中，也在一条常规的JavaScript注释中**

 **//IE会执行这段代码，其他浏览器不执行它**

 **alert('You are using Internet Explorer);**

 **@else\*/** 

 **//这段代码并没在JavaScript注释中，但仍然在IE条件注释中**

 **//也就是说除了IE之外的所有浏览器都执行这里的代码**

 ***\*alert\*******\*(\******'You are not using Internet Explorer'\******);\**** 

 **/\*@end** 

**@\*/** 

### ***\*可访问性\****

JavaScript可访问性的一条重要原则是，设计的代码即使在禁用JavaScript解释器的浏览器中也能正常使用（或至少以某种形式正常使用）。

​	另一个重要的问题是：应该尽可能地支持独立于设备的事件。

​	关心可访问性的Web应用开发者应该阅读这里的文档：http://www.w3.org/WAI/intro/aria的WAI-ARIA (Web Accessibility Initiative-Accessible Rich Internet Applications)标准。

### ***\*安全性\****

***\*JS\*******\*不能做\*******\*什么\****

Web浏览器针对恶意代码的第一条防线就是它们不支持某些功能，例如，客户端JavaScript没有权限来写入或删除客户计算机上的任意文件或列出任意目录。

客户端JavaScript没有任何通用的网络能力。客户端JavaScript程序可以对HTTP协议编程；并且HTML5有一个附属标准叫WebSockets ，定义了一个类套接字的API，用于和指定的服务器通信。但是，这些API都不允许对于范围更广的网络进行直接访问。通用的Internet客户端和服务器不能同时使用客户端JavaScript来写（我们不能基于浏览器写出一个“服务器”，网络中的浏览器和浏览器之间无法直接进行通信）。

***\*同源策略\****

同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面使用多个<iframe>元素或者打开其他浏览器窗口的时候，这一策略通常就会发挥作用。在这种情况下，同源策略负责管理窗口或窗体中的JavaScript代码以及和其他窗口或帧的交互。具体来说，脚本只能读取和所属文档来源相同的窗口和文档的属性。

同源策略给那些使用多个子域的大站点带来了一些问题。为了支持这种类型的多域名站点，可以使用Document对象的domain属性。在默认情况下，属性domain存放的是载入文档的服务器的主机名。可以设置这一属性，不过使用的字符串必须具有有效的域前缀或它本身。因此，如果一个domain属性的初始值是字符串"home.example.com"，就可以把它设置为字符串"example.com"，但是不能设置为"home.example"或"ample.com"。另外，domain值中必须有一个点号，不能把它设置为"com" 或其他顶级域名。如果两个窗口（或窗体）包含的脚本把domain设置成了相同的值，那么这两个窗口就不再受同源策略的约束，它们可以相互读取对方的属性。

不严格的同源策略的第二项技术已经标准化为：跨域资源共享(Cross-Origin Resource Sharing，参见http://www.w3.org/TR/cors/)。这个标准草案用新的"Origin:"请求头和新的Access-Control-Allow-Origin响应头来扩展HTTP。它允许服务器用头信息显式地列出源，或使用通配符来匹配所有的源并允许由任何地址请求文件。类似Firefox 3.5和Safari 4的浏览器可以使用这种新的头信息来允许跨域HTTP请求，这样XMLHttpRequest就不会被同源策略所限制了。

另一种新技术，叫做跨文档消息(cross-document messaging)，允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用Window对象上的postMessage()方法，可以异步传递消息事件（可以用onmessage事件处理程序函数来处理它）到窗口的文档里。一个文档里的脚本还是不能调用在其他文档里的方法和读取属性，但它们可以用这种消息传递技术来实现安全的通信。

***\*脚本化\*******\*插件和\*******\*ActiveX控件\****

尽管核心JavaScript语言和基本的客户端对象模型缺乏大多数恶意代码所需要的文件系统功能和网络功能，但情况并不像看上去那么简单。在很多Web浏览器中，JavaScript亦被用做很多软件或插件的“脚本引擎”，这样的组件有IE中的ActiveX控件和其他浏览器的插件。Flash和Java插件是最常安装的例子，它们为客户端脚本提供了非常重要且强大的特性。

***\*跨站脚本\****

跨站脚本 (Cross-site scripting)，或者叫做XSS，这个术语用来表示一类安全问题，也就是攻击者向目标Web站点注入HTML标签或者脚本。防止XSS攻击是服务器端Web开发者的一项基本工作。然而，客户端JavaScript程序员也必须意识到或者能够预防跨站脚本。

如果Web页面动态地产生文档内容，并且这些文档内容是基于用户提交的数据的，而并没有通过从中移除任何嵌入的HTML标签来“消毒”的话，那么这个Web页面很容易遭到跨站脚本攻击。示例：

<script>

***\*var\**** name = decodeURIComponent(window.location.search.substring(1)) || "";

document.write("Hello" + name); 

</script>

这个页面通过 http://www.example.com/greet.html?David调用，但是，当用以下url调用时，会发生什么？

[http://www.example.com/greet.html?%3Cscript](http://www.example.com/greet.html? src=siteB/evil.js%3E%3C/script%3E

之所以叫做跨站脚本攻击，就是因为它涉及多个站点。站点B（或者站点C）包含一个专门构造的到站点A 的链接（就像上面的那个），它会注入一个来自站点B的脚本。脚本eval.js驻留在恶意站点B中，但现在，它嵌入到站点A中，并且可以对站点A的内容进行任何想要的操作。它可能损坏这个页面或者使其不能正常工作。

通常，防止XSS攻击的方式是，在使用任何不可信的数据来动态的创建文档内容之前，从中移除HTML标签。

name = name.replace(/</g, "<").replace(/>/g, ">");

上面的简单代码替换把字符串中所有的尖括号替换成它们对应的HTML实体，也就是说将字符串中任意HTML标签进行转义和过滤删除(deactivate)处理。IE8定义了一个更加微妙的toStaticHTML()方法，可以移除<script>标签（和其他潜在的可执行内容）而不修改不可执行的HTML。toStaticHTML()是不标准的，但在JavaScript核心代码中自己实现一个HTML安全函数也非常简单。

HTML5的内容安全策略则更进一步，它为<iframe>元素定义了一个sandbox属性。在实现之后，它允许显示不可信的内容，并自动禁用脚本。

有很多在线资源可以帮助你预防跨站脚本带来的危险。其中一个最重要的参考资料出自原始CERT Advisory:  http://www.cert.org/advisories/CA-2000-02.html。

***\*拒绝\*******\*服\*******\*务\*******\*攻\*******\*击\****

这种攻击手法非常暴力。如果访问了启用JavaScript功能的一个恶意Web站点，这个站点可以使用一个alert()对话框的无限循环占用浏览器，或者用一个无限循环或没有意义的计算来占用CPU。

某些浏览器可以检测运行时间很长的脚本，并且让用户选择终止它们。但是恶意脚本可以使用window.setInterval()这样的方法来占用CPU，并通过分配很多的内存来攻击你的系统。Web浏览器并没有通用的办法来防止这种笨重的攻击手法。实际上，由于没有人会返回一个滥用这种脚本的网站，因此这在Web上不是一个常见的问题。

### ***\*客户端框架\****

l jQuery

l Prototype：针对DOM和Ajax实现的一套实用工具。Scriptaculous类库基于l	Prototype实现，用来做动画和各种视觉特效。

l Dojo：大型框架，包含一个种类繁多的UI组件集合、包管理系统、数据抽象层等

l YUI：Yahoo!使用的一个著名的大型框架，包括语言工具、UI组件等。

l Closure：Google的类库，打算和Closure编译器配合使用，剔除没用的类库函数，包含一个庞大的使用工具集。

l GWT：Google Web Toolkit，是一个完全不同类型的客户端框架。它用JAVA定义了Web应用接口，并提供编译器，将JAVA程序翻译成客户端Javascript。

***\*Window对象\****

客户端JavaScript程序的全局对象

### ***\*计时器\****

l setTimeout()：一个函数在指定的毫秒数之后运行。返回一个值，这个值可以传递给clearTimeout()用于取消这个函数的执行。

l setInterval()：一个函数在指定毫秒数的间隔里重复调用。返回一个值，这个值可以传递给clearInterval()用于取消后续函数的调用。

由于历史原因. setTimeout()和setInterval()的第一个参数可以作为字符串传入。如果这么做，那这个字符串会在指定的超时时间或间隔之后进行求值（相当于执行eval()）。

除前两个参数之外. HTML5规范（除IE之外的所有浏览器）还允许setTimeout()和setInterval()传入额外的参数，并在调用函数时把这些参数传递过去。

如果以0毫秒的超时时间来调用setTimeout()，那么指定的函数不会立刻执行。相反，会把它放到队列中，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。

请参照：http://ejohn.org/blog/how-javascript-timers-work/

### ***\*浏览器定位和导航\****

Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL，并定义了方法来使窗口载入新的文档。

Document对象的location属性也引用到Location对象。

Document对象也有一个URL属性，是文档首次载入后保存该文档的URL的静态字符串。如果定位到文档中的片段标识符（如#table-of-contents），Location对象会做相应的更新，而document.URL属性却不会改变。

***\*解析\*******\*URL\****

Location对象的href属性是一个字符串，后者包含URL的完整文本。Location对象的toString()方法返回href属性的值，因此在会隐式调用toString()的情况下，可以使用location代替location.href。

这个对象的其他属性——protocol，host，hostname，port，pathname和search，分别表示URL的各个部分。它们称为“URL分解”属性，同时被Link对象（通过HTML文档中的<a>和<area>元素创建）支持。

Location对象的hash和search属性比较有趣。如果有的话，hash属性返回URL中的“片段标识符”部分。search属性也类似，它返回的是问号之后的URL，这部分通常是某种类型的查询字符串。

示例：提取URL的搜索字符串中的参数

**/\***

 *** This function parses ampersand-separated name=value argument pairs from**

 *** the query string of the URL. It stores the name=value pairs in**

 *** properties of an object and returns that object. Use it like this:**

 *** var args = urlArgs();  // Parse args from URL**

 *** var q = args.q || "";  // Use argument, if defined, or a default value**

 *** var n = args.n ? parseInt(args.n) : 10;**

 ***/**

***\*function\**** urlArgs***\*()\**** ***\*{\****

  ***\*var\**** args ***\*=\**** ***\*{};\****               **// Start with an empty object**

  ***\*var\**** query ***\*=\**** ***\*location\****.***\*search\****.***\*substring\*******\*(\*******\*1\*******\*);\**** **// Get query string, minus '?'**

  ***\*var\**** pairs ***\*=\**** query.***\*split\*******\*(\******"&"\******);\****       **// Split at ampersands**

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** pairs.***\*length\*******\*;\**** i***\*++)\**** ***\*{\****  **// For each fragment**

​    ***\*var\**** pos ***\*=\**** pairs***\*[\****i***\*]\****.***\*indexOf\*******\*(\******'='\******);\****    **// Look for "name=value"**

​    ***\*if\**** ***\*(\****pos ***\*==\**** ***\*-\*******\*1\*******\*)\**** ***\*continue\*******\*;\****        **// If not found, skip it**

​    ***\*var\**** ***\*name\**** ***\*=\**** pairs***\*[\****i***\*]\****.***\*substring\*******\*(\*******\*0\*******\*,\****pos***\*);\**** **// Extract the name**

​    ***\*var\**** ***\*value\**** ***\*=\**** pairs***\*[\****i***\*]\****.***\*substring\*******\*(\****pos***\*+\*******\*1\*******\*);\**** **// Extract the value**

​    ***\*value\**** ***\*=\**** decodeURIComponent***\*(\*******\*value\*******\*);\****   **// Decode the value**

​    args***\*[\*******\*name\*******\*]\**** ***\*=\**** ***\*value\*******\*;\****          **// Store as a property**

  ***\*}\****

  ***\*return\**** args***\*;\****                **// Return the parsed arguments**

***\*}\****

***\*载入\*******\*新的文档\****

Location对象的assign()方法可以使窗口载入并显示你指定的URL中的文档。

replace()方法也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。如果脚本无条件地载入一个新文档， replace()方法可能是比assgin()方法更好的选择。否则，“后退”按钮会把浏览器带回到原始文档，而相同的脚本则会再次载入新文档。

Location对象还定义了reload()方法，后者可以让浏览器重新载入当前文档。

使浏览器跳转到新页面的一种更传统的方法是直接把新的URL赋给location属性。

纯粹的片段标识特是相对URL的一种类型，它不会让浏览器载入新文档，但会使它滚动到文档的某个位置。#top标识符是个特殊的例子：如果文档中没有元素的ID是"top"，它会让浏览器跳到文档开始处。

Location对象的URL分解属性是可写的，对它们重新赋值会改变URL的位置，并且导致浏览器载入一个新的文档（如果改变的是hash属性，则在当前文档中进行跳转）。

location.search ***\*=\**** **"?page="** ***\*+\**** (pagenum***\*+\*******\*1\****); **//载入下一个页面**

### ***\*浏览历史\****

Window对象的history属性引用的是该窗口的History对象。History对象是用来把窗口的浏览历史用文档和文档状态列表的形式表示。

但是出于安全的因素，脚本不能访问己保存的URL。

history对象的back()和forward()方法与浏览器的“后退”和“前进”按钮一样。

go()方法接受一个整数参数，可以在历史列表中向前（正参数）或向后（负参数）跳过任意多个页。

history.go(***\*-\*******\*2\****); **//后退两个历史记录，相当于单击"后退"按钮两次**

如果窗口包含多个子窗口（比如<iframe>元素），子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用history.back()可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。

在实际工作中，在那些需要以前的HTML5历史管理的项目中，开发者通常会使用一些现成的解决方案。很多JavaScript框架都实现了这种功能。比如，jQuery有history插件，另外也有些单独的管理历史记录的类库。RSH (Really Simple History)是其中一个比较流行的示例，可以在这里找到， http://code.google.com/p/reallysimplehistory/。

### ***\*浏览器和屏幕信息\****

***\*Navigator\*******\*对象\****

Window对象的navigator属性引用的是包含浏览器厂商和版本信息的Navigator对象。Navigator对象的命名是为了纪念Netscape之后Navigator浏览器，不过所有其他的浏览器也支持它（IE还支持clientInformation属性，它作为navigator的厂商中立同义词。遗憾的是，其他浏览器并不支持这一更直观的属性命名）。

过去，Navigator对象通常被脚本用来确定它们是在IE中还是在Netscape中运行。这种浏览器嗅探方法有问题，因为它要求随着新浏览器和现有浏览器的新版本的引入而不断地调整。如今，有一种更好的功能测试方法，只需要测试所需要的功能（即，方法或属性），而不是假设特定的浏览器版本及其功能。

然而，浏览器嗅探有时候仍然有价值。这样的一种情况是，当需要解决存在于某个特定的浏览器的特定版本中的特殊的bug时。Navigator对象有4个属性用于提供关于运行中的浏览器的版本信息，并且可以使用这些属性进行浏览器嗅探。

l appName：Web浏览器的全称。在IE中，这就是"Microsoft Internet Explorer"。在Firefox中，该属性就是"Netscape"。为了兼容现存的浏览器嗅探代码，其他浏览器通常也取值为"Netscape" 。

l appVersion：此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是4.0或5.0，表示它是第4或第5代兼容的浏览器。appVersion字符串没有标准的格式，所以，没有办法直接用它来判断浏览器的类型。

l userAgent：浏览器在它的USER-AGENT HTTP头部中发送的字符串。这个属性通常包含appVersion中的所有信息，并且常常也可能包含其他的细节。和appVersion一样，它也没有标准的格式。由于这个属性包含绝大部分信息，因此浏览器嗅探代码通常用它来嗅探。

l platform：在其上运行浏览器的操作系统（并且可能是硬件）的字符串。

下例展示了如何使用正则表达式从navigator.userAgent中抽取浏览器名称和版本号

**// Define browser.name and browser.version for client sniffing, using code**

**// derived from jQuery 1.4.1. Both the name and number are strings, and both**

**// may differ from the public browser name and version. Detected names are:**

**//**

**//  "webkit": Safari or Chrome; version is WebKit build number**

**//  "opera": the Opera browser; version is the public version number**

**//  "mozilla": Firefox or other gecko-based browsers; version is Gecko version**

**//  "msie": IE; version is public version number**

**//**

**// Firefox 3.6, for example, returns: { name: "mozilla", version: "1.9.2" }.**

***\*var\**** browser ***\*=\**** ***\*(\*******\*function\*******\*()\**** ***\*{\****

   ***\*var\**** s ***\*=\**** ***\*navigator\****.***\*userAgent\****.***\*toLowerCase\*******\*();\****

   ***\*var\**** ***\*match\**** ***\*=\**** ***\*/(\****webkit***\*)[\**** ****/]([\****\w.***\*]+)/\****.***\*exec\*******\*(\****s***\*)\**** ***\*||\****

​     ***\*/(\****opera***\*)(?:\****.***\**\****version***\*)?[\**** ****/]([\****\w.***\*]+)/\****.***\*exec\*******\*(\****s***\*)\**** ***\*||\****

​     ***\*/(\****msie***\*)\**** ***\*([\****\w.***\*]+)/\****.***\*exec\*******\*(\****s***\*)\**** ***\*||\****

​     ***\*!/\****compatible***\*/\****.***\*test\*******\*(\****s***\*)\**** ***\*&&\**** ***\*/(\****mozilla***\*)(?:\****.***\**?\**** rv***\*:([\****\w.***\*]+))?/\****.***\*exec\*******\*(\****s***\*)\**** ***\*||\****

​     ***\*[];\****

   ***\*return\**** ***\*{\**** ***\*name\*******\*:\**** ***\*match\*******\*[\*******\*1\*******\*]\**** ***\*||\**** **""\******,\**** version***\*:\**** ***\*match\*******\*[\*******\*2\*******\*]\**** ***\*||\**** **"0"** ***\*};\****

***\*}());\****

Navigator对象还包含一些杂项的属性和方法：

l onLine：navigator.onLine属性(如果存在的话)表示浏览器当前是否连接到网络。应用程序可能希望在离线状态下把状态保存在本地

l geolocation：Geolocation对象定义用于确定用户地理位置信息的接口。

l javaEnabled()：一个非标准的方法，当浏览器可以运行Java小程序时返回true。

l cookieEnable()：非标准的方法，如果浏览器可以保存永久的cookie时，返回true。当cookie配置为“视具体情况而定”时可能会返回不正确的值。

***\*Screen对象\****

Window对象的screen属性引用的是Screen对象。它提供有关窗口显示的大小和可用的颜色数量的信息。

属性width和height指定的是以像素为单位的窗口大小。

属性availWidth和availHeight指定的是实际可用的显示大小，它们排除了像桌面任务栏这样的特性所占用的空间。

属性colorDepth指定的是显示的BPP (bits-per-pixel) 值，典型的值有16 、24和32。

window.screen属性和它引用的Screen对象都是非标准但广泛实现的。

### ***\*对话框\****

Window对象提供了3个方法来向用户显示简单的对话框。

l alert()向用户显示一条消息并等待用户关闭对话框。 

l confirm()也显示一条消息，要求用户单击“确定”或“取消”按钮，并返回一个布尔值。

l prompt()同样也显示一条消息，等待用户输入字符串，并返回那个字符串。

注意，这些对话框中显示的文本是纯文本，而不是HTML格式的文本。只能使用空格、换行符和各种标点符号来格式化这些对话框。

方法confirmO 和prompt()都会产生阻塞，也就是说，在用户关掉它们所显示的对话框之前，它们不会返回。这就意味着在弹出一个对话框前，代码就会停止运行。如果当前正在载入文档，也会停止载入，直到用户用要求的输入进行响应为止。在大多数的浏览器里，alert()方法也会产生阻塞，并等待用户关闭对话框，但并不总是这样。

还有个更复杂的方法showModalDialog()，显示一个包含HTML格式的“模态对话框”（***\*模态对话框就是指那种\*******\*“显示出来就不可以点选位于其下面的对话框”的\*******\*对话框\****），可以给它传入参数，以及从对话框里返回值。

l 第一个参数用以指定提供对话框HTML内容的URL。

l 第二个参数是一个任意值（数组和对象均可），这个值在对话框里的脚本中可以通过window.dialogArguments属性的值访问。

l 第三个参数是一个非标准的列表，包含以分号隔开的name=value对，如果提供了这个参数，可以配置对话框的尺寸或其他属性。用"dialogwidth" 和"dialogheight"来设置对话框窗口的大小，用"resizable=yes" 来允许用户改变窗口大小。

用这个方法显示的窗口是“模态的”，showModalDialog()这个方法直到窗口关闭之前不会返回。当窗口关闭后， window.returnValue属性的值就是此方法返回的值。对话框的HTML内容往往必须包含用来设置returnValue的“确认”按钮，如果需要则调用window.close()。示例：

***\*<!--\****

 This ***\*is\**** not a stand***\*-\****alone HTML file. It must be invoked by showModalDialog***\*()\****.

 It expects ***\*window\****.dialogArguments to be an array of strings.

 The first ***\*element\**** of the array ***\*is\**** displayed at the ***\*top\**** of the dialog.

 Each remaining ***\*element\**** ***\*is\**** a label ***\*for\**** a single***\*-\****line ***\*text\**** input field.

 Returns an array of input field values when the user clicks Okay.

 Use ***\*this\**** file ***\*with\**** code like ***\*this\*******\*:\****

 

 ***\*var\**** p ***\*=\**** showModalDialog***\*(\******"multiprompt.html"\******,\****

​             ***\*[\******"Enter 3D point coordinates"\******,\**** **"x"\******,\**** **"y"\******,\**** **"z"\******],\****

​             **"dialogwidth:400; dialogheight:300; resizable:yes"\******);\****

 ***\*-->\****





<fieldset ***\*id\*******\*=\******"fields"\******></\****fieldset> ***\*<!--\**** Dialog body filled ***\*in\**** by script ***\*below\**** ***\*-->\****



  



<button ***\*onclick\*******\*=\******"okay()"\******>\****Okay***\*</\****button>   ***\*<!--\**** Set ***\*return\**** ***\*value\**** and ***\*close\**** ***\*-->\****

<button ***\*onclick\*******\*=\******"cancel()"\******>\****Cancel***\*</\****button> ***\*<!--\**** Close ***\*with\**** no ***\*return\**** ***\*value\**** ***\*-->\****

***\*</\****div>

<script>

**// Create the HTML for the dialog body and display it in the fieldset**

***\*var\**** args ***\*=\**** dialogArguments***\*;\****

***\*var\**** ***\*text\**** ***\*=\**** **"<legend>"** ***\*+\**** args***\*[\*******\*0\*******\*]\**** ***\*+\**** **"</legend>"\******;\****

***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*1\*******\*;\**** i ***\*<\**** args.***\*length\*******\*;\**** i***\*++)\**** 

  ***\*text\**** ***\*+=\**** **"<label>"** ***\*+\**** args***\*[\****i***\*]\**** ***\*+\**** **": <input id='f"** ***\*+\**** i ***\*+\**** **"'></label><br>"\******;\****

***\*document\****.getElementById***\*(\******"fields"\******)\****.***\*innerHTML\**** ***\*=\**** ***\*text\*******\*;\****

 

**// Close the dialog without setting a return value**

***\*function\**** cancel***\*()\**** ***\*{\**** ***\*window\****.***\*close\*******\*();\**** ***\*}\****

 

**// Read the input field values and set a return value, then close**

***\*function\**** okay***\*()\**** ***\*{\****

  ***\*window\****.***\*returnValue\**** ***\*=\**** ***\*[];\****       **// Return an array**

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*1\*******\*;\**** i ***\*<\**** args.***\*length\*******\*;\**** i***\*++)\**** **// Set elements from input fields**

​    ***\*window\****.***\*returnValue\*******\*[\****i***\*-\*******\*1\*******\*]\**** ***\*=\**** ***\*document\****.getElementById***\*(\******"f"** ***\*+\**** i***\*)\****.***\*value\*******\*;\****

  ***\*window\****.***\*close\*******\*();\**** **// Close the dialog. This makes showModalDialog() return.**

***\*}\****

***\*</\****script>

***\*</\****form>

### ***\*错误处理\****

Window对象的onerror属性是一个事件处理程序，当未捕获的异常传播到调用栈上时就会调用它，并把错误消息输出到浏览器的JavaScript控制台上。如果给这个属性赋一个函数，那么只要这个窗口中发生了JavaScript错误，就会调用该函数，即它成了窗口的错误处理程序。

由于历史原因，Window对象的onerror事件处理函数的调用通过三个字符串参数，而不是通过通常传递的一个事件对象。（其他客户端对象的onerror处理程序所需要的错误条件是不一样的，但是它们都是正常的事件处理程序，向这个函数只须传入一个事件对象。）window.onerror的第一个参数是描述错误的一条消息。第二个参数是一个字符串，它存放引发错误的JavaScript代码所在的文档的URL。第三个参数是文档中发生错误的行数。

除了这三个参数之外，onerror处理程序的返回值也很重要。如果onerror处理程序返回false，它通知浏览器事件处理程序已经处理了错误，不需要其他操作。换句话说，浏览器不应该显示它自己的错误消息。遗憾的是，由于历史原因，Firefox里的错误处理程序必须返回true来表示它已经处理了错误。

onerror处理程序是早期JavaScript的遗物，那时语言核心不包含try/catch异常处理语句。现代代码已经很少使用它。但是，在开发阶段，你可能要像这样定义一个错误处理程序，当有错误发生时，来显式地通知你：

**//在一个对话框中弹出错误消息，但不超过三次**

***\*window\****.***\*onerror\**** ***\*=\**** ***\*function\*******\*(\****msg***\*,\**** url***\*,\**** line***\*)\**** ***\*{\**** 

 ***\*if\**** ***\*(\*******\*onerror\****.num***\*++\**** ***\*<\**** ***\*onerror\****.***\*max\*******\*)\**** ***\*{\**** 

  ***\*alert\*******\*(\******"ERROR: "** ***\*+\**** msg  ***\*+\**** **"\n"** ***\*+\**** url ***\*+\**** **":"** ***\*+\**** line***\*);\**** 

  ***\*return\**** ***\*true\*******\*;\****

***\*}\**** 

***\*onerror\****.***\*max\**** ***\*=\**** ***\*3\*******\*;\**** 

***\*onerror\****.num ***\*=\**** ***\*0\*******\*;\**** 

### ***\*作为Window对象属性的文档元素\****

如果在HTML文档中用id属性来为元素命名，并且如果Window对象没有此名字的属性，Window对象会赋予一个属性，它的名字是id属性的值，而它们的值指向表示文档元素的HTMLElement对象。

这就意味着在HTML文档中使用的id属性会成为可以被脚本访问的全局变量。如果文档包含一个<button id="okay"/>元素，可以通过全局变量okay来引用此元素。

但是，有一个重要的警告：如果Window对象已经具有此名字的属性，这就不会发生。比如，id是"history"、"location"或"navigator"的元素，就不会以全局变量的形式出现，因为这些ID 已经占用了。同样，如果HTML文档包含一个id为"x" 的元素，并且还在代码中声明并赋值给全局变量x，那么显式声明的变量会隐藏隐式的元素变量。如果脚本中的变量声明出现在命名元素之前，那这个变量的存在就会阻止元素获取它window属性。而如果脚本中的变量声明出现在命名元素之后，那么变量的显式赋值会覆盖该属性的隐式值。

假设ID并没有被Window对象使用的话，那么任何有id属性的HTML元素都会成为全局变量的值。以下HTML元素如果有name属性的话，也会这样表现：

<a> <applet> <area> <embed> <form> <frame> <frameset> <iframe> <img> <object>

id元素在文档中必须是唯一的：两个元素不能有相同的id。但是，这对name属性无效。如果上面的元素有多于一个有相同的name属性（或者一个元素有name属性，而另一个元素有相同值的id属性），具有该名称的隐式全局变量会引用一个类数组对象，这个类数组对象的元素是所有命名的元素。

有name或id属性的<iframe>元素是个特殊的例子。为它们隐式创建的变量不会引用表示元素自身的Element对象，而是引用表示<iframe>元素创建的嵌套浏览器窗体的Window对象。

### ***\*多窗口和窗体\****

HTML文档经常使用<iframe> 来嵌套多个文档。由<iframe>所创建的嵌套浏览上下文是用它自己的Window对象所表示的。废弃的<frameset>和<frame>元素同样创建了一个嵌套的浏览上下文，每一个<f rame>都由一个独立的Window对象表示。对于客户端JavaScript来说，窗口、标签页、iframe和框架都是浏览上下文；对于JavaScript来说，它们都是Window对象。和相互独立的标签页不同，嵌套的浏览上下文之间并不是相互独立的。在一个窗体中运行的JavaScript程序总是可以看到它的祖先和子孙窗体，尽管脚本查看这些窗体中的文档受到同源策略的限制。

***\*打开\*******\*和关闭窗口\****

使用Window对象的open()方法可以打开一个新的浏览器窗口，它有4个可选参数：

l 第一个参数是要在新窗口中显示的文档的URL；

l 第二个参数是新打开的窗口的名字；如果指定的是一个已经存在的窗口的名字（并且脚本允许跳转到那个窗口），会直接使用已存在的窗口。否则，会打开新的窗口，并将这个指定的名字赋值给它。如果省略此参数，会使用指定的名字"_blank" 打开一个新的、未命名的窗口。（窗口的名字是非常重要的，因为它允许open() 方法引用已存在的窗口，并同时可以作为<a>和dorm> 元素上HTML target属性的值，用来表示引用的文档（或表单提交结果）应该显示在命名的窗口中。）

l 第三个可选参数是一个以逗号分隔的列表，包含大小和各种属性，用以表明新窗口是如何打开的；示例：

***\*var\**** w = window.open("smallwin.html", "smallwin",

  "width=400,height=350,status=yes,resizable=yes")

l 第四个参数只在第二个参数命名的是一个存在的窗口时才有用。它是一个布尔值，声明了由第一个参数指定的URL是应用替换掉窗口浏览历史的当前条目(true)，还是应该在窗口浏览历史中创建一个新的条目(false)，后者是默认的设置。

l open()的返回值是代表命名或新创建的窗口的Window对象。

l 在由window.open()方法创建的窗口中，opener属性引用的是打开它的脚本的Window对象。在其它窗口中， opener为null。

方法close()将关闭一个窗口。注意，要显式地使用标识符window，这样可以避免混淆Window对象的close()方法和Document对象的close()方法。

大多数浏览器只允许自动关闭由自己的JavaScript代码创建的窗口。如果要关闭其他窗口，可以用一个对话框提示用户，要求他对关闭窗口的请求进行确认（或取消）。

在表示窗体而不是顶级窗口或标签页上的Window对象上执行close()方法不会有任何效果，它不能关闭一个窗体（反之可以从它包含的文档中删除iframe）。

即使一个窗口关闭了，代表它的Window对象仍然存在。己关闭的窗口会有个值为true的closed属性，它的document会是null，它的方法通常也不会再工作。

***\*窗体之间\*******\*的关系\****

Window对象的方怯open() 返回代表新创建的窗口的Window对象。而且这个新窗口具有opener属性，该属性可以打开它的原始窗口。

任何窗口或窗体中的JavaScript代码都可以将自己的窗口和窗体引用为window或self。

窗体可以用parent属性引用包含它的窗口或窗体的Window对象。如果一个窗口是顶级窗口或标签，而不是窗体，那么其parent属性引用的就是这个窗口本身。

如果一个窗体包含在另一个窗体中，而后者又包含在顶级窗口中，那么该窗体就可以使用parent.parent来引用顶级窗口。top属性是一个通用的快捷方式，无论一个窗体被嵌套了几层，它的top属性引用的都是指向包含它的顶级窗口。如果一个Window对象代表的是一个顶级窗口，那么它的top属性引用的就是窗口本身

窗体是通过<iframe>元素创建的。可以用获取其他元素的方法来获取一个表示<iframe> 的元素对象。假定文档里有<iframe id="f1">。那么，表示该iframe的元素对象就是：

***\*var\**** iframeElement = document.getElementById("f1");



file:///H:/Program%20Files/Typora/resources/app//null

<iframe allow-top-navigation="false" allow-forms="false" allowfullscreen="true" allow-popups="false" sandbox="allow-scripts" onload="window.remoteOnLoad &amp;&amp; window.remoteOnLoad(this)" src="null" height="48" data-user-height="24" style="box-sizing: border-box; margin: 0px auto; max-width: 100%; width: 800px; border: none;"></iframe>



***\*var\**** childFrame = document.getElementById("f1").contentWindow;

可以进行反向操作一一从表示窗体的Window对象来获取该窗体的<iframe>元素一一用Window对象的frameElement属性。表示顶级窗口的Window对象的frameElement属性为null，窗体中的Window对象的frameElement属性不是null:

***\*var\**** elt = document.getElementById("f1");

***\*var\**** win = elt.contentWindow;

win.frameElement === elt //对于子窗口来说永远是true

window.frameElement === ***\*null\**** //对于顶级窗口来说永远是true

尽管如此，通常不需要使用getElementById()方法和contentWindow属性来获取窗口中子窗体的引用。每个Window对象都有一个frames属性，它引用自身包含的窗口或窗体的子窗体。frames属性引用的是类数组对象，并可以通过数字或窗体名进行索引。frames[] 数组里的元素是Window对象，而不是<iframe>元素。如果指定<iframe>元素的name或id属性，那么除了用数字进行索引之外，还可以用名字来进行索引。



file:///H:/Program%20Files/Typora/resources/app//null

<iframe allow-top-navigation="false" allow-forms="false" allowfullscreen="true" allow-popups="false" sandbox="allow-scripts" onload="window.remoteOnLoad &amp;&amp; window.remoteOnLoad(this)" src="null" height="48" data-user-height="24" style="box-sizing: border-box; margin: 0px auto; max-width: 100%; width: 800px; border: none;"></iframe>



实际上. HTML5规范指出frames属性是一个自引用(self-referential)的属性，就像window和self一样。而这个Window对象看起来像一个由窗体组成的数组。也就是说可以通过window[0]来获取第一个子窗体的引用，可以通过window.length或length查询窗体的编号。但是这里我们使用frames来代替window会比较清晰一些，尽管这种方法有些传统。需要注意的是，当前的浏览器不会让frame==window，但在frame和window不相等的情况下，可以通过子窗体的索引或名字来获取其他对象的引用。

可以使用<iframe>的元素的name或id属性作为JavaScript代码中的引用标识。但如果使用name属性的话，所指定的name同样也会成为代表这个窗体的Window对象的name属性。以这种方式给出的名字可以用做一个链接的target属性，而且它可以用做window.open() 的第二个参数。

***\*交互\*******\*窗口中的JavaScript\****

当在窗体或窗口间共享函数肘，牢记词法作用域的规则非常重要。***\*函数在定义它的作用域中执行，而不是在调用它的作用域中执行\****。

事实上，每个Window都有自己的原型对象，这意味着instanceof操作符不能跨窗口工作。例如，当用instanceof来比较窗体B的一个字符串和窗体A的String()构造函数时，结果会为false。

***\*WindowProxy\*******\*对象\****

我们已经讲过很多次，Window对象是客户端JavaScript的全局变量。但是从技术上来看，并不是这样的。Web浏览器每次向窗口或窗体中载入新的内容，它都会开始一个新的JavaScript执行上下文，包含一个新创建的全局对象。但是当多个窗口或窗体在使用时，有一个重要的概念，尽管窗体或窗口载入了新的文档，但是引用窗体或窗口的Window对象还仍然是一个有效的引用。

所以客户端JavaScript 有两个重要的对象。客户端全局对象处于作用域链的顶级，并且是全局变量和函数所定义的地方。事实上，全局对象会在窗口或窗体载入新内容时被替换。我们称为"Window对象"的对象实际上不是全局对象，而是全局对象的一个代理。每当查询或设直Window对象的属性时，就会在窗口或窗体的当前全局对象上查询或设置相同的属性。HTML5规范称这个代理对象为WindowProxy，但我们会继续使用名词Window对象。

由于它的代理行为，除了有更长的生命周期之外，代理对象表现得像真正的全局对象。如果可以比较两个对象，那么区分它们会很困难。但是事实上，没有办法可以引用到真正的客户端全局对象。全局对象处于作用域链的顶端，但是window、self、top、parent 以及窗体的属性全部返回代理对象。window.open()方法也返回代理对象。甚至顶级函数里this 关键字的值都是代理对象，而不是真正的全局对象。

***\*脚本化文档\****

每一个Web浏览器窗口、标签页和框架由一个Window对象所表示。每个Window对象有一个document属性引用了Document对象。Document对象表示窗口的内容。尽管如此，Document对象并非独立的，它是一个巨大的API中的核心对象，叫做文档对象模型(Document Object Model, DOM)，它代表和操作文档的内容。

### ***\*DOM概览\****

树形的根部是Document节点，它代表整个文档。代表HTML元素的节点是E1ement节点，代表文本的节点是Text节点。 Document、Element和Text是Node的子类。

文档节点的部分层次结构图：

 

Comment节点代表HTML或XML的注释。由于注释基本上是文本字符串，因此它们很像表示文档中显示文本的Text节点。CharacterData通常是Text和Comment的祖先，它定义这两种节点所共享的方法。Attr节点类型代表XML或HTML属性，但它几乎从不使用，因为和文档节点不同，Element类型定义了将属性当做“名/值”对使用的方法。DocumentFragment类在实际文档中并不存在的一种节点：它代表一系列没有常规父节点的节点。对一些文档操作来说DocumentFragment非常有用。

### ***\*选取文档元素\****

DOM定义许多方式来选取元素，查询文档的一个或多个元素有如下方法:

l 用指定的id属性；

l 用指定的name属性；

l 用指定的标签名字；

l 用指定的CSS类；

l 匹配指定的CSS选择器。

***\*通过ID\*******\*选取\*******\*元素\****

任何HTML元素可以有一个id属性，在文档中该值必须唯一，即同一个文档中的两个元素不能有相同的ID。可以用Document对象的getElementById()方法选取一个基于唯一ID的元素。

在低于IE8版本的浏览器中，getElementById()对匹配元素的ID不区分大小写，而且也返回匹配name属性的元素。

***\*通过\*******\*名字选取\*******\*元素\****

HTML的name属性最初打算为表单元素分配名字，在表单数据提交到服务器时使用该属性的值。类似id 属性，name是给元素分配名字，但是区别于id，name属性的值不是必须唯一：多个元素可能有同样的名字，在表单中，单选和复选按钮通常是这种情况。而且，和id不一样的是name属性只在少数HTML元素中有效，包括表单、表单元素、<iframe>和<img>元素。

基于name属性的值选取HTML元素，可以使用Document对象的getElementsByName()方法。

getElementsByName() 定义在HTMLDocument类中，而不在Document类中，所以它只针对HTML文档可用，在XML文档中不可用。它返回一个NodeList对象，后者的行为类似一个包含若干Element对象的只读数组。在IE中， getElementsByName() 也返回id属性匹配指定值的元素。为了兼容，应该小心谨慎，不要将同样的字符串同时用做名字和ID。

为某些HTML元素设置name属性值将自动为Window对象中创建对应的属性，对Document对象也类似。为<form>、 <img>、<frame>、<applet>、<embed>或<object>元素（其中只有<object>元素没有后备对象）设置name属性值，即在Document对象中创建以此name属性值为名字的属性（当然，假设此文档还没有该名字的属性）。

如果给定的名字只有一个元素，自动创建的文档属性对应的该值是元素本身。如果有多个元素，该文档属性的值是一个NodeList对象，它表现为一个包含这些元素的数组。为若干命名<iframe>元素所创建的文档属性比较特殊；它们指代这些框架的Window对象而不是Element对象。这就意味着有些元素可以作为Document属性仅通过名字来选取：

//针对<form name="shipping_address">元素，得到Element对象

***\*var\**** form = document.shipping_address;

***\*通过\*******\*标签名选取\*******\*元素\****

Document对象的getElementsByTagName()方法可用来选取指定类型（标签名）的所有HTML或XML元素，它返回一个NodeList对象。

在NodeList中返回的元素按照在文档中的顺序排序。

HTML标签是不区分大小写的，当在HTML文档中使用getElementsByTagName()时，它进行不区分大小写的标签名比较。

传递通配符参数"*"将获得一个代表文档中所有元素的NodeList对象。

Element类也定义getElementsByTagName()方法，其原理和Document版本的一样，但是它只选取调用该方法的元素的后代元素。

由于历史的原因，HTMLDocument类定义一些快捷属性来访问各种各样的节点。例如，images、forms和links等属性指向行为类似只读数组的<img>、<form>和<a>（但只包含那些有href属性的<a>标签）元素集合。这些属性指代HTMLCollection对象，它们很像NodeList对象，但是除此之外它们可以用元素的ID或名字来索引。

HTMLDocument也定义embeds和plugins属性，它们是同义词，都是HTMLCollection类型的<embed>元素的集合。anchors是非标准属性，它指代有一个name属性的<a>元素而并不是一个href属性。scripts在HTML5 中是标准属性，它是HTMLCollection类型的<script>元素的集合，但是在写本书的时候，它还未普遍实现。

HTMLDocument对象还定义两个属性，它们指代特殊的单个元素而不是元素的集合。document.body是一个HTML文档的<body>元素，document.head是<head>元素。这些属性总是会定义：如果文档源代码未显式地包含<head>和<body>元素，浏览器将隐式地创建它们。Document类的documentElement属性指代文档的根元素。在HTML文档中，它总是指代<html>元素。

***\*通过\*******\*css\*******\*类选取元素\****

HTML元素的class属性值是一个以空格隔开的列表，可以为空或包含多个标识符。它描述一种方法来定义多组相关的文档元素：在它们的class属性中有相同标识符的任何元素属于该组的一部分。在JavaScript中class是保留字，所以客户端JavaScript使用className属性来保存HTML的class属性值。尽管如此，HTML定义了getElementsByClassName()方法，它基于其class属性值中的标识符来选取成组的文档元素。

在HTML 文档和HTML元素上都可以调用getElementsByClassName()，它的返回值是一个实时的NodeList对象，包含文档或元素所有匹配的后代节点。该方法只需要一个字符串参数，但是该字符串可以由多个空格隔开的标识符组成。只有当元素的class属性值包含所有指定的标识符时才匹配，但是标识符的顺序是无关紧要的。注意，class 属性和getElementsByClassName()方法的类标识符之间都是用空格隔开的，而不是逗号。

***\*通过\*******\*css\*******\*选择器选取元素\****

CSS样式表有一种非常强大的语法，那就是选择器，它用来描述文档中的若干或多组元素。

Document方法querySelectorAll()接受包含一个CSS选择器的字符串参数，返回一个表示文档中匹配选择器的所有元素的NodeList对象。这个NodeList对象并***\*不是实时\****的:它包含在调用时刻选择器所匹配的元素，但它并不更新后续文档的变化。如果没有匹配的元素，querySelectorAll()将返回一个空的NodeList对象。如果选择器字符串非法，querySelectorAll()将抛出一个异常。

文档对象还定义了querySelector()方法。与querySelectorAll()的工作原理类似，但它只是返回第一个匹配的元素（以文档顺序）或者如果没有匹配的元素就返回null。

这两个方法在Element节点中也有定义（并且也在DocumentFragment节点中）。在元素上调用时，指定的选择器仍然在整个文档中进行匹配，然后过滤出结果集以便它只包含指定元素的后代元素。

注意，CSS定义了":first-line" 和":first-letter" 等伪元素。在CSS 中，它们匹配文本节点的一部分而不是实际元素。如果和querySelectorAll() 或querySelector() 一起使用它们是不匹配的。而且，很多浏览器会拒绝返回":link" 和":visited" 等伪类的匹配结果，因为这会泄露用户的浏览历史记录。

所有当前的浏览器都支持querySelector() 和querySelectorAll() 方法。但是注意，这些方法的规范并不要求支持CSS3选择器：鼓励浏览器支持和在样式表中一样的选择器集合。当前的浏览器除了IE都支持CSS3选择器。IE 7和8支持CSS2选择器。

querySelectorAll() 是终极的选取元素的方法：它是一种非常强大的技术，通过它客户端JavaScript程序能够选择它们想要操作的元素。幸运的是，甚至在没有querySelectorAll() 的原生支持的浏览器中也可以使用CSS选择器。jQuery库使用这种基于CSS选择器的查询作为它的核心编程范式。

jQuery的CSS选择器匹配代码已经作为一个独立的标准库提出来并发布了，命名为Sizzle。它已经被Dojo和其他一些客户端库所采纳。使用一个类似Sizzle的库（或一个包含Sizzle的库）的好处就是在老式浏览器中选取元素也能正常工作，并保证一个基准的选择器集合在所有的浏览器中都能运行。

***\*document\*******\*.all[]\****

在DOM标准化之前，IE 4引入了 document.all[] 集合来表示所有文档中的元素（除了Text节点）。document.all[] 已经被标准的方法（如getElementById() 和getElementsByTagName()）等所取代，现在已经废弃不应该再使用了。

***\*document\****.***\*all\*******\*[\****O***\*]\**** **//文档中第一个元素**

***\*document\****.***\*all\*******\*[\******"navbar"\******]\**** **// id或name为"navbar"的元素(或多个元素)**

***\*document\****.***\*all\****.navbar  **//同上**

***\*document\****.***\*all\****.***\*tags\*******\*(\******"div"\******)\**** **//文档中所有的<div>元素**

***\*document\****.***\*all\****.***\*tags\*******\*(\******"p"\******)[\*******\*0\*******\*]\**** **//文档中第一个<p>元素**

### ***\*文档结构和遍历\****

文档从概念上可以看做是一棵节点对象树，

***\*作为节点树的文档\****

Document对象、它的Element对象和文档中表示文本的Text对象都是Node对象。Node定义了以下重要的属性:

l parentNode：该节点的父节点，或者针对类似Document对象应该是null ，因为它没有父节点。

l childNodes：只读的类数组对象（NodeList对象），它是该节点的子节点的实时表示。

l firstChild、lastChild：该节点的子节点中的第一个和最后一个，如果该节点没有子节点则为null。

l nextSibling、previoursSibling：该节点的兄弟节点中的前一个和下一个。具有相同父节点的两个节点为兄弟节点。节点的顺序反映了它们在文档中出现的顺序。这两个属性将节点之间以双向链表的形式连接起来。

l nodeType：该节点的类型。9代表Document节点，1代表Element节点，3代表Text节点，8代表Comment节点，11代表DocumentFragment节点。

l nodeValue：Text节点或Comment节点的文本内容。

l nodeName：元素的标签名，以大写形式表示。

***\*作为\*******\*元素\*******\*树\*******\*的文档\****

当将主要的兴趣点集中在文档中的元素上而非它们之间的文本（和它们之间的空白）上时，我们可以使用另外一个更有用的API。它将文档看做是Element对象树，忽略部分文档: Text和Comment节点。

该API的第一部分是Element对象的children属性。类似ChildNodes，它也是一个NodeList对象，但不同的是children列表只包含Element对象。children并非标准属性，但是它在所有当前的浏览器中都能工作。

第二部分是Element属性，后者类似Node对象的子属性和兄弟属性:

l firstElementChild,lastElementChild：类似firstChild和lastChild. 但只代表子Element。

l nextElementSibling,previousElementSibling ：类似nextSibling和previousSibling. 但只代表兄弟Element。

l childElementCount：子元素的数量。返回的值和children.length值相等。

子元素和兄弟元素的属性是标准属性，并在除了IE之外的浏览器中都已实现。

### ***\*属性\****

HTML元素由一个标签和一组称为属性(attribute)的名/值对组成。HTM元素的属性值在代表这些元素的HTMLElement对象的属性(property) 中是可用的。

***\*HTML\*******\*属性作为\*******\*Element\*******\*的属性\****

HTML属性名不区分大小写，但JavaScript属性名则大小写敏感。从HTML属性名转换到JavaScript属性名应该采用小写。但是，如果属性名包含不止一个单词，则将除了第一个单词以外的单词的首字母大写。

有些HTML属性名在JavaScript中是保留字。对于这些属性，一般的规则是为属性名加前缀"html"。"class" 在JavaScript中是保留字（但还未使用），它是HTML非常重要的class属性，是上面规则的一个例外：在JavaScript代码中它变为className。

表示HTML属性的值通常是字符串。当属性为布尔值或数值（例如，<input>元素的defaultChecked和maxLength属性），属性也是布尔值或数值，而不是字符串。事件处理程序属性值总是为Function对象（或null）。HTML5规范定义了一个新的属性（如<input>和相关元素的form属性）用以将元素ID转换为实际的Element对象。最后，任何HTML元素的style属性值是***\*CSSStyleDeclaration\****对象，而不是字符串。

注意，这个基于属性的API用来获取和设置属性值，但没有定义任何从元素中删除属性的方法。奇怪的是，delete操作符也无法完成此目的。

***\*获取和设置非标准\*******\*HTML\*******\*属性\****

Element类型还定义了getAttribute()和setAttribute()方法来查询和设置非标准的HTML属性，也可用来查询和设置XML文档中元素上的属性。这些方法和前面的基于属性的API之间两个重要的区别：

首先，属性值都被看做是字符串。getAttribute()不返回数值、布尔值或对象。其次，方法使用标准属性名，甚至当这些名称为JavaScript保留字时也不例外。对HTML元素来说，属性名不区分大小写。

Element类型还定义了两个相关的方法，hasAttribute()和removeAttribute()，它们用来检测命名属性是否存在和完全删除属性。当属性为布尔值时这些方提特别有用：有些属性（如HTML的表单元素的disabled属性）在一个元素中是否存在是重点关键，而其值却无关紧要。

如果操作包含来自其他命名空间中属性的XML文档，可以使用这4个方法的命名空间版本: getAttributeNS()、setAttributeNS()、hasAttributeNS()和removeAttributeNS()。这些方法需要两个属性名字符串作为参数，而不是一个。第一个是标识命名空间的URI，第二个通常是属性的本地名字，在命名空间中是无效的。但特别地，setAttributeNS()的第二个参数应该是属性的有效名字，它包含命名空间的前缀。

***\*数据集\*******\*属性\****

有时候在HTML元素上绑定一些额外的信息也是很有帮助的，当JavaScript选取这些元素并以某种方式操纵这些信息时就是很典型的情况。有时可以通过给class属性添加特殊的标识符来完成。其他时候针对更复杂的数据，客户端程序员会借助使用非标准的属性。如上所述，可以使用getAttribute() 和setAttribute() 来读和写非标准属性的值。但为此而付出的代价是文档将不再是合法有效的HTML。

HTML5提供了一个解决方案。在HTML5文档中，任意以 "data-" 为前缀的小写的属性名字都是合法的。这些“数据集属性”将不会对其元素的表现产生影响，它们定义了一种标准的、附加额外数据的方法，并不是在文档合法性上做出让步。

HTML5还在Element对象上定义了dataset属性。该属性指代一个对象，它的各个属性对应于去掉前缀的data-属性。因此dataset.x应该保存data-x属性的值。带连字符的属性对应于驼峰命名法属性名: data-jquery-test属性就变成dataset.jqueryTest属性。

注意，dataset属性是（或将是，当实现以后）元素的data-属性的实时、双向接口。设置或删除dataset的一个属性就等同于设置或移除对应元素的data- 属性。

***\*作为\*******\*Attr\*******\*节\*******\*点的属\*******\*性\****

还有一种使用Element的属性的方法。Node类型定义了attributes属性。针对非Element对象的任何节点，该属性为null。对于Element对象，attributes属性是只读的类数组对象，它代表元素的所有属性。类似NodeLists，attributes对象也是实时的。它可以用数字索引访问，这意味着可以枚举元素的所有属性。并且，它也可以用属性名索引。

当索引attributes对象时得到的值是Attr对象。Attr对象是一类特殊的Node，但从来不会像Node一样去用。Attr的name和value属性返回该属性的名字和值。

### ***\*元素的内容\****

***\*作为\*******\*HTML\*******\*的元素内容\****

读取Element的innerHTML属性作为字符串标记返回那个元素的内容。在元素上设置该属性调用了Web浏览器的解析器，用新字符串内容的解析展现形式替换元素当前内容。（不要管它的名字，除了在HTML元素上，innerHTML也可以在XML元素上使用。）

HTML5说innerHTML应该在Document节点以及Element节点上工作正常，但这还未被普遍地支持。

HTML5还标准化了outerHTML属性。当查询outerHTML时，返回的HTML或XML标记的字符串包含被查询元素的开头和结尾标签。当设置元素的outerHTML时，元素本身被新的内容所替换。只有Element节点定义了outerHTML属性， Document节点则无。

IE引入的另一个特性是insertAdjacentHTML()方法，它将在HTML5中标准化，它将任意的HTML标记字符串插入到指定的元素“相邻”的位置。标记是该方法的第二个参数并且“相邻”的精确含义依赖于第一个参数的值。第一个参数为具有以下值之一的字符串:"beforebegin"、"afterbegin"、"beforeend"和"afterend"。这些值对应的插入点如图所示。

![x](file://D:/WorkingDir/Office/Resources/js003.png?lastModify=1614742308)



***\*作为纯\*******\*文本的元素内容\****

有时需要查询纯文本形式的元素内容，或者在文档中插入纯文本（不必转义HTML标记中使用的尖括号和&符号），标准的方法是用Node的textContent属性来实现。

textContent属性在除了IE的所有当前的浏览器中都支持。在IE中，可以用Element的innerText属性来代替。

textContent属性就是将指定元素的所有后代Text节点简单地串联在一起。innerText没有一个明确指定的行为，但是和textContent有一些不同。innerText不返回<script>元素的内容。它忽略多余的空白，并试图保留表格格式。同时，innerText针对某些表格元素（如<table>、<tbody>和<tr>）是只读的属性。

内联的<script>元素（也就是那些没有src属性的）有一个text属性用来获取它们的文本。浏览器不显示<script>元素的内容，并且HTML解析器忽略脚本中的尖括号和星号。这使得<script>元素成为应用程序用来嵌入任意文本内容的一个理想的地方。简单地将元素的type属性设直为某些值（如"text/x-custom-data"），就标明了脚本为不可执行的JavaScript代码。如果这样做，JavaScript解释器将忽咯该脚本，但该元素将仍然存在于文档树中，它的text 属性还将返回数据给你。

***\*作为\*******\*Text\*******\*节点的元素内容\****

另一种方法处理元素的内容来是当做一个子节点列表，每个子节点可能有它自己的一组子节点。当考虑元素的内容时，通常感兴趣的是它的Text节点。在XML文档中，你也必须准备好处理CDATASection节点——它是Text的子类型，代表了CDATA段的内容。

下例展示了一个textContent()函数，它递归地遍历元素的子节点，然后连接后代节点中所有的Text节点的文本。为了理解代码，回想一下nodeValue属性(定义在Node类型中)。它保存Text节点的内容。

**// Return the plain-text content of element e, recursing into child elements.**

**// This method works like the textContent property**

***\*function\**** textContent***\*(\****e***\*)\**** ***\*{\****

  ***\*var\**** child***\*,\**** ***\*type\*******\*,\**** s ***\*=\**** **""\******;\**** **// s holds the text of all children**

  ***\*for\*******\*(\****child ***\*=\**** e.firstChild***\*;\**** child ***\*!=\**** ***\*null\*******\*;\**** child ***\*=\**** child.nextSibling***\*)\**** ***\*{\****

​    ***\*type\**** ***\*=\**** child.nodeType***\*;\****

​    ***\*if\**** ***\*(\*******\*type\**** ***\*===\**** ***\*3\**** ***\*||\**** ***\*type\**** ***\*===\**** ***\*4\*******\*)\**** **// Text and CDATASection nodes**

​      s ***\*+=\**** child.nodeValue***\*;\****

​    ***\*else\**** ***\*if\**** ***\*(\*******\*type\**** ***\*===\**** ***\*1\*******\*)\****      **// Recurse for Element nodes**

​      s ***\*+=\**** textContent***\*(\****child***\*);\****

  ***\*}\****

  ***\*return\**** s***\*;\****

***\*}\****

nodeValue属性可以读/写，设置它可以改变Text或CDATASection节点所显示的内容。Text和CDATASection都是CharacterData的子类型，CharacterData定义了data属性，它和nodeValue的文本相同。

### ***\*创建、插入和删除节点\****

下例展示了节点的创建和插入，这里复制了这个简短的示例:

**// Asynchronously load and execute a script from a specified URL**

***\*function\**** loadasync***\*(\****url***\*)\**** ***\*{\**** 

  ***\*var\**** head ***\*=\**** ***\*document\****.getElementsByTagName***\*(\******"head"\******)[\*******\*0\*******\*];\**** **// Find document <head>**

  ***\*var\**** s ***\*=\**** ***\*document\****.createElement***\*(\******"script"\******);\**** **// Create a <script> element**

  s.***\*src\**** ***\*=\**** url***\*;\****                **// Set its src attribute** 

  head.appendChild***\*(\****s***\*);\****            **// Insert the <script> into head**

***\*}\****

***\*创建\*******\*节点\****

创建新的Element节点可以使用Document对象的createElement()方法。给方法传递元素的标签名:对HTML文档来说该名字不区分大小写，对XML文档则区分大小写。

另一种创建新文档节点的方法是复制已存在的节点。每个节点有一个cloneNode()方法来返回该节点的一个全新副本。给方法传递参数true也能够递归地复制所有的后代节点，或传递参数false只是执行一个浅复制。在除了IE的其他浏览器中，Document对象还定义了一个类似的方法叫importNode()。如果给它传递另一个文档的一个节点，它将返回一个适合本文档插入的节点的副本。传递true作为第二个参数，该方法将递归地导入所有的后代节点。

***\*插入节点\****

appendChild()是在需要插入的Element节点上调用的，它插入指定的节点使其成为那个节点的最后一个子节点。

insertBefore()就像appendChild()一样，除了它接受两个参数。第一个参数就是待插入的节点，第二个参数是己存在的节点，新节点将插入该节点的前面。该方法应该是在新节点的父节点上调用，方法的第二个参数必须是该父节点的子节点。如果传递null作为第二个参数，insertBefore()的行为类似appendChild()，它将节点插入在最后。

这是一个在数字索引的位置插入节点的简单函数

**//将child节点插入到parent中，使其成为第n个子节点**

***\*function\**** insertAt***\*(\*******\*parent\*******\*,\**** child***\*,\**** n***\*)\**** ***\*{\**** 

 ***\*if\**** ***\*(\****n ***\*<\**** ***\*0\**** ***\*||\**** n ***\*>\**** ***\*parent\****.childNodes.***\*length\*******\*)\**** ***\*throw\**** ***\*new\**** Error***\*(\******"invalid index"\******);\**** 

 ***\*else\**** ***\*if\**** ***\*(\****n ***\*==\**** ***\*parent\****.childNodes.***\*length\*******\*)\**** ***\*parent\****.appendChild***\*(\****child***\*);\**** 

 ***\*else\**** ***\*parent\****.insertBefore***\*(\****child***\*,\**** ***\*parent\****.childNodes***\*[\****n***\*]);\**** 

***\*}\****

如果调用appendChild()或insertBefore()将己存在文档中的一个节点再次插入，那个节点将自动从它当前的位置删除并在新的位置重新插入:没有必要显式删除该节点。示例：表格的行排序

**// Sort the rows in first <tbody> of the specified table according to**

**// the value of nth cell within each row. Use the comparator function**

**// if one is specified. Otherwise, compare the values alphabetically.**

***\*function\**** sortrows***\*(\****table***\*,\**** n***\*,\**** comparator***\*)\**** ***\*{\****

  ***\*var\**** tbody ***\*=\**** table.tBodies***\*[\*******\*0\*******\*];\**** **// First <tbody>; may be implicitly created**

  ***\*var\**** rows ***\*=\**** tbody.getElementsByTagName***\*(\******"tr"\******);\**** **// All rows in the tbody**

  rows ***\*=\**** ***\*Array\****.***\*prototype\****.***\*slice\****.***\*call\*******\*(\****rows***\*,\*******\*0\*******\*);\****  **// Snapshot in a true array**

 

  **// Now sort the rows based on the text in the nth <td> element**

  rows.***\*sort\*******\*(\*******\*function\*******\*(\****row1***\*,\****row2***\*)\**** ***\*{\****

​    ***\*var\**** cell1 ***\*=\**** row1.getElementsByTagName***\*(\******"td"\******)[\****n***\*];\**** **// Get nth cell**

​    ***\*var\**** cell2 ***\*=\**** row2.getElementsByTagName***\*(\******"td"\******)[\****n***\*];\**** **// of both rows**

​    ***\*var\**** val1 ***\*=\**** cell1.textContent ***\*||\**** cell1.***\*innerText\*******\*;\**** **// Get text content**

​    ***\*var\**** val2 ***\*=\**** cell2.textContent ***\*||\**** cell2.***\*innerText\*******\*;\**** **// of the two cells**

​    ***\*if\**** ***\*(\****comparator***\*)\**** ***\*return\**** comparator***\*(\****val1***\*,\**** val2***\*);\****  **// Compare them!**

​    ***\*if\**** ***\*(\****val1 ***\*<\**** val2***\*)\**** ***\*return\**** ***\*-\*******\*1\*******\*;\****

​    ***\*else\**** ***\*if\**** ***\*(\****val1 ***\*>\**** val2***\*)\**** ***\*return\**** ***\*1\*******\*;\****

​    ***\*else\**** ***\*return\**** ***\*0\*******\*;\****

  ***\*});\****

 

  **// Now append the rows into the tbody in their sorted order.**

  **// This automatically moves them from their current location, so there**

  **// is no need to remove them first. If the <tbody> contains any**

  **// nodes other than <tr> elements, those nodes will float to the top.**

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** rows.***\*length\*******\*;\**** i***\*++)\**** tbody.appendChild***\*(\****rows***\*[\****i***\*]);\****

***\*}\****

 

**// Find the <th> elements of the table (assuming there is only one row of them)**

**// and make them clickable so that clicking on a column header sorts**

**// by that column.**

***\*function\**** makeSortable***\*(\****table***\*)\**** ***\*{\****

  ***\*var\**** headers ***\*=\**** table.getElementsByTagName***\*(\******"th"\******);\****

  ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** headers.***\*length\*******\*;\**** i***\*++)\**** ***\*{\****

​    ***\*(\*******\*function\*******\*(\****n***\*)\**** ***\*{\**** **// Nested funtion to create a local scope**

​      headers***\*[\****i***\*]\****.***\*onclick\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** sortrows***\*(\****table***\*,\**** n***\*);\**** ***\*};\****

​    ***\*}(\****i***\*));\****     **// Assign value of i to the local variable n**

  ***\*}\****

***\*}\****

***\*删除和替换节点\****

removeChild()方法是从文档树中删除一个节点。但是请小心:该方法不是在待删除的节点上调用，而是（就像其名字的一部分"child"所暗示的一样）在其父节点上调用。在父节点上调用该方法，并将需要删除的子节点作为方法参数传递给它。

replaceChild()方法删除一个子节点并用一个新的节点取而代之。在父节点上调用该方法，第一个参数是新节点，第二个参数是需要代替的节点。

**//用一个新的<b>元素替换n节点，并使n成为该元素的子节点**

***\*function\**** embolden***\*(\****n***\*)\**** ***\*{\**** 

 **//假如参数为字符串而不是节点，将其当做元素的id**

 ***\*if\**** ***\*(typeof\**** n ***\*==\**** **"string"\******)\**** n ***\*=\**** ***\*document\****.getElementById***\*(\****n***\*);\**** 

 ***\*var\**** ***\*parent\**** ***\*=\**** n.parentNode***\*;\**** **//获得n的父节点**

 ***\*var\**** b ***\*=\**** ***\*document\****.createElement***\*(\******"b"\******);\**** **//创建一个<b>元素**

 ***\*parent\****.replaceChild***\*(\****b***\*,\**** n***\*);\**** **//用该<b>元素替换节点n**

 b.appendChild***\*(\****n***\*);\**** **//使n成为<b>元素的子节点**

***\*}\****

***\*}());\****

***\*使用DocumentFragment\****

DocumentFragment是一种特殊的Node，它作为其他节点的一个临时的容器。创建方法：

var frag = document.createDocumentFragment();

像Document节点一样，DocumentFragment是独立的，而不是任何其他文档的一部分。它的parentNode总是为null。但类似Element，它可以有任意多的子节点。

DocumentFragment的特殊之处在于它使得一组节点被当做一个节点看待：如果给appendChild()、insertBefore() 或replaceChild()传递一个DocumentFragment，其实是将该文档片段的所有子节点插入到文档中，而非片段本身。（文档片段的子节点从片段移动到文档中，文档片段清空以便重用。）以下函数使用DocumentFragment来倒序排列一个节点的子节点:

**//倒序排列节点n的子节点**

***\*function\**** ***\*reverse\*******\*(\****n***\*)\**** ***\*{\**** 

 **//创建一个DocumentFragment作为临时容器**

 ***\*var\**** f ***\*=\**** ***\*document\****.createDocumentFragment***\*();\**** 

 **//从后至前循环子节点，将每一个子节点移动到文档片段中**

 **// n的最后一个节点变成f的第一个节点，反之亦然**

 **//注意，给f添加一个节点，该节点自动地会从n中删除**

 ***\*while\*******\*(\****n.lastChild***\*)\**** f.appendChild***\*(\****n.lastChild***\*);\**** 

 **//最后，把f的所有子节点一次性全部移回n中**

 n.appendChild***\*(\****f***\*);\****

***\*}\**** 

### ***\*文档和元素的几何形状和滚动\****

***\*文档坐标\*******\*和\*******\*视\*******\*口坐\*******\*标\****

元素的位置是以像素来度量的，向右代表X坐标的增加，向下代表Y坐标的增加。但是，有两个不同的点作为坐标系的原点：元素的X 和Y坐标可以相对于文档的左上角或者相对于在其中显示文档的视口的左上角。在顶级窗口和标签页中，“视口”只是实际显示文档内容的浏览器的一部分：它不包括浏览器“外壳”（如菜单、工具条和标签页）。针对框架页中显示的文档，视口是定义了框架页的<iframe>元素。无论在何种情况下，当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口坐标。（注意，视口坐标有时也叫做窗口坐标。）

如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角，文档和视口坐标系统是同一个。但是，一般来说，要在两种坐标系之间互相转换，必须加上或减去滚动的偏移量(scroll offset)。例如，在文档坐标中如果一个元素的Y坐标是200像素，并且用户已经把浏览器向下滚动75像素，那么视口坐标中元素的Y坐标是125像素。同样，在视口坐标中如果一个元素的X坐标是400像素，并且用户已经水平滚动了视口200像素，那么文档坐标中元素的X坐标是600像素。

文档坐标、比视口坐标更加基础，并且在用户滚动时它们不会发生变化。不过，在客户端编程中使用视口坐标是非常常见的。当使用CSS指定元素的位置时运用了文档坐标。但是，最简单的查询元素位置的方法返回视口坐标中的位置。类似地，当为鼠标事件注册事件处理程序函数时，报告的鼠标指针的坐标是在视口坐标系中的。

为了在坐标系之间互相转换，我们需要判定浏览器窗口的滚动条的位置。Window对象的pageXOffset和pageYOffset属性在所有的浏览器中提供这些值，除了IE8及更早的版本以外。IE（和所有现代浏览器）也可以通过scrollLeft和scrollTop属性来获得滚动条的位置。令人迷惑的是，正常情况下通过查询文档的根节点(document.documentElement)来获取这些属性值，但在怪异模式下，必须在文档的<body> 元素(document.body)上查询它们。

示例：查询窗口滚动条的位置

**// Return the current scrollbar offsets as the x and y properties of an object**

***\*function\**** getScrollOffsets***\*(\****w***\*)\**** ***\*{\****

  **// Use the specified window or the current window if no argument**

  w ***\*=\**** w ***\*||\**** ***\*window\*******\*;\****

  **// This works for all browsers except IE versions 8 and before**

  ***\*if\**** ***\*(\****w.***\*pageXOffset\**** ***\*!=\**** ***\*null\*******\*)\**** ***\*return\**** ***\*{\*******\*x\*******\*:\**** w.***\*pageXOffset\*******\*,\**** ***\*y\*******\*:\****w.***\*pageYOffset\*******\*};\****

  **// For IE (or any browser) in Standards mode**

  ***\*var\**** d ***\*=\**** w.***\*document\*******\*;\****

  ***\*if\**** ***\*(\*******\*document\****.compatMode ***\*==\**** **"CSS1Compat"\******)\****

​    ***\*return\**** ***\*{\*******\*x\*******\*:\****d.documentElement.scrollLeft***\*,\**** ***\*y\*******\*:\****d.documentElement.scrollTop***\*};\****

  **// For browsers in Quirks mode**

  ***\*return\**** ***\*{\**** ***\*x\*******\*:\**** d.body.scrollLeft***\*,\**** ***\*y\*******\*:\**** d.body.scrollTop ***\*};\****

***\*}\****

有时能够判定视口的尺寸也是非常有用的一一例如，为了确定文档的哪些部分是当前可见的。利用滚动偏移量查询视口尺寸的简单方法在IE8及更早的版本中无法工作，而且该技术在IE中的运行方式还要取决于浏览器是处于怪异模式还是标准模式。示例：查询窗口的视口尺寸

**// Return the viewport size as w and h properties of an object**

***\*function\**** getViewportSize***\*(\****w***\*)\**** ***\*{\****

  **// Use the specified window or the current window if no argument**

  w ***\*=\**** w ***\*||\**** ***\*window\*******\*;\**** 

  **// This works for all browsers except IE8 and before**

  ***\*if\**** ***\*(\****w.***\*innerWidth\**** ***\*!=\**** ***\*null\*******\*)\**** ***\*return\**** ***\*{\****w***\*:\**** w.***\*innerWidth\*******\*,\**** h***\*:\****w.***\*innerHeight\*******\*};\****

  **// For IE (or any browser) in Standards mode**

  ***\*var\**** d ***\*=\**** w.***\*document\*******\*;\****

***\*if\**** ***\*(\*******\*document\****.compatMode ***\*==\**** **"CSS1Compat"\******)\****    

***\*return\**** ***\*{\**** w***\*:\**** d.documentElement.clientWidth***\*,\**** h***\*:\**** d.documentElement.clientHeight ***\*};\****

  **// For browsers in Quirks mode**

  ***\*return\**** ***\*{\**** w***\*:\**** d.body.clientWidth***\*,\**** h***\*:\**** d.body.clientWidth ***\*};\****

***\*}\****

***\*查询元素的几何尺寸\****

判定一个元素的尺寸和位置最简单的方法是调用它的getBoundingClientRect()方法。它不需要参数，返回一个有left、right、top和bottom属性的对象。left和top属性表示元素的左上角的X和Y坐标，right和bottom属性表示元素的右下角的X和Y坐标。

这个方法返回元素在视口坐标中的位置。为了转化为甚至用户滚动浏览器窗口以后仍然有效的文档坐标，需要加上滚动的偏移量：

***\*var\**** box ***\*=\**** e.getBoundingClientRect***\*();\**** **//获得在视口坐标中的位置**

***\*var\**** offsets ***\*=\**** getScrollOffsets***\*();\**** **//上面定义的工具函数**

***\*var\**** ***\*x\**** ***\*=\**** box.***\*left\**** ***\*+\**** offsets.***\*x\*******\*;\**** **//转化为文档坐标**

***\*var\**** ***\*y\**** ***\*=\**** box.***\*top\**** ***\*+\**** offsets.***\*y\*******\*;\**** 

在很多浏览器（和W3C标准）中，getBoundingClientRect()返回的对象还包含width和height属性，但是在原始的IE中未实现。为了简便起见，可以这样计算元素的width和height:

***\*var\**** box ***\*=\**** e.getBoundingClientRect***\*();\**** 

***\*var\**** w ***\*=\**** box.***\*width\**** ***\*||\**** ***\*(\****box.***\*right\**** ***\*-\**** box.***\*left\*******\*);\**** 

***\*var\**** h ***\*=\**** box.***\*height\**** ***\*||\**** ***\*(\****box.***\*bottom\**** ***\*-\**** box.***\*top\*******\*);\**** 

元素内容被一块可选的空白区域所包围，叫做内边距。内边距被边框所包围，边框被外边距所包围。内边距、边框和外边距都是可选的。getBoundingClientRect()所返回的坐标包含元素的边框和内边距，但不包含元素的外边距。

浏览器在布局时块状元素（如图片、段落和<div>元素等）总是为矩形。但是，内联元素（如<span>、<code>和<b>等）可能跨了多行，因此可能由多个矩形组成。想象一下，例如，一些被断成两行的斜体文本（用*和*标签标记的）。它的形状是由第一行的右边部分和第二行的左边部分两个矩形组成的（假设文本顺序是从左向右）。如果在内联元素上调用getBoundingClientRect()，它返回“边界矩形”。对于如上描述的<i>元素，边界矩形会包含整整两行的宽度。

如果想查询内联元素每个独立的矩形，调用getClientRects()方法来获得一个只读的类数组对象，它的每个元素类似于getBoundingClientRect()返回的矩形对象。

getBoundingClientRect()和getClientRects()所返回的矩形对象（和矩形对象列表）并不是实时的。

***\*判定元素在\*******\*某点\****

Document对象的elementFromPoint()方法来判定视口中的指定位置上有什么元素。传递X和Y坐标（使用视口坐标而非文档坐标），该方法返回在指定位置的一个元素。该方法的意图就是它返回在那个点的最里面的和最上面的元素。如果指定的点在视口以外，elementFromPoint()返回null，即使该点在转换为文档坐标后是完美有效的，返回值也一样。

***\*滚动\****

Window对象的scrollTop()方法（和其同义词scroll()）接受一个点的X和Y坐标（文档坐标），并作为滚动条的偏移量设置它们。也就是，窗口滚动到指定的点出现在视口的左上角。如果指定的点太接近于文档的下边缘或右边缘，浏览器将尽量保证它和视口的左上角之间最近，但是无法达到一致。以下代码滚动浏览器到文档最下面的页面可见:

**//获得文档和视口的高度，offsetHeight会在下面解释**

***\*var\**** documentHeight ***\*=\**** ***\*document\****.documentElement.***\*offsetHeight\*******\*;\**** 

***\*var\**** viewportHeight ***\*=\**** ***\*window\****.***\*innerHeight\*******\*;\**** **//或使用上面的getViewportSize()**

**//然后，滚动让最后一页在视口中可见**

***\*window\****.***\*scrollTo\*******\*(\****0***\*,\**** documentHeight ***\*-\**** viewportHeight***\*);\**** 

Window的scrollBy()方法和scroll()和scrollTo()类似，但是它的参数是相对的，并在当前滚动条的偏移量上增加。例如，快速阅读者可能会喜欢这样的书签：

**//每200毫秒向下滚动10像素。注意，它无法关闭**

javascript***\*:\*******\*void\**** setInterval***\*(\*******\*function\*******\*()\**** ***\*{\*******\*scrollBy\*******\*(\*******\*0\*******\*,\*******\*10\*******\*)},\**** ***\*200\*******\*);\**** 

通常，除了滚动到文档中用数字表示的位置，我们只是想它滚动使得文档中的某个元素可见。可以利用getBoundingClientRect()计算元素的位置，并转换为文档坐标，然后用scrollTo()方法达到目的。但是在需要显示的HTML元素上调用scrollIntoView()方法更加方便。该方法保证了元素能在视口中可见。默认情况下，它试图将元素的上边缘放在或尽量接近视口的上边缘。如果只传递false作为参数，它试图将元素的下边缘放在或尽量接近视口的下边缘。只要有助于元素在视口内可见，浏览器也会水平滚动视口。

scrollIntoView()的行为与设置window.location.hash为一个命名锚点（<a name="">元素）的名字后浏览器产生的行为类似。

***\*元素\*******\*尺寸、位置\*******\*和\*******\*溢出的更多信息\****

getBoundingClientRect()方法在所有当前的浏览器上都有定义，但如果需要支持老式浏览器，不能依靠此方法而必须使用更老的技术来判定元素的尺寸和位置。元素的尺寸比较简单：任何HTML元素的只读属性offsetWidth和offsetHeight以CSS像素返回它的屏幕尺寸。返回的尺寸包含元素的边框和内边距，除去了外边距。

所有HTML元素拥有offsetLeft和offsetTop属性来返回元素的X和Y坐标。对于很多元素，这些值是文档坐标，并直接指定元素的位置。但对于己定位元素的后代元素和一些其他元素（如表格单元），这些属性返回的坐标是相对于祖先元素的而非文档。offsetParent属性指定这些属性所相对的父元素。如果offsetParent为null，这些属性都是文档坐标，因此，一般来说，用offsetLeft和offsetTop来计算元素e的位置需要一个循环:

***\*function\**** getElementPosition***\*(\****e***\*)\**** ***\*{\**** 

 ***\*var\**** ***\*x\**** ***\*=\**** ***\*0\*******\*,\**** ***\*y\**** ***\*=\**** ***\*0\*******\*;\**** 

 ***\*while\*******\*(\****e ***\*!=\**** ***\*null\*******\*)\**** ***\*{\**** 

  ***\*x\**** ***\*+=\**** e.***\*offsetLeft\*******\*;\**** 

  ***\*y\**** ***\*+=\**** e.***\*offsetTop\*******\*;\**** 

  e ***\*=\**** e.***\*offsetParent\*******\*;\**** 

 ***\*}\****

 ***\*return\**** ***\*{\*******\*x\*******\*:\*******\*x\*******\*,\**** ***\*y\*******\*:\*******\*y\*******\*};\****

***\*}\**** 

这里不能对元素的位置就一锤定音，尽管如此一一这个getElementPosition() 函数也不总是计算正确的值，下面看看如何来修复它。

除了这些名字以offset开头的属性以外，所有的文档元素定义了其他两组属性，其名称一组以client开头，另一组以scroll开头。

为了理解这些client和scroll属性，你需要知道HTML元素的实际内容有可能比分配用来容纳内容的盒子更大，因此单个元素可能有滚动条。内容区域是视口，就像浏览器的窗口，当实际内容比视口更大时，需要把元素的滚动条位置考虑进去。

clientWidth和clientHeight类似offsetWidth和offsetHeight。不同的是它们不包含边框大小，只包含内容和它的内边距。同时，如果浏览器在内边距和边框之间添加了滚动条，clientWidth和clientHeight在其返回值中也不包含滚动条。注意，对于类似<i>、<code>和<span>这些内联元素，clientWidth和clientHeight总是返回0。

上例方法中使用了clientWidth和clientHeight。有一个特殊的案例，在文档的根元素上查询这些属性时，它们的返回值和窗口的innerWidth和innerHeight属性值相等。

clientLeft和clientTop属性没什么用：它们返回元素的内边距的外边缘和它的边框的外边缘之间的水平距离和垂直距离，通常这些值就等于左边和上边的边框宽度。但是如果元素有滚动条，并且浏览器将这些滚动条放置在左侧或顶部（可这不太常见），clientLeft和clientTop也就包含了滚动条的宽度。对于内联元素，clientLeft和clientTop总是为0。

scrollWidth和scrollHeight是元素的内容区域加上它的内边距再加上任何溢出内容的尺寸。当内容正好和内容区域匹配而没有溢出时，这些属性与clientWidth和clientHeight是相等的。但当溢出时，它们就包含溢出的内容，返回值比clientWidth和clientHeight要大。

最后，scrollLeft和scrollTop指定元素的滚动条的位置。scrollLeft和scrollTop是可写的属性，通过设置它们来让元素中的内容滚动。

当文档包含可滚动的且有溢出内容的元素时，上述定义的getElementPosition()方法就不能正常工作了，因为它没有把滚动条考虑进去。这里有一个修改版，它从累计的偏移量中减去了滚动条的位置，这样一来，将返回的位置从文档坐标转换为视口坐标。

***\*function\**** getElementPos***\*(\****elt***\*)\**** ***\*{\**** 

 ***\*var\**** ***\*x\**** ***\*=\**** ***\*0\*******\*,\**** ***\*y\**** ***\*=\**** ***\*0\*******\*;\**** 

 **//循环以累加偏移量**

 ***\*for\*******\*(\*******\*var\**** e ***\*=\**** elt***\*;\**** e ***\*!=\**** ***\*null\*******\*;\**** e ***\*=\**** e.***\*offsetParent\*******\*)\**** ***\*{\**** 

  ***\*x\**** ***\*+=\**** e.***\*offsetLeft\*******\*;\**** 

  ***\*y\**** ***\*+=\**** e.***\*offsetTop\*******\*;\**** 

 ***\*}\**** 

 **//再次循环所有的祖先元素，减去滚动的偏移量**

 **//这也减去了主滚动条，并转换为视口坐标**

 ***\*for\*******\*(\*******\*var\**** e***\*=\****elt.parentNode***\*;\**** e ***\*!=\**** ***\*null\**** ***\*&&\**** e.nodeType ***\*==\**** ***\*1\*******\*;\**** e***\*=\****e.parentNode***\*)\**** ***\*{\**** 

  ***\*x\**** ***\*-=\**** e.scrollLeft***\*;\**** 

  ***\*y\**** ***\*-=\**** e.scrollTop***\*;\**** 

 ***\*}\****

 ***\*return\**** ***\*{\*******\*x\*******\*:\*******\*x\*******\*,\**** ***\*y\*******\*:\*******\*y\*******\*};\**** 

***\*}\****

实际类似jQuery这样的客户端类库包含了一些函数来计算元素的位置，它们扩充了这个基本的位置计算算法，修复了一系列浏览器特定的bug。

### ***\*HTML表单\****

 

### ***\*其它\*******\*文档特性\****

***\*Document的属性\****

l cookie：

l domain：该属性允许当Web页面之间交互时，相同域名下互相信任的Web服务器之间协作放宽同源策略安全限制

l lastModified：包含文档修改时间的字符串。

l location：与Window对象的location属性引用同一个Location对象。

l referrer：如果有，它表示浏览器导航到当前链接的上一个文档。该属性值和HTTP的Referer头信息的内容相同，只是拼写上有两个r。可以对特定URL跳转过来的页面进行处理

l title：文档的<title>和</title>标签之间的内容。

l URL：文档的URL。只读字符串而不是Location对象。该属性值与location.href的初始值相同，只是不包含Location对象的动态变化。

***\*document.write()方法\****

document.write()会将其字符串参数连接起来，然后将结果字符串插入到文档中调用它的脚本元素的位置。当脚本执行结束，浏览器解析生成的输出并显示它。

***\*查询选取的文本\****

有时判定用户在文档中选取了哪些文本非常有用。可以用类似如下的函数达到目的:

***\*function\**** getSelectedText(){

 ***\*if\****(Window.getSelection) //HTML5标准API

  ***\*return\**** window.getSelection().toString();

 ***\*else\**** ***\*if\****(document.selection) //IE特有的技术

  ***\*return\**** document.selection.createRange().text;  

}

标准的window.getSelection() 方法返回一个Selection对象，后者描述了当前选取的一系列一个或多个Range对象。Selection和Range定义了一个不太常用的较为复杂的API。toString() 方法是Selection对象中最重要的也广泛实现了（除了IE）的特性，它返回选取的纯文本内容。

IE定义了一个不同的API，它在本书中也没有文档记录。document.selection对象代表了用户的选择。该对象的createRange()方法返回IE特有的TextRange对象，它的text属性包含了选取的文本。

***\*可编辑的内容\****

跟随IE的脚步，所有当今的Web浏览器也支持简单的HTML编辑功能。

有两种方法来启用编辑功能。其一，设置任何标签的HTML contenteditable属性，其二，设置对应元素的JavaScript contenteditable属性；这都将使得元素的内容变成可编辑。当用户单击该元素的内容时就会出现插入光标，用户敲击键盘就可以插入其中。

浏览器可能为表单字段和contenteditable元素支持自动拼写检查。在支持该功能的浏览器中，检查可能默认开启或关闭。为元素添加spellcheck属性来显式开启拼写检查，而使用spellcheck=false来显式关闭该功能。

将Document对象的designMode属性设置为字符串"on"使得整个文档可编辑。（设置为"off"将恢复为只读文档。）designMode属性并没有对应的HTML属性。

浏览器定义了多项文本编辑命令，大部分没有键盘快捷键。为了执行这些命令，应该使用Document对象的execCommand()方法。

execCommand()所支持的命令通常是由工具栏上的按钮触发的。当要触发的命令不可用时，良好的UI会使对应的按钮无效。可以给document.queryCommandSupport()传递命令名来查询浏览器是否支持该命令。调用document.queryCommandEnabled()来查询当前所使用的命令。有一些命令如"bold" 和"italic" 有一个布尔值状态，开或关取决于当前选区或光标的位置。这些命令通常用工具栏上的开关按钮表示。要判定这些命令的当前状态可以使用document.queryCommandState()。最后，有些命令（如"fontname"）有一个相关联的值（字体系列名）。用document.queryCommandValue()查询该值。如果当前选取的文本使用了两种不同的字体，"fontname" 的查询结果是不确定的。使用document.queryCommandIndeterm() 来检测这种情况。

​	一旦用户编辑了某元素的内容，该元素设置了conteneditable属性，就可以使用innerHTML属性得到己编辑内容的HTML标记。

​	互操作命令列表：http://www.quirksmode.org/dom/execCommand.html

 

***\*脚本化css\****

### ***\*文本样式\****

脚本化CSS最直截了当的方法就是更改单独的文档元素的style属性。类似大多数HTML属性，style也是元素对象的属性，它可以在JavaScript中操作。但是style属性不同寻常：它的值不是字符串，而是一个CSSStyleDeclaration对象。该style对象的JavaScript属性代表了HTML代码中通过style指定的CSS属性。

很多CSS样式属性（如font-size）在名字中包含连字符。在JavaScript 中，连字符是减号，所以不能直接书写。因此，CSSStyleDeclaration对象中的属性名和实际的CSS属性名有所区别。如果一个CSS 属性名包含一个或多个连字符，CSSStyleDeclaration属性名的格式应该是移除连字符，将每个连字符后面紧接着的字母大写。

另外，当一个CSS 属性（如float属性）在JavaScript 中对应的名字是保留字时，在之前加"css"前缀来创建合法的CSSStyleDeclaration名字。由此，使用CSSStyleDeclaration对象的css Float属性来设直或查询元素的CSS float属性。记住所有的值都应该是字符串，所有的定位属性都需要包含单位。

HTML元素的style属性是它的内联样式，它覆盖在样式表中的任何样式说明。

读取元素的内联样式特别困难，对style属性来说须包含单位，对复合属性来说：在真正使用这些值的时候，代码不得不包含非同寻常的CSS 解析能力。总之，元素的内联样式只在设置样式的时候有用，如果需要查询元素的样式，就要使用计算样式。

有时，发现作为单个字符串值来设置或查询元素的内联样式反而比作为CSSStyleDeclaration对象更加简单。为此，可以使用元素的getAttribute()和setAttribute()方法或CSSStyleDeclaration对象的cssText属性来实现：

//两者都可设置e的样式属性为字符串s

e.setAttribute("style", s);

e.style.cssText = s;

 

//两者都可查询元素的内联样式

s = e.getAttribute("style");

s = e.style.cssText;

### ***\*CSS\*******\*动画\****

脚本化的CSS 最常见的用途之一是产生视觉动画效果。使用setTimeout() 或setInterval()重复调用函数来修改元素的内联样式达到目的。

### ***\*计算\*******\*样式\****

元素的计算样式是一组属性值，它由浏览器通过把

内联样式结合所有链接样式表中所有可应用的样式规则后导出(或计算)得到的:

它就是一组在显示元素时实际使用的属性值。类似内联样式，计算样式也是用一个

CSSStyleDeclaration对象来表示的，区别是，计算样式是只读的。虽然不能设置这些样式，但为元素计算出的CSSStyleDeclaration对象确切地决定了浏览器在渲染元素时使用的样式属性值。

用浏览器窗口对象的getComputedStyle()方法来获得一个元素的计算样式。此方法的第一个参数就是要获取其计算样式的元素，第二个参数也是必需的，通常是null或空字符串，但它也可以是命名CSS伪对象的字符串，如":before"、":after"、":first-line"或":first-letter"。

***\*var\**** title = document.getElementById("section1title");

***\*var\**** titlestyles = window.getComputedStyle(element, ***\*null\****);

getComputedStyle()方法的返回值是一个CSSStyleDeclaration对象，它代表了应用在指定元素（或伪对象）上的所有样式。表示计算样式的CSSStyleDeclaration对象和表示内联样式的对象之间有一些重要的区别：

l 计算样式的属性是只读的。

l 计算样式的值是绝对值：类似百分比和点之类相对的单位将全部转换为绝对值。所有指定尺寸（例如外边距大小和字体大小）的属性都有一个以像素为度量单位的值。该值将是一个冠以"px"后缀的字符串，使用时仍然需要解析它，但是不用担心单位的解析或转换。其值是颜色的属性将以"rgb(#,#,#)"或"rgba(#,#,#,#)"的格式返回。

l 不计算复合属性，它们只基于最基础的属性。例如，不要查询margin属性，应该使用marginLeft和marginTop等。

l 计算样式的cssText属性未定义。

### ***\*脚本化\*******\*css\*******\*类\****

HTML5为每个元素定义了classList属性。该属性值是DOMTokenList对象：一个只读的类数组对象，它包含元素的单独类名。但是，和数组元素相比，DOMTokenList定义的方法更加重要。add()和remove()从元素的class属性中添加和清除一个类名。toggle()表示如果不存在类名就添加一个，否则，删除它。最后，contains()方法检测class属性中是否包含一个指定的类名。

类似其他DOM集合类型，DOMTokenList对象“实时地”代表了元素类名集合，而并非是在查询classList属性时类名的一个静态快照。如果从元素的classList属性中获得了一个DOMTokenList对象，然后元素的className属性改变了，这些变化在标识列表中及时可见。同样，改变标识列表，在className属性中及时可见。

### ***\*脚本化\*******\*样式表\****

在脚本化样式表时，将会碰到两类需要使用的对象。第一类是元素对象，由<style>和<link>元素表示，两种元素包含或引用样式表。这些是常规的文档元素，如果它们有id属性值，可以用document.getElementByld()函数来选择它们。第二类是CSSStyleSheet对象，它表示样式表本身。document.styleSheets属性是一个只读的类数组对象，它包含CSSStyleSheet对象，表示与文档关联在一起的样式表。如果为定义或引用了样式表的<style>或<link>元素设置title属性值，该title作为对应CSSStyleSheet对象的title属性就可用。

***\*开启和关闭样式表\****

最简单的脚本化样式表的技术也是最便捷和健壮的。<style>、<link>元素和CSSStyleSheet对象都定义了一个在JavaScript中可以设置和查询的disabled属性。顾名思义，如果disabled属性为true，样式表就被浏览器关闭并忽略。

***\*查询、插入与删除样式表规则\****

直接操作样式表通常没什么意义。典型地，相对编辑样式表或增加新规则而言，让样式表保持静态并对元素的className属性编程更好。另一方面，如果允许用户完全控制页面上的样式，可能就需要动态操作样式表。

document.style5heets[] 数组的元素是CSSStyleSheet对象。CSSStyleSheet对象有一个cssRules[] 数组，它包含样式表的所有规则：

***\*var\**** firstRule = document.styleSheets[0].cssRules[0];

IE 使用不同的属性名rules代替cssRules。

cssRules[] 或rules[] 数组的元素为CSSRule对象。在标准API 中，CSSRule对象代表所有CSS规则，包含如@import和@page等指令。但是，在IE 中，rules[] 数组只包含样式表中实际存在的样式规则。

CSSRule对象有两个属性可以很便捷地使用。selectText是规则的CSS选择器，它引用一个描述与选择器相关联的样式的可写CSSStyleDeclaration对象。回想一下，CSSStyleDeclaration是用来表示内联和计算样式的相同类型。可以利用它来查询规则的样式值或设置新样式。通常，当遍历样式表时，你对规则的文本比它解析后的表示形式更感兴趣。此时，使用CSSStyleDeclaration对象的cssText属性来获得规则的文本表示形式。

除了查询和修改样式表中己存在的规则以外，也能向样式表添加和从中删除规则。标准的API接口定义了insertRule ()和deleteRule()方法来添加和删除规则：

document.styleSheet[0].insertRule("H1 { text-weight:bold; }", 0);

IE不支持insertRule() 和deleteRule()，但定义了大致等效的函数addRule() 和removeRule()。（除了名字以外）仅有的不同是addRule()希望选择器文本和样式文本作为两个参数。

以下代码遍历样式表的规则，举例说明了用API对样式表进行一些可疑的修改：

***\*var\**** ss = document.styleSheets[0]; //得到第一个样式表

***\*var\**** rules = ss.cssRules?ss.cssRules:ss.rules; //得到样式表规则

***\*for\****(***\*var\**** i = 0; i < rules.length; i++) { //遍历这些规则

 ***\*var\**** rule = rules[i];

 ***\*if\**** (!rule.selectorText) ***\*continue\****; //跳过@import和非样式规则

 

 ***\*var\**** selector = rule.selectorText; //选择器

 ***\*var\**** ruleText = rule.style.cssText; //文本形式的样式

 //如果规则应用在h1元素上，也将其应用到h2元素上

 //注意：仅当选择器在字面上为"h1"时这才起作用

 ***\*if\**** (selector == "h1") {

  ***\*if\**** (ss.insertRule) ss.insertRule("h2 {" + ruleText + "}", rules.length);

  ***\*else\**** ***\*if\**** (ss.addRule) ss.addRule("h2", ruleText, rules.length);

 }

 //如果规则设置了text-decoration属性，则将其删除

 ***\*if\**** (rule.style.textDecoration) {

  ***\*if\**** (ss.deleteRule) ss.deleteRule(i);

  ***\*else\**** ***\*if\**** (ss.removeRule) ss.removeRule(i);

  i--; //调整循环索引，因为以上的规则i+1现在即为规则i

 }

}

***\*创建新样式表\****

最后，创建整个新样式表并将其添加到文档是中可能的。在大多数浏览器中，可以用标准的DOM技术：只要创建一个全新的<style>元素，将其插入到文档的头部，然后用其innerHTML属性来设置样式表内容。但是在IE 8以及更早版本中，CSSStyleSheet对象通过非标准方法document.createStyleSheet()来创建，其样式文本用cssText属性值来指定。

 

 

 

 

 

 

***\*事件处理\****

客户端JavaScript程序采用了异步事件驱动编程模型。

事件类型(event type) 是一个用来说明发生什么类型事件的字符串。

事件目标(event target) 是发生的事件或与之相关的对象。

事件处理程序 (event handler) 或事件监听程序 (event listener) 是处理或响应事件的函数。当对象上注册的事件处理程序被调用时，我们有时会说浏览器“触发”(fire、trigger) 和“派发”(dispatch)了事件。

事件对象 (event object) 是与特定事件相关且包含有关该事件详细信息的对象。事件对象作为参数传递给事件处理程序函数（不包括IE8及之前版本，在这些浏览器中有时仅能通过全局变量event才能得到）。所有的事件对象都有用来指定事件类型的type属性和指定事件目标的target属性。（在IE8及之前版本中用srcElement而非target。）

事件传播 (event propagation) 是浏览器决定哪个对象触发其事件处理程序的过程。对于单个对象的特定事件（比如Window对象的load事件），必须是不能传播的。当文档元素上发生某个类型的事件时，它们会在文档树上向上传播或“冒泡”(bubble)。

事件传播的另外一种形式称为事件捕获 (event capturing)，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前拦截（或“捕获”）它。IE8及之前版本不支持事件捕获，所以不常用它。但是，当处理鼠标、拖放事件时，捕获或“夺取”鼠标事件的能力是必需的。

事件处理程序可以通过返回一个适当的值、调用事件对象的某个方法或设置事件对象的某个属性来阻止默认操作的发生。这有时称为“取消”事件。

### ***\*事件类型\****

 

***\*传统事件类型\****

***\*1\*******\*、表单\*******\*事件\****

当提交表单和重置表单时，<form>元素会分别触发submit和reset事件。当用户和类按钮表单元素（包括单选按钮和复选框）交互时，它们会发生click事件。当用户通过输入文字、选择选项或选择复选框来改变相应表单元素的状态时，这些通常维护某种状态的表单元素会触发change事件。对于文本输入域，只有用户和表单元素完成交互并通过Tab键或单击的方式移动焦点到其他元素上时才会触发change事件。响应通过键盘改变焦点的表单元素在得到和失去焦点时会分别触发focus和blur事件。

通过事件处理程序能取消submit和reset事件的默认操作，某些click事件也是如此。focus和blur事件不会冒泡，但其他所有表单事件都可以。IE定义了focusin和focusout事件可以冒泡，它们可以用于替代foucs和blur事件。jQuery库为不支持focusin和focusout事件的浏览器模拟了这两个事件，同时3级DOM事件规范也正在标准化它们。

最后注意，无论用户何时输入文字（通过键盘或剪切和粘帖）到<textarea>和其他文本输入表单元素，除IE外的浏览器都会触发input事件。不像change事件，每次文字插入都会触发input事件。遗憾的是，input事件的事件对象没有指定输入文本的内容。

***\*2、\*******\*Window事件\****

Window事件是指事件的发生与浏览器窗口本身而非窗口中显示的任何特定文档内容相关。但是，这些事件中有一些会和文档元素上发生的事件同名。

load 事件是这些事件中最重要的一个，当文档和其所有外部资源（比如图片）完全加载并显示给用户时就会触发它。DOMContentLoaded和readystatechange是load事件的替代方案，当文档和其元素为操作准备就绪，但外部资源完全加载完毕之前，浏览器就会尽早触发它们。

unload事件和load相对，当用户离开当前文档转向其他文档时会触发它。unload事件处理程序可以用于保存用户的状态，但它不能用于取消用户转向其他地方。beforeunload事件和unload类似，但它能提供询问用户是否确定离开当前页面的机会。如果beforeunload的处理程序返回字符串，那么在新页面加载之前，字符串会出现在展示给用户确认的对话框上，这样用户将有机会取消其跳转而留在当前页上。

像<img>元素这样的单个文档元素也能为load和error事件注册处理程序。当外部资源（例如图片）完全加载或发生阻止加载的错误时就会触发它们。某些浏览器也支持abort事件（HTML5将其标准化），当图片（或其他网络资源）因为用户停止加载进程而导致失败就会触发它。

前面介绍的表单元素的focus和blur事件也能用做Window事件，当浏览器窗口从操作系统中得到或失去键盘焦点时会触发它们。

最后，当用户调整浏览器窗口大小或滚动它时会触发resize和scroll事件。scroll事件也能在任何可以滚动的文档元素上触发，比如那些设置CSS 的overflow属性的元素。传递给resize和scroll事件处理程序的事件对象是一个非常普通的Event对象，它没有指定调整大小或发生滚动的详细信息属性，但可以通过[上面](#_文档和元素的几何形状和滚动)介绍的技术来确定新窗口的尺寸和滚动条的位置。

***\*3、\*******\*鼠标事件\****

当用户在文档上移动或单击鼠标时都会产生鼠标事件。这些事件在鼠标指针所对应的最深嵌套元素上触发，但它们会冒泡直到文档最顶层。传递给鼠标事件处理程序的事件对象有属性集，它们描述了当事件发生时鼠标的位置和按键状态，也指明当时是否有任何辅助键接下。clientX和clientY属性指定了鼠标在窗口坐标中的位置，button和which属性指定了按下的鼠标键是哪个。当键盘辅助键按下肘，对应的属性altkey、ctrlKey、metaKey和shiftKey会设置为true。而对于click事件，detail属性指定了其是单击、双击还是三击。

用户每次移动或拖动鼠标肘，会触发mousemove事件。这些事件的发生非常频繁，所以mousemove事件处理程序一定不能触发计算密集型任务。当用户按下或释放鼠标按键时，会触发mousedown和mouseup事件。通过注册mousedown和mousemove事件处理程序，可以探测和响应鼠标的拖动。合理地这样做能够捕获鼠标事件，甚至当鼠标从开始元素移出时我们都能持续地接受到mousemove事件。

在mousedown和mouseup事件队列之后，浏览器也会触发click事件。之前介绍过click事件是独立于设备的表单事件，但实际上它不仅仅在表单元素上触发，它可以在任何文档元素上触发，同时传递拥有之前介绍的所有鼠标相关额外字段的事件对象。如果用户在相当短的时间内连续两次单击鼠标按键，跟在第二个click事件之后是dblclick事件。当单击鼠标右键时，浏览器通常会显示上下文菜单(context menu)。在显示菜单之前，它们通常会触发contextmenu事件，而取消这个事件就可以阻止菜单的显示。这个事件也是获得鼠标右击通知的简单方法。

当用户移动鼠标指针从而使它悬停到新元素上肘，浏览器就会在该元素上触发mouseover事件。当鼠标移动指针从而使它不再悬停在某个元素上肘，浏览器就会在该元素上触发mouseout事件。对于这些事件，事件对象将有relatedTarget属性指明这个过程涉及的其他元素。mouseover和mouseout事件和这里介绍的所有鼠标事件一样会冒泡。但这通常不方便，因为当触发mouseout事件处理程序时，你不得不检查鼠标是否真的离开目标元素还是仅仅是从这个元素的一个子元素移动到另一个。正因为如此，IE提供了这些事件的不冒泡版本mouseenter和mouseleave。JQuery模拟非IE的浏览器中这些事件的支持，同时3级DOM事件规范把它们标准化了。

当用户滚动鼠标滚轮时，浏览器触发mousewheel事件（或在Firefox 中是DOMMouseScroll事件）。传递的事件对象属性指定滚轮转动的大小和方向。3级DOM事件规范正在标准化一个更通用的多维wheel事件，一且实现将取代mousewheel 和DOMMouseScroll事件。

***\*4、\*******\*键盘事件\****

当键盘聚焦到Web浏览器时，用户每次按下或释放键盘上的按键时都会产生事件。键盘快捷键对于操作系统和浏览器本身有特殊意义，它们经常被操作系统或浏览器“吃掉”并对JavaScript事件处理程序不可见。无论任何文档元素获取键盘焦点都会触发键盘事件，并且它们会冒泡到Document和Window对象。如果没有元素获得焦点，可以直接在文档上触发事件。传递给键盘事件处理程序的事件对象有keyCode字段，它指定按下或释放的键是哪个。除了keyCode，键盘事件对象也有altKey、ctrlKey、metaKey和shiftKey，描述键盘辅助键的状态。

keydown和keyup事件是低级键盘事件，无论何时按下或释放按键（甚至是辅助键）都会触发它们。当keydown事件产生可打印字符时，在keydown和keyup之间会触发另外一个keypress事件。当按下键重复产生字符时，在keyup事件之前可能产生很多keypress事件。keypress是较高级的文本事件，其事件对象指定产生的字符而非按下的键。

所有浏览器都支持keydown、keyup和keypress事件，但有一些互用性问题，因为事件对象的keyCode属性值从未标准化过。3级DOM事件规范尝试解决之前的互用性问题，但尚未实施。

***\*DOM事件\****

3 级DOM事件规范标准化了不冒泡的focusin 和focusout事件来取代冒泡的focus和blur事件，标准化了冒泡的mouseenter和mouseleave事件来取代不冒泡的mouseover和mouseout事件。

wheel事件的处理程序接收到的事件对象除了所有普通鼠标事件属性，还有deltaX、deltaY和deltaZ属性来报告三个不同的鼠标滚轴。

3级DOM事件规范定义了keypress事件，但不赞成使用它而使用称为textinput的新事件。传递给textinput事件处理程序的事件对象不再有难以使用的数字keyCode属性值，而有指定输入文本字符串的data属性。textinput事件不是键盘特定事件，无论通过键盘、剪切和粘贴、拖放等方式，每当发生文本输入时就会触发它。规范定义了事件对象的inputMethod属性和一组代表各种文本输入种类的常量（键盘、粘贴、拖放、手写和语音识别等）。

新DOM标准通过在事件对象中加入新的key和char属性来简化keydown、keyup和keypress事件，这些属性都是字符串。对于产生可打印字符的键盘事件，key和char值将等于生成的文本。对于控制键，key属性将会是像标识键的"Enter"、"Delete"和 "Left" 这样的字符串，而char属性将是null，或对于像Tab这样的控制键有一个字符编码，它将是按键产生的字符串。

***\*HTML5\*******\*事件\****

 

***\*触摸屏和移动设备事件\****

Safari产生的手势事件用于两个手指的缩放和旋转手势。当手势开始时生成gesturestart事件，而手势结束时生成gestureend 事件。在这两个事件之间是跟踪手势过程的gesturechange事件队列。这些事件传递的事件对象有数字属性scale和rotation。scale属性是两个手指之间当前距离和初始距离的比值。“捏紧”手势的scale值小于1. 0，而“撑开”手势的scale值大于1.0。rotation属性是指从事件开始手指旋转的角度，它以度为单位，正值表示按照顺时针方向旋转。

手势事件是高级事件，用于通知已经翻译的手势。如果想实现自定义手势，你可以监听低级触摸事件。当手指触摸屏幕时会触发touchstart事件，当手指移动时会触发touchmove事件，而当手指离开屏幕时会触发touchend事件。不像鼠标事件，触摸事件并不直接报告触摸的坐标。相反，触摸事件传递的事件对象有一个changedTouches属性，该属性是一个类数组对象，其每个元素都描述触摸的位置。

当设备允许用户从竖屏旋转到横屏模式时会在Window对象上触发orientationchanged事件，该事件传递的事件对象本身没有用。但是，在移动版的Safari 中，Window对象的orientation属性能给出当前方位，其值是0、90、180或-90。

### ***\*注册事件处理程序\****

注册事件处理程序有两种基本方式。第一种方式出现在Web初期，给事件目标对象或文档元素设置属性。第二种方式更新并且更通用，是将事件处理程序传递给对象或元素的一个方法。但复杂的是，每种技术都有两个版本。可以在JavaScript代码中设置事件处理程序为对象属性，或对于文档元素，可以在HTML中直接设置相应属性。对于通过方法调用的处理程序注册，有一个标准方法，命名为addEventListener()，除IE8及以前版本之外，所有浏览器都支持这种方式，而且9之前的IE版本支持的是一个叫attachEvent()的不同方法。

***\*设置\*******\*JavaScript\*******\*对象属性为事件处理程序\****

注册事件处理程序最简单的方式就是通过设置事件目标的属性为所需事件处理程序函数。按照约定，事件处理程序属性的名字由"on"后面跟着事件名组成：这些属性名是区分大小写的，所有都是小写，即使事件类型是由多个词组成。

事件处理程序属性的缺点是其设计都是围绕着假设每个事件目标对于每种事件类型将最多只有一个处理程序。如果想编写能够在任意文档中都能使用的脚本库代码，更好的方式是使用一种不修改或覆盖任何已有注册处理程序的技术。

***\*设置\*******\*HTML\*******\*标签属性为事件处理程序\****

用于设置的文档元素事件处理程序属性(property)也能换成对应HTML标签的属性(attribute)。如果这样做，属性值应该是JavaScript代码字符串。这段代码应该是事件处理程序函数的主体，而非完整的函数声明。也就是说，HTML事件处理程序代码不应该用大括号包围且使用function关键字作为前缀。例如：

<button ***\*onclick=\****"alert('Thank you')***\*;\****"***\*>\****点击这里</button>

如果HTML事件处理程序属性包含多条JavaScript语句，要记住必须使用分号分隔这些语句或断开属性值使其跨多行。

客户端编程的通用风格是保持HTML 内容和JavaScript行为分离，遵循这条规则的程序员应禁止（或至少避免）使用HTML事件处理程序属性，因为这些属性直接混合了JavaScript和HTML。

***\*add\*******\*EventListener()\****

在除IE8及之前版本外的所有浏览器都支持的标准事件模型中，任何能成为事件目标的对象都定义了一个名叫addEventListener()的方法，使用这个方法可以为事件目标注册事件处理程序。

addEventListener()接受三个参数。

第一个是要注册处理程序的事件类型，这个事件类型（或名字）是字符串，但它不应该包括用于设置事件处理程序属性的前缀"on"。

第二个参数是当指定类型的事件发生时应该调用的函数。

最后一个参数是布尔值。通常情况下，会给这个参数传递false。如果相反传递了true ，那么函数将注册为捕获事件处理程序，并在事件不同的调度阶段调用。

下面这段代码在<button>元素上注册了click事件的两个处理程序。注意所用两个技术之间的不同:

<button ***\*id\*******\*=\******"mybutton"\******>\*******\*click\**** me***\*</\****button> 

<script> 

 ***\*var\**** b ***\*=\**** ***\*document\****.getElementById***\*(\******"mybutton"\******);\**** 

 b.***\*onclick\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*alert\*******\*(\******"Thanks for clicking me!"\******);\**** ***\*};\**** 

 b.addEventListener***\*(\******"click"\******,\**** ***\*function\*******\*()\**** ***\*{\**** ***\*alert\*******\*(\******"Thanks again!"\******);\**** ***\*},\**** ***\*false\*******\*);\**** 

***\*</\****script> 

用 "click" 作为第一个参数调用addEventListener()不会影响onclick属性的值，在前面的代码中单击按钮会产生两个alert() 对话框。能通过多次调用addEventListener() 为同一个对象注册同一事件类型的多个处理程序函数。当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。使用相同的参数在同一个对象上多次调用addEventListener()是没用的，处理程序仍然只注册一次，同时重复调用也不会改变调用处理程序的顺序。

相对addEventListener() 的是removeEventListener() 方法，它同样有三个参数，从对象中删除事件处理程序函数而非添加，它常用于临时注册事件处理程序，然后不久就删除它。

***\*attach\*******\*Event()\****

IE9之前的IE不支持addEventListener() 和removeEventListener()，但是定义了类似的方法attachEvent()和detachEvent()，它们的异同点如下：

l 不支持事件捕获

l 使用带 "on" 前缀的事件处理程序属性名

l 允许相同的事件处理程序函数注册多次，当特定的事件类型发生时，注册函数的调用次数和注册次数一样。

经常可以看到的事件处理程序注册代码是在支持addEventListener() 的浏览器中就调用它，否则就用attachEvent()：

***\*var\**** b ***\*=\**** ***\*document\****.getE1ementByld***\*(\******"mybutton"\******);\**** 

***\*var\**** handler ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** ***\*alert\*******\*(\******"Thanks!"\******);\**** ***\*};\**** 

***\*if\**** ***\*(\****b.addEventListener***\*)\**** 

 b.addEventListener***\*(\******"click"\******,\**** handler***\*,\**** ***\*false\*******\*);\**** 

***\*else\**** ***\*if\**** ***\*(\****b.attachEvent***\*)\**** 

 b.attachEvent***\*(\******"onclick"\******,\**** handler***\*);\**** 

### ***\*事件处理程序的调用\****

***\*事件处理程序的参数\****

通常调用事件处理程序时把事件对象作为它们的一个参数。事件对象的属性提供了有关事件的详细信息。

在IE8及以前版本中，通过设置属性注册事件处理程序，当调用它们时并未传递事件对象。取而代之，需要通过全局对象window.event来获得事件对象。

出于互通性，你能像如下那样编写事件处理程序：

***\*function\**** handler***\*(\*******\*event\*******\*)\**** ***\*{\**** 

 ***\*event\**** ***\*=\**** ***\*event\**** ***\*||\**** ***\*window\****.***\*event\*******\*;\**** 

 **//处理程序代码出现在这里**

***\*}\****

***\*事件处理程序的运行环境\****

当通过设置属性注册事件处理程序时，甚至当使用addEventListener()注册时，调用的处理程序使用事件目标作为它们的this值。但是，对于attachEvent()来讲这是不对的。使用attachEvent()注册的处理程序作为函数调用，它们的this值是全局 (Window) 对象。可以用如下代码来解决这个问题：

**/\*** 

 ***在指定的事件目标上注册用于处理指定类型事件的指定处理程序函数**

 ***确保处理程序一直作为事件目标的方法调用**

***/** 

***\*function\**** addEvent***\*(\*******\*target\*******\*,\**** ***\*type\*******\*,\**** handler***\*)\**** ***\*{\**** 

 ***\*if\**** ***\*(\*******\*target\****.addEventListener***\*)\**** 

  ***\*target\****.addEventListener***\*(\*******\*type\*******\*,\**** handler***\*,\**** ***\*false\*******\*);\**** 

 ***\*else\**** 

  ***\*target\****.attachEvent***\*(\******"on"** ***\*+\**** ***\*type\*******\*,\**** 

​           ***\*function\*******\*(\*******\*event\*******\*)\**** ***\*{\**** 

​            **//把处理程序作为事件目标的方能调用，**

​            **//传递事件对象**

​            ***\*return\**** handler.***\*call\*******\*(\*******\*target\*******\*,\**** ***\*event\*******\*);\**** 

​           ***\*});\**** 

***\*}\****

注意使用这个方法注册的事件处理程序不能删除，因为传递给attachEvent()的包装函数没有保留下来传递给detachEvent()。

***\*事件处理程序的作用域\****

像所有的JavaScript函数一样，事件处理程序也是词法作用域。它们在其定义时的作用域而非调用时的作用域中执行，并且它们能存取那个作用域中的任何一个本地变量。例如，之前的addEvent() 函数就证明过。

但是，通过HTML属性来注册事件处理程序是一个例外。它们被转换为能存取全局变量的顶级函数而非任何本地变量。但因为历史原因，它们运行在一个修改后的作用域链中。通过HTML属性定义的事件处理程序能好像本地变量一样使用目标对象、容器<form>对象（如果有）和Document对象的属性。所以，调用时需要写上事件主体。

***\*事件处理程序的返回值\****

通过设置对象属性或HTML属性注册事件处理程序的返回值有时是非常有意义的。通常情况下，返回值false就是告诉浏览器不要执行这个事件相关的默认操作。例如，表单提交按钮的onclick事件处理程序能返回false阻止浏览器提交表单。（当用户的输入在客户端验证失败肘，这是有用的。）类似地，如果用户输入不合适的字符，输入域上的onkeypress事件处理程序能通过返回false来过滤、键盘输入。

Window对象的onbeforeunload事件处理程序的返回值也非常有意义。当浏览器将要跳转到新页面时触发这个事件。如果事件处理程序返回一个字符串，那么它将出现在询问用户是否想离开当前页面的标准对话框中。

理解事件处理程序的返回值只对通过属性注册的处理程序才有意义这非常重要。接下来我们将看到使用addEventListener() 或attachEvent() 注册事件处理程序转而必须调用preventDefault()方法或设置事件对象的returnValue属性。

***\*调用顺序\****

文档元素或其他对象可以为指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照如下规则调用所有的事件处理程序:

n 通过设置对象属性或HTML属性注册的处理程序一直优先调用。

n 使用addEventListener()注册的处理程序按照它们的注册顺序调用。

n 使用attachEvent()注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。

***\*事件传播\****

当事件目标是Window对象或其他一些单独对象（比如XMLHttpRequest）时，浏览器简单地通过调用对象上适当的处理程序响应事件。

当事件目标是文档或文档元素时，在调用在目标元素上注册的事件处理函数后，大部分事件会“冒泡”到DOM树根。调用目标的父元素的事件处理程序，然后调用在目标的祖父元素上注册的事件处理程序。这会一直到Document对象，最后到达Window对象。事件冒泡为在大量单独文档元素上注册处理程序提供了替代方案，即在共同的祖先元素上注册一个处理程序来处理所有的事件。例如，可以在<form>元素上注册 "change" 事件处理程序来取代在表单的每个元素上注册 "change" 事件处理程序。

发生在文档元素上的大部分事件都会冒泡，值得注意的例外是focus、blur和scroll事件。文档元素上的load事件会冒泡，但它会在Document对象上停止冒泡而不会传播到Window对象。只有当整个文档都加载完毕时才会触发Window对象的load事件。

事件冒泡是事件传播的第三个“阶段”。目标对象本身的事件处理程序调用是第二个阶段。第一个阶段甚至发生在目标处理程序调用之前，称为“捕获”阶段。之前addEventListener()把一个布尔值作为其第三个参数。如果这个参数是true。那么事件处理程序被注册为捕获事件处理程序，它会在事件传播的第一个阶段调用。事件冒泡得到广泛的支持，它能用在包括IE在内的所有浏览器中，且无论事件处理程序用哪种方式注册（除非它们被注册为捕获事件处理程序）。而事件捕获只能用于以addEventListener()注册且第三个参数是true的事件处理程序中。这意味着事件捕获无法在IE9之前的IE中使用。

事件传播的捕获阶段像反向的冒泡阶段，最先调用Window对象的捕获处理程序，然后是Document对象的捕获处理程序，接着是body对象的，再然后是DOM树向下，以此类推，直到调用事件目标的父元素的捕获事件处理程序。在目标对象本身上注册的捕获事件处理程序不会被调用。

事件捕获提供了在事件没有送达目标之前查看它们的机会。事件捕获能用于程序调试，或用于后面介绍的事件取消技术，过滤掉事件从而使目标事件处理程序绝不会被调用。事件捕获常用于处理鼠标拖放，因为要处理拖放事件的位置不能是这个元素内部的子元素。

***\*事件取消\****

用属性注册的事件处理程序的返回值能用于取消事件的浏览器默认操作。在支持addEventListener()的浏览器中，也能通过调用事件对象的preventDefault()方法取消事件的默认操作。不过，在IE9 之前的IE 中，可以通过设置事件对象的returnValue属性为false来达到同样的效果。下面的代码假设一个事件处理程序，它使用全部三种取消技术：

***\*function\**** cancelHandler***\*(\*******\*event\*******\*)\**** ***\*{\**** 

 ***\*var\**** ***\*event\**** ***\*=\**** ***\*event\**** ***\*||\**** ***\*window\****.***\*event\*******\*;\**** **//用于IE**

 **/\*这里是处理事件的代码\*/**

 **//现在取消事件相关的默认行为**

 ***\*if\**** ***\*(\*******\*event\****.preventDefault***\*)\**** ***\*event\****.preventDefault***\*();\**** **//标准技术**

 ***\*if\**** ***\*(\*******\*event\****.***\*returnValue\*******\*)\**** ***\*event\****.***\*returnValue\**** ***\*=\**** ***\*false\*******\*;\**** **// IE** 

 ***\*return\**** ***\*false\*******\*;\**** **//用于处理使用对象属性注册的处理程序**

***\*}\****

当前的DOM事件模型草案定义了Event对象属性defaultPrevented。它尚未得到广泛支持，但其目的是常态下这个属性是false。但如果preventDefaut()被调用则它将变成true。

取消事件相关的默认操作只是事件取消中的一种，我们也能取消事件传播。在支持addEventListener()的浏览器中，可以调用事件对象的一个stopPropagation()方法以阻止事件的继续传播。如果在同一对象上定义了其他处理程序，剩下的处理程序将依旧被调用，但调用stopPropagation()之后任何其他对象上的事件处理程序将不会被调用。stopPropagation()方法可以在事件传播期间的任何时间调用，它能工作在捕获期阶段、事件目标本身中和冒泡阶段。

IE9之前的IE不支持stopPropagation()方法。相反，IE事件对象有一个cancelBubble属性，设置这个属性为true能阻止事件进一步传播。（IE8及之前版本不支持事件传播的捕获阶段，所以冒泡是唯一待取消的事件传播。）

当前的DOM事件规范草案在Event 对象上定义另一个方法，命名为stopImmediatePropagation()。类似stopPropagation()，这个方法阻止了任何其他对象的事件传播，但也阻止了在相同对象上注册的任何其他事件处理程序的调用。

### ***\*文档加载事件\****

Window对象的load事件直到文档和所有图片加载完毕时才发生。然而，在文档完全解析之后但在所有图片全部加载完毕之前开始运行脚本通常是安全的，当文档加载解析完毕且所有延迟(deferred)脚本都执行完毕时会触发DOMContentLoaded事件，此时图片和异步(async)脚本可能依旧在加载，但是文档已经为操作准备就绪了。Firefox引入了这个事件，然后它被包括Microsoft的IE9在内的所有其他浏览器厂商采用。

document.readyState属性随着文档加载过程而变。在IE中，每次状态改变都伴随着Document对象上的readystatechange事件，当IE接收到"complete"状态时使用这个事件来做判断是可行的。HTML5标准化了ready statechange事件，但它仅在load事件之前立即触发，所以目前尚不清楚监听"readystatechange" 取代"load" 会带来多大好处。

### ***\*鼠标事件\****

| ***\*类型\**** | ***\*说明\****                                               |
| -------------- | ------------------------------------------------------------ |
| click          | 高级事件，当用户按下并释放鼠标按键或其他方式“激活”元素时触发 |
| contextmenu    | 可以取消的事件，当上下文菜单即将出现时触发。当前浏览器在鼠标右击时显示上下文菜单，所以这个事件也能像click事件那样使用 |
| dblclick       | 当用户双击鼠标时触发                                         |
| mousedown      | 当用户按下鼠标按键时触发                                     |
| mouseup        | 当用户释放鼠标按键时触发                                     |
| mousemove      | 当用户移动鼠标时触发                                         |
| mouseover      | 当鼠标进入元素时触发。relatedTarget（在IE中是fromElement）指的是鼠标来自的元素 |
| mouseout       | 当鼠标离开元素时触发。relatedTarget（在IE 中是toElement）指的是鼠标要去往的元素 |
| mouseenter     | 类似"mouseover"，但不冒泡。IE将其引人，HTML5将其标准化，但尚未广泛实现 |
| mouseleave     | 类似"mouseout"，但不冒泡。IE将其引人，HTML5将其标准化，但尚未广泛实现 |

传递给鼠标事件处理程序的事件对象有clientX和clientY属性，它们指定了鼠标指针相对于包含窗口的坐标。加入窗口的滚动偏移量就可以把鼠标位置转换成文档坐标。

altKey、ctrlKey、metaKey和shiftKey属性指定了当事件发生时是否有各种键盘辅助键按下。例如，这让你能够区分普通单击和按着Shift键的单击。

button属性指定当事件发生时哪个鼠标按键按下，但是，不同浏览器给这个属性赋不同的值，所以它很难用。某些浏览器只在单击左键时才触发click事件，所以如果需要探测其他键的单击需要监听mousedown和mouseup事件。通常contextmenu事件发生的标志是右击，但如上所述，当事件发生时可能无法阻止上下文菜单的显示。

### ***\*鼠标滚轮事件\****

下例演示了如何使用鼠标滚轮事件和如何实现跨平台的互用性。它定义了enclose()函数在一个较大的内容元素（比如图片）周围包装了一个指定尺寸的“窗体”或“视口”，并定义了鼠标滚轮事件处理程序让用户既能在视口内移动内容元素也能调整视口大小。可以像下面这样在代码中使用enclose() 函数：

<script src="whenReady.js"></script> 

<script src="Enclose.js"></script> 

<script> 

 whenReady***\*(\*******\*function\*******\*()\**** ***\*{\**** 

  enclose***\*(\*******\*document\****.getElementByld***\*(\******"content"\******),\**** ***\*400\*******\*,\**** ***\*200\*******\*,\**** ***\*-\*******\*200\*******\*,\**** ***\*-\*******\*300\*******\*);\**** 

 ***\*});\****

***\*</script>\**** 

<style>div.enclosure { border: solid black 10px; margin: 10px; }</style>

<img id="content" src="testimage.jpg"/> 

处理鼠标滚轮事件：

**// Enclose the content element in a frame or viewport of the specified width**

**// and height (minimum 50x50). The optional contentX and contentY arguments**

**// specify the initial offset of the content relative to the frame. (If**

**// specified, they must be <= 0.) The frame has mousewheel event handlers that**

**// allow the user to pan the element, and to shrink or enlarge the frame.**

***\*function\**** enclose***\*(\****content***\*,\**** framewidth***\*,\**** frameheight***\*,\**** contentX***\*,\**** contentY***\*)\**** ***\*{\****

  **// These arguments aren't just the initial values: they maintain the**

  **// current state and are used and modified by the mousewheel handler.**

  framewidth ***\*=\**** ***\*Math\****.***\*max\*******\*(\****framewidth***\*,\**** ***\*50\*******\*);\****

  frameheight ***\*=\**** ***\*Math\****.***\*max\*******\*(\****frameheight***\*,\**** ***\*50\*******\*);\****

  contentX ***\*=\**** ***\*Math\****.***\*min\*******\*(\****contentX***\*,\**** ***\*0\*******\*)\**** ***\*||\**** ***\*0\*******\*;\****

  contentY ***\*=\**** ***\*Math\****.***\*min\*******\*(\****contentY***\*,\**** ***\*0\*******\*)\**** ***\*||\**** ***\*0\*******\*;\****

 

  **// Create the frame element and set a CSS classname and styles**

  ***\*var\**** frame ***\*=\**** ***\*document\****.createElement***\*(\******"div"\******);\****

  frame.***\*className\**** ***\*=\**** **"enclosure"\******;\**** **// So we can define styles in a stylesheet**

  frame.***\*style\****.***\*width\**** ***\*=\**** framewidth ***\*+\**** **"px"\******;\****    **// Set the frame size.**

  frame.***\*style\****.***\*height\**** ***\*=\**** frameheight ***\*+\**** **"px"\******;\****

  frame.***\*style\****.overflow ***\*=\**** **"hidden"\******;\****       **// No scrollbars, no overflow**

  frame.***\*style\****.boxSizing ***\*=\**** **"border-box"\******;\****    **// Border-box simplifies the** 

  frame.***\*style\****.webkitBoxSizing ***\*=\**** **"border-box"\******;\**** **// calculations for resizing**

  frame.***\*style\****.MozBoxSizing ***\*=\**** **"border-box"\******;\****   **// the frame.**

 

  **// Put the frame in the document and move the content elt into the frame.**

  content.parentNode.insertBefore***\*(\****frame***\*,\**** content***\*);\****

  frame.appendChild***\*(\****content***\*);\****

 

  **// Position the element relative to the frame**

  content.***\*style\****.position ***\*=\**** **"relative"\******;\****

  content.***\*style\****.***\*left\**** ***\*=\**** contentX ***\*+\**** **"px"\******;\****

  content.***\*style\****.***\*top\**** ***\*=\**** contentY ***\*+\**** **"px"\******;\****

 

  **// We'll need to work around some browser-specific quirks below**

  ***\*var\**** isMacWebkit ***\*=\**** ***\*(\*******\*navigator\****.***\*userAgent\****.***\*indexOf\*******\*(\******"Macintosh"\******)\**** ***\*!==\**** ***\*-\*******\*1\**** ***\*&&\****

​            ***\*navigator\****.***\*userAgent\****.***\*indexOf\*******\*(\******"WebKit"\******)\**** ***\*!==\**** ***\*-\*******\*1\*******\*);\****

  ***\*var\**** isFirefox ***\*=\**** ***\*(\*******\*navigator\****.***\*userAgent\****.***\*indexOf\*******\*(\******"Gecko"\******)\**** ***\*!==\**** ***\*-\*******\*1\*******\*);\****

 

  **// Register mousewheel event handlers.**

  frame.onwheel ***\*=\**** wheelHandler***\*;\****    **// Future browsers**

  frame.onmousewheel ***\*=\**** wheelHandler***\*;\**** **// Most current browsers**

  ***\*if\**** ***\*(\****isFirefox***\*)\****           **// Firefox only**

​    frame.addEventListener***\*(\******"DOMMouseScroll"\******,\**** wheelHandler***\*,\**** ***\*false\*******\*);\****

 

  ***\*function\**** wheelHandler***\*(\*******\*event\*******\*)\**** ***\*{\****

​    ***\*var\**** e ***\*=\**** ***\*event\**** ***\*||\**** ***\*window\****.***\*event\*******\*;\**** **// Standard or IE event object**

 

​    **// Extract the amount of rotation from the event object, looking**

​    **// for properties of a wheel event object, a mousewheel event object** 

​    **// (in both its 2D and 1D forms), and the Firefox DOMMouseScroll event.**

​    **// Scale the deltas so that one "click" toward the screen is 30 pixels.**

​    **// If future browsers fire both "wheel" and "mousewheel" for the same**

​    **// event, we'll end up double-counting it here. Hopefully, however,**

​    **// cancelling the wheel event will prevent generation of mousewheel.**

​    ***\*var\**** deltaX ***\*=\**** e.deltaX***\**-\*******\*30\**** ***\*||\**** **// wheel event**

​         e.wheelDeltaX***\*/\*******\*4\**** ***\*||\**** **// mousewheel**

​                ***\*0\*******\*;\****  **// property not defined**

​    ***\*var\**** deltaY ***\*=\**** e.deltaY***\**-\*******\*30\**** ***\*||\**** **// wheel event**

​         e.wheelDeltaY***\*/\*******\*4\**** ***\*||\**** **// mousewheel event in Webkit**

  ***\*(\****e.wheelDeltaY***\*===\****undefined ***\*&&\****   **// if there is no 2D property then** 

​         e.wheelDelta***\*/\*******\*4\*******\*)\**** ***\*||\**** **// use the 1D wheel property**

​           e.detail***\**-\*******\*10\**** ***\*||\**** **// Firefox DOMMouseScroll event**

​                ***\*0\*******\*;\****   **// property not defined**

 

​    **// Most browsers generate one event with delta 120 per mousewheel click.**

​    **// On Macs, however, the mousewheels seem to be velocity-sensitive and**

​    **// the delta values are often larger multiples of 120, at** 

​    **// least with the Apple Mouse. Use browser-testing to defeat this.**

​    ***\*if\**** ***\*(\****isMacWebkit***\*)\**** ***\*{\****

​      deltaX ***\*/=\**** ***\*30\*******\*;\****

​      deltaY ***\*/=\**** ***\*30\*******\*;\****

​    ***\*}\****

 

​    **// If we ever get a mousewheel or wheel event in (a future version of)**

​    **// Firefox, then we don't need DOMMouseScroll anymore.**

​    ***\*if\**** ***\*(\****isFirefox ***\*&&\**** e.***\*type\**** ***\*!==\**** **"DOMMouseScroll"\******)\****

​      frame.removeEventListener***\*(\******"DOMMouseScroll"\******,\**** wheelHandler***\*,\**** ***\*false\*******\*);\****

 

​    **// Get the current dimensions of the content element**

​    ***\*var\**** contentbox ***\*=\**** content.getBoundingClientRect***\*();\****

​    ***\*var\**** contentwidth ***\*=\**** contentbox.***\*right\**** ***\*-\**** contentbox.***\*left\*******\*;\****

​    ***\*var\**** contentheight ***\*=\**** contentbox.***\*bottom\**** ***\*-\**** contentbox.***\*top\*******\*;\****

 

​    ***\*if\**** ***\*(\****e.***\*altKey\*******\*)\**** ***\*{\**** **// If Alt key is held down, resize the frame**

​      ***\*if\**** ***\*(\****deltaX***\*)\**** ***\*{\****

​        framewidth ***\*-=\**** deltaX***\*;\**** **// New width, but not bigger than the**

​        framewidth ***\*=\**** ***\*Math\****.***\*min\*******\*(\****framwidth***\*,\**** contentwidth***\*);\**** **// content**

​        framewidth ***\*=\**** ***\*Math\****.***\*max\*******\*(\****framewidth***\*,\*******\*50\*******\*);\****  **// and no less than 50.**

​        frame.***\*style\****.***\*width\**** ***\*=\**** framewidth ***\*+\**** **"px"\******;\**** **// Set it on frame**

​      ***\*}\****

​      ***\*if\**** ***\*(\****deltaY***\*)\**** ***\*{\****

​        frameheight ***\*-=\**** deltaY***\*;\**** **// Do the same for the frame height**

​        frameheight ***\*=\**** ***\*Math\****.***\*min\*******\*(\****frameheight***\*,\**** contentheight***\*);\****

​        frameheight ***\*=\**** ***\*Math\****.***\*max\*******\*(\****frameheight***\*-\****deltaY***\*,\**** ***\*50\*******\*);\****

​        frame.***\*style\****.***\*height\**** ***\*=\**** frameheight ***\*+\**** **"px"\******;\****

​      ***\*}\****

​    ***\*}\****

​    ***\*else\**** ***\*{\**** **// Without the Alt modifier, pan the content within the frame**

​      ***\*if\**** ***\*(\****deltaX***\*)\**** ***\*{\****

​        **// Don't scroll more than this**

​        ***\*var\**** minoffset ***\*=\**** ***\*Math\****.***\*min\*******\*(\****framewidth***\*-\****contentwidth***\*,\**** ***\*0\*******\*);\****

​        **// Add deltaX to contentX, but don't go lower than minoffset**

​        contentX ***\*=\**** ***\*Math\****.***\*max\*******\*(\****contentX ***\*+\**** deltaX***\*,\**** minoffset***\*);\****

​        contentX ***\*=\**** ***\*Math\****.***\*min\*******\*(\****contentX***\*,\**** ***\*0\*******\*);\****   **// or higher than 0**

​        content.***\*style\****.***\*left\**** ***\*=\**** contentX ***\*+\**** **"px"\******;\**** **// Set new offset**

​      ***\*}\****

​      ***\*if\**** ***\*(\****deltaY***\*)\**** ***\*{\****

​        ***\*var\**** minoffset ***\*=\**** ***\*Math\****.***\*min\*******\*(\****frameheight ***\*-\**** contentheight***\*,\**** ***\*0\*******\*);\****

​        **// Add deltaY to contentY, but don't go lower than minoffset**

​        contentY ***\*=\**** ***\*Math\****.***\*max\*******\*(\****contentY ***\*+\**** deltaY***\*,\**** minoffset***\*);\****

​        contentY ***\*=\**** ***\*Math\****.***\*min\*******\*(\****contentY***\*,\**** ***\*0\*******\*);\****   **// Or higher than 0**

​        content.***\*style\****.***\*top\**** ***\*=\**** contentY ***\*+\**** **"px"\******;\**** **// Set the new offset.**

​      ***\*}\****

​    ***\*}\****

 

​    **// Don't let this event bubble. Prevent any default action.**

​    **// This stops the browser from using the mousewheel event to scroll**

​    **// the document. Hopefully calling preventDefault() on a wheel event**

​    **// will also prevent the generation of a mousewheel event for the**

​    **// same rotation.**

​    ***\*if\**** ***\*(\****e.preventDefault***\*)\**** e.preventDefault***\*();\****

​    ***\*if\**** ***\*(\****e.stopPropagation***\*)\**** e.stopPropagation***\*();\****

​    e.***\*cancelBubble\**** ***\*=\**** ***\*true\*******\*;\**** **// IE events**

​    e.***\*returnValue\**** ***\*=\**** ***\*false\*******\*;\**** **// IE events**

​    ***\*return\**** ***\*false\*******\*;\****

  ***\*}\****

***\*}\****

### ***\*拖放事件\****

拖放(Drag-and-Drop, DnD)是在“拖放源(drag source)”和“拖放目标(drop target)”之间传输数据的用户界面，它可以存在相同应用之间也可是不同应用之间。

DnD总是基于事件且JavaScript API包含两个事件集，一个在拖放源上触发，另一个在拖放目标上触发。所有传递给DnD事件处理程序的事件对象都类似鼠标事件对象，另外它拥有dataTransfer属性。这个属性引用DataTransfer对象，该对象定义DnD API的方法和属性。

拖放源事件相当简单，我们就从它们开始。任何有HTML draggable属性的文档元素都是拖放源。当用户开始用鼠标在拖放源上拖动时，浏览器并没有选择元素内容，相反，它在这个元素上触发dragstart事件。这个事件的处理程序就调用dataTransfer。setData()指定当前可用的拖放源数据（和数据类型）。（当新的HTML5 API实现时，可以用dataTransfer.items.add()代替。）这个事件处理程序也可以设置dataTransfer.effectAllowed来指定支持“移动”、“复制”和“链接”传输操作中的几种，同时它可以调用dataTransfer.setDragImage() 或dataTransfer.addElement() （在那些支持这些方法的浏览器中）指定图片或文档元素用做拖动时的视觉表现。

在拖动的过程中，浏览器在拖放源上触发拖动事件。如果想更新拖动图片或修改提供的数据，可以监听这些事件，但一般不需要注册“拖动”事件处理程序。

当放置数据发生时会触发dragend事件。如果拖放源支持“移动”操作，它就会检查dataTransfer.dropEffect去看看是否实际执行了移动操作。如果执行了，数据就被传输到其他地方，你应该从拖放源中删除它。

拖放目标比拖放源更棘手。任何文档元素都可以是拖放目标，这不需要像拖放源一样设置HTML属性，只需要简单地定义合适的事件监听程序。（但是使用新的HTML5 DnD API，将可以在拖放目标上定义dropzone属性来取代定义后面介绍的一部分事件处理程序。）有4个事件在拖放目标上触发。当拖放对象(dragged object)进入文档元素时，浏览器在这个元素上触发dragenter事件。拖放目标应该使用dataTransfer.types属性确定拖放对象的可用数据是否是它能理解的格式。（也可以检查dataTransfer.effectAllowed确保拖放源和拖放目标同意使用移动、复制和链接操作中的一个。）如果检查成功，拖放目标必须要让用户和浏览器都知道它对放置感兴趣。可以通过改变它的边框或背景颜色来向用户反馈。令人吃惊的是，拖放目标通过取消事件来告知浏览器它对放置感兴趣。

如果元素不取消浏览器发送给它的dragenter事件，浏览器将不会把它作为这次拖放的拖放目标，并不会向它再发送任何事件。但如果拖放目标取消了dragenter事件，浏览器将发送dragover事件表示用户继续在目标上拖动对象。再一次令人吃惊的是，拖放目标必须监听且取消所有这些事情来表明它继续对放置感兴趣。如果拖放目标想指定它只允许移动、复制或链接操作，它应该使用dragover事件处理程序来设置dataTransfrer.dropEffect。

如果用户移动拖放对象离开通过取消事件表明有兴趣的拖放目标，那么在拖放目标上将触发dragleave事件。这个事件的处理程序应该恢复元素的边框或背景颜色或取消任何其他为响应dragenter事件而执行的可视化反馈。遗憾的是， dragenter和dragleave事件会冒泡，如果拖放目标内部有嵌套元素，想知道dragleave事件表示拖放对象从拖放目标离开到目标外的事件还是到目标内的事件非常困难。

最后，如果用户把拖放对象放置到拖放目标上，在拖放目标上会触发drop事件。这个事件的处理程序应该使用dataTransfer.getData()获取传输的数据并做一些适当的处理。另外，如果用户在拖放目标放置一或多个文件，dataTransfer.files属性将是一个类数组的File对象。使用新的HTML5 API，drop事件处理程序将能遍历dataTransfer.items[] 的元素去检查文件和非文件数据。

### ***\*文本事件\****

浏览器有3个传统的键盘输入事件。keydown事件和keyup事件是低级事件，keypress事件是较高级的事件，它表示产生了一个可打印字符。3级DOM事件规范草案定义一个更通用的textinput事件，不管来源（例如：键盘、粘贴或拖放形式的数据传输、亚洲语言输入法、声音或手写识别系统），无论何时用户输入文本时都会触发它。

textinput事件传递一个简单的事件对象，它有一个用于保存输入文本的data属性。（另一个属性inputMethod是建议用于指定输入源，但它尚未实现。）对于键盘输入，data属性通常只保存单个字符，但其他输入源通常可能包含多个字符。

通过keypress事件传递的对象更加混乱。一个keypress事件表示输入的单个字符。事件对象以数字Unicode编码的形式指定字符，所以必须用String.fromCharCode()把它转换成字符串。在大多数浏览器中，事件对象的keyCode属性指定了输入字符的编码。但是由于历史的原因，Firefox使用的是charCode属性。大多数浏览器只在当产生可打印字符时触发keypress事件。但是Firefox在产生非打印字符时也触发keypress事件。为了检测这种情况（这样就能忽略非打印字符），可以查找有charCode属性但值为0的事件对象。

可以通过取消textinput和keypress事件来阻止字符输入，这意味着可以使用这些事件来过滤输入。

keypress和textinput事件是在新输入的文本真正插入到聚焦的文档元素前触发，这就是这些事件处理程序能够取消事件和阻止文本插入的原因。浏览器也实现了在文本插入到元素后才触发的input事件类型input。虽然这些事件不能取消，不能指定其事件对象中的最新文本，但它们能以某种形式提供元素文本内容发生改变的通知。

HTML5标准化了input事件，除IE外的所有浏览器都支持它。在IE中，可以使用不标准的propertychange事件检测文本输入元素的value属性改变来实现相似的效果。

### ***\*键盘事件\****

当用户在键盘上按下或释放按键时，会发生keydown和keyup事件。它们由辅助键、功能键和字母数字键产生。如果用户按键时间足够长会导致它开始重复，那么在keyup事件到达之前会收到多个keydown事件。

这些事件相关的事件对象都有数字属性keyCode，指定了按下的键是哪个。对于产生可打印字符的按键，keyCode值是按键上出现的主要字符的Unicode编码。无论Shift键处于什么状态，字母键总是产生大写keyCode值，这是因为它们出现在物理键盘上。类似地，即使为了输入标点字符而按下了Shift键，但数字键产生的keyCode值就是出现在对应键上的数字。对于不可打印键，keyCode属性将是一些其他值。keyCode值尚未标准化，但适当的跨浏览器兼容性是可行的。

类似鼠标事件对象，键盘事件对象有altKey、ctrlKey、metakey和shiftKey属性，当事件发生时，如果对应的辅助键被按下，那么它们会被设置为true。

keydown和keyup事件及keyCode属性已经使用了十多年，但从未标准化。3级DOM事件规范草案标准化了keydown和keyup事件类型，但没有尝试标准化keyCode。相反，它定义了新属性key，它会以字符串的形式包含键名。如果按键对应的是一个可打印字符，那么key属性将仅仅是这个可打印字符。如果按键是功能键，那么key属性将是像"F2"、"Home"或"Left"这样的值。

像Safari和Chrome这类基于Webkit的浏览器为这些事件的事件对象定义了一个keyIdentifier属性。类似key.keyIdentifier是字符串而非数字，并且对于功能键，它是像"Shift"、"Enter"这样有用的值。对于可打印字符，该属性保存了这个字符的Unicode编码的字符串表示形式，其用处要小一些。

***\*脚本化HTTP\****

Ajax描述了一种主要使用脚本操纵HTTP的Web应用架构。

Comet是和使用脚本操纵HTTP的Web应用架构相关的术语。在某种意义上，Comet和Ajax相反。在Comet 中， Web服务器发起通信并异步发送消息到客户端。如果Web应用需要响应服务端发送的消息，则它会使用Ajax技术发送或请求数据。在Ajax 中，客户端从服务端“拉”数据，而在Comet中，服务端向客户端“推”数据。Comet还包括其他名词（如“服务器推”、“Ajax推”和“HTTP流”）。

实现Ajax和Comet的方式有很多种，而这些底层的实现有时称为传输协议(transport)。

<script>元素的src属性能设置URL并发起HTTP GET请求。使用<script>元素实现脚本操纵HTTP是非常吸引人的，因为它们可以跨域通信而不受限于同源策略。通常，使用基于<script>的Ajax传输协议时，服务器的响应采用JSON编码的数据格式，当执行脚本时，JavaScript解析器能自动将其“解码”。由于它使用JSON数据格式，因此这种Ajax传输协议也叫做"JSONP"。

虽然在<iframe>和<script>传输协议之上能实现Ajax技术，但通常还有更简单的方式。一段时间以来，所有浏览器都支持XMLHttpRequest对象，它定义了用脚本操纵HTTP的API。

Comet传输协议比Ajax更精妙，但都需要客户端和服务器之间建立（必要时重新建立）连接，同时需要服务器保持连接处于打开状态，这样它才能够发送异步信息。实现Comet的一种更可靠跨平台方案是客户端建立一个和服务器的连接（使用Ajax传输协议），同时服务器保持这个连接打开直到它需要推送一条消息。服务器每发送一条消息就关闭这个连接，这样可以确保客户端正确接收到消息。处理该消息之后，客户端马上为后续的消息推送建立一个新连接。

实现可靠的跨平台Comet传输协议是非常有挑战性的，所以大部分使用Comet架构的Web应用开发者依赖于像Dojo这样的Web框架库中的传输协议。浏览器正开始实现HTML5相关草案中的Server-Sent事件，它用EventSource对象的形式定义了简单的Comet API。 

在Ajax和Comet之上构建更高级的通信协议是可行的。例如，这些客户端/服务器技术可以用做RPC（Remote Procedure Call，远程过程调用）机制或发布/订阅事件系统的基础。

### ***\*使用XMLHttpRequest\****

浏览器在XMLHttpRequest类上定义了它们的HTTP API。这个类的每个实例都表示一个独立的请求/响应对，并且这个对象的属性和方法允许指定请求细节和提取响应数据。

使用这个HTTP API必须做的第一件事就是实例化XMLHttpRequest对象

function getXhr() {var xhr = null;if (window.XMLHttpRequest) {//非ie浏览器    xhr = new XMLHttpRequest();  } else {//ie浏览器    xhr = new ActiveXObject('Microsoft.XMLHttp');  }return xhr;}

一个HTTP请求由4部分组成：

l HTTP请求方法或“动作”(verb)

l 正在请求的URL

l 一个可选的请求头集合，其中可能包括身份验证信息

l 一个可选的请求主体

服务器返回的HTTP响应包含3 部分：

l 一个数字和文字组成的状态码，用来显示请求的成功和失败

l 一个响应头集合

l 响应主体

1）编程的基本步骤

​	step1 获得XMLHttpRequest对象：var xhr = getXhr();

​	step2 发送请求

​	方式一：发送get请求

// open(请求方式，请求地址，同步还是异步)// 请求方式有两种: 'get'，'post'// 请求地址:如果是get方式，请求参数要添加到请求地址后面，如果是post方式，请求参数要加到send方法里面。// true：异步，false:同步xhr.open('get', callUrl, true);xhr.onreadystatechange=f1;xhr.send(null);

方式二：发送post请求

xhr.open('post', callUrl, true);// 因为xhr默认生成的请求数据包不会自动添加content-type消息头，需要通过编程的方式来添加。xhr.open('post','check_name.do',true);xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');xhr.onreadystatechage = f1;// eg. username=zsxhr.send(parameters);

step3 服务器端，编写处理请求的代码。　

​	step4 监听器处理服务器返回的数据

function f1(){if(xhr.readyState == 4){	  // 只有readyState的值是４，才表示xhr收到了服务器返回的所有数据。		var txt = xhr.responseText;		// 使用txt更新页面，即一些dom操作		...	}}

1) ajax编程中的编码问题

​	编码问题产生的原因：

​	XMLHttpRequest对象生成请求数据包，当采用get方式向服务器发请求时，IE会使用gbk编码格式对请求中的参数进行编码，而FF、Chrome会使用utf-8对请求中的参数进行编码。服务器端一般会使用iso-8859-1去解码，这样，编码与解码的编码格式不一样，会出现乱码问题。

​	解决方案：

​	step1 在server.xml文件中，添加URIEncoding = "utf-8"。能解决FireFox乱码，Chrome乱码；不能解决IE乱码。

​	step2 使用encodeURI函数对请求地址进行统一的编码（utf-8），解决IE乱码。

使用post方式发送请求时，要注意编码问题：

​	原因：ie、ff、chrome内置的XMLHttpRequest对象都会使用utf-8对请求参数进行编码。服务器默认情况下，会使用iso-8859-1去解码，注意，之前在server.xml文件中添加的URIEncoding不起作用。

​	解决方案：只需要添加request.setCharacterEncoding("utf-8");

2) 同步方式发请求（扩展）

​	open('get/post', callUrl, false);

​	false：表示同步，同步的含义是，当XMLHttpRequest对象向服务器发送请求时，浏览器会锁定页面，用户不能做其它操作，必须等到服务器返回数据回来之后，才能做其它操作。

 

***\*缓存问题：在使用IE浏览器时，如果使用get方式发送请求，浏览器会将数据缓存起来。这样，当再次发送请求时，如果请求地址不变，IE不会真正地向服务器发送请求，而是将之前缓存的数据显示给用户\****

解决方法 

\1. url 后带一个总是变化的参数，比如当前时间

var url = "/ajax/registerProcess.php?mytime=" + new  Date();

\2. 在服务器回送结果时，禁用缓存

//这里两句话很重要，第一讲话告诉浏览器返回的数据是xml格式

​	header("Content-Type: text/xml;charset=utf-8");

​	//告诉浏览器不要缓存数据

​	header("Cache-Control: no-cache");

\3. 使用post发送

当一个ajax请求到服务器，服务器可以根据需求返回3种格式的数据，那么我们应当选择哪一个？

\1. 如果你的项目经理没有特殊的要求，建议使用json

\2. 若应用程序***\*不需要与其他应用程序共享数据的时候\****，使用HTML片段来返回数据是最简单的

**3.** ***\*如果数据需要重用\****，JSON文件是个不错的选择，其在性能和文件大小方面有优势

**4.** ***\*当远程应用程序未知时\****，XML文档是首选，因为XML是web服务领域的“世界语”

 

***\*指定\*******\*请求\****

创建XMLHttpRequest对象之后，发起HTTP请求的下一步是调用XMLHttpRequest对象的open()方法去指定这个请求的两个必需部分：方法和URL。

open()的第一个参数指定HTTP方法或动作。这个字符串不区分大小写，但通常大家用大写字母来匹配HTTP协议。"GET" 和"POST" 方法是得到广泛支持的。"GET" 用于常规请求，它适用于当URL完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存时。"POST" 方法常用于HTML表单。它在请求主体中包含额外数据（表单数据）且这些数据常存储到服务器上的数据库中（副作用）。相同URL的重复POST请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求。

除了"GET"和"POST"之外，XMLHttpRequest规范也允许把"DELETE"、"HEAD"、"OPTIONS" 和"PUT"作为open() 的第1 个参数。（"HTTP CONNECT"、"TRACE"和"TRACK"因为安全风险己被明确禁止。）旧浏览器并不支持所有这些方法，但至少"HEAD"得到广泛支持。

open()的第2个参数是URL，它是请求的主题。这是相对于文档的URL，这个文档包含调用open()的脚本。如果指定绝对URL、协议、主机和端口通常必须匹配所在文档的对应内容：跨域的请求通常会报错。

如果有请求头的话，请求进程的下个步骤是设置它。例如， POST请求需要"ContentType"头指定请求主题的MIME类型：

request.setRequestHeader("Content-Type", "text/plain");

如果对相同的头调用setRequestHeader()多次，新值不会取代之前指定的值，相反，HTTP请求将包含这个头的多个副本或这个头将指定多个值。

你不能自己指定"Content-Length"、"Date"、"Referer"或"User-Agent"头，XMLHttpRequest对象自动添加这些头而防止伪造它们。类似地，XMLHttpRequest对象自动处理cookie、连接时间、字符集和编码判断，所以你无法向setRequestHeader()传递这些头。

你能为请求指定"Authorization"头，但通常不需要这么做。如果请求一个受密码保护的URL，把用户名和密码作为第4个和第5个参数传递给open()，则XMLHttpRequest将设置合适的头。

使用XMLHttpRequest发起HTTP请求的最后一步是指定可选的请求主体并向服务器发送它。使用send()方法像如下这样做：

request.send(null);

GET请求绝对没有主体，所以应该传递null或省略这个参数。POST请求通常拥有主体，同时它应该匹配使用setRequestHeader()指定的"Content-Type"头。

HTTP请求的各部分有指定顺序：请求方法和URL首先到达，然后是请求头，最后是请求主体。XMLHttpRequest 实现通常直到调用send()方法才开始启动网络。但XMLHttpRequest API的设计似乎使每个方法都将写入网络流。这意味着调用XMLHttpRequest方法的顺序必须匹配HTTP请求的架构。例如，setRequestHeader()方法的调用必须在调用open()之前但在调用send()之后，否则它将抛出异常。

下例使用了我们目前介绍的所有XMLHttpRequest方法。它用POST方法发送文本字符串给服务器，并忽略服务器返回的任何响应。

***\*function\**** postMessage***\*(\****msg***\*){\****

 ***\*var\**** request ***\*= new\**** XMLHttpRequest***\*();\**** **//新请求**

 request.***\*open\*******\*(\******"POST"\******,\******"/log.php"\******);\******//用POST向服务器端发送脚本**

 **//用请求主体发送纯文本信息**

 request.setRequestHeader***\*(\******"Content-Type"\******,\******//请求主体将是纯文本**

​              **"text/plain;charset=UTF-8"\******);\****

 request.send***\*(\****msg***\*);\******//把msg作为请求主体发送**

 **//请求完成，我们将忽略任何响应和错误**

***\*}\****

上例的send()方法启动请求，然后返回，当它等待服务器的响应时并不阻塞。

***\*取得响应\****

一个完整的HTTP响应由状态码、响应头集合和响应主体组成。这些都可以通过XMLHttpRequest对象的属性和方法使用：

l status和statusText属性以数字和文本的形式返回HTTP状态码。这些属性保存标准的HTTP值，像200和"OK" 表示成功请求，404和"Not Found"表示URL不能匹配服务器上的任何资源。

l 使用getResponseHeader()和getAllResponseHeaders()能查询响应头。XMLHttpRequest会自动处理cookie：它会从getAllResponseHeaders()头返回集合中过滤掉cookie头，而如果给getResponseHeader()传递"Set-Cookie" 和"Set-Cookie2"则返回null。

l 响应主体可以从responseText属性中得到文本形式的，从responseXML属性中得到Document形式的。（这个属性名是有历史的：它实际上对XHTML和XML文档有效，但XHR2说它也应该对普通的HTML文档工作。）

XMLHttpRequest对象通常异步使用：发送请求后，send()方法立即返回，直到响应返回，前面列出的响应方法和属性才有效。为了在响应准备就绪时得到通知，必须监听XMLHttpRequest对象上的readystatechange事件。但为了理解这个事件类型，你必须理解readyState属性。

​	readyState是一个整数，它指定了HTTP请求的状态，同时下表列出了它可能的值。第一列的符号是XMLHttpRequest构造函数定义的常量。这些常量是XMLHttpRequest规范的一部分，但老的浏览器和IE8没有定义它们，通常看到使用硬编码值4来表示XMLHttpRequest.DONE。

| ***\*常量\****   | ***\*值\**** | ***\*含义\****                   |
| ---------------- | ------------ | -------------------------------- |
| UNSENT           | 0            | open()尚未调用                   |
| OPENED           | 1            | open()已调用，尚未调用send()方法 |
| HEADERS_RECEIVED | 2            | send()方法已调用，接收到头信息   |
| LOADING          | 3            | 接收到响应主体                   |
| DONE             | 4            | 接收了所有数据，响应完成         |

理论上，每次readyState属性改变都会触发readystatechange事件。实际中，当readyState改变为0或1时可能没有触发这个事件。当调用send()时，即使readyState仍处于OPENED状态，也通常触发它。某些浏览器在LOADING状态时能触发多次事件来给出进度反馈。当readyState值改变为4或服务器的响应完成时，所有的浏览器都触发readystatechange事件。因为在响应完成之前也会触发事件，所以事件处理程序应该一直检验readyState值。

为了监听readystatechange事件，请把事件处理函数设置为XMLHttpRequest对象的onreadystatechange属性。也能使用addEventListener()（或在IE8以及之前版本中使用attachEvent()），但通常每个请求只需要一个处理程序，所以只设置onreadystatechange更容易。

下例定义了getText()函数来演示如何监听readystatechange事件。事件处理程序首先要确保请求完成。如果这样，它会检查响应状态码来取保请求成功。然后它查找"Content-Type"头来验证响应主体是否是期望的类型。如果3个条件都得到楠足，它会把响应主体（以文本形式）发送给指定的回调函数。

**//发出一个HTTP GET请求以获得指定URL的内容**

**//当响应成功到达，验证它是否是纯文本**

**//如果是，把它传递给指定回调函数**

***\*function\**** getText***\*(\****url***\*,\**** callback***\*){\****

 ***\*var\**** request ***\*= new\**** XMLHttpRequest***\*();\******//创建新请求**

 request.***\*open\*******\*(\******"GET"\******,\****url***\*);\******//指定待获取的URL**

 request.onreadystatechange ***\*=\**** ***\*function\*******\*(){\******//定义事件处理程序**

  **//如果请求完成，则它是成功的**

  ***\*if\**** ***\*(\****request.***\*readyState\**** ***\*===\**** ***\*4\**** ***\*&&\**** request.***\*status\**** ***\*===\**** ***\*200\*******\*) {\****

   ***\*var\**** ***\*type\**** ***\*=\**** request.getResponseHeader***\*(\******"Content-Type"\******);\****

   ***\*if\*******\*(\*******\*type\****.***\*match\*******\*(/^\*******\*text\*******\*/))\******//确定响应是文本**

​    callback***\*(\****request.ResponseText***\*);\******//把它传递给回调函数** 

  ***\*}\****

 ***\*};\****

 request.send***\*(\*******\*null\*******\*);\******//立即发送请求**

***\*}\****

由于其本身的性质，异步处理HTTP响应是最好的方式。然而，XMLHttpRequest也支持同步响应。如果把false作为第3个参数传递给open()，那么send()方法将阻塞直到请求完成。在这种情况下，不需要使用事件处理程序：一且send()返回，仅需要检查XMLHttpRequest对象的status和responseText属性。下例是同步代码：

//发出一个同步的HTTP GET请求以获得指定URL的内容

//返回响应文本，或如果请求不成功或响应不是文本就报错

***\*function\**** getTextSync(url){

 ***\*var\**** request = new XMLHttpRequest();//创建新请求

 request.open("GET", url, ***\*false\****);//传递false实现同步

 request.send(***\*null\****);//立即发送请求

 

 //如果请求不是200 OK，就报错

 ***\*if\**** (request.status !== 200) ***\*throw\**** new Error(request.statusText);

 

 //如果类型错误，就报错

 ***\*var\**** type = request.getResponseHeader("Content-Type");

 

 ***\*if\****(!type.match(/^text/))//确定响应是文本

  ***\*throw\**** new Error("Expected textual response; got: " + type);

 

 ***\*return\**** request.responseText;

}

同步请求是吸引人的，但应该避免使用它们。客户端JavaScript是单线程的，当Send()方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结。

解析HTTP响应

**//发起HTTP GET响应以获取指定URL的内容**

**//当响应到达时，把它以解析后的XML Document对象、解析后的JSON对象**

**//或字符串形式传递给回调函数**

***\*function\**** ***\*get\*******\*(\****url***\*,\**** callback***\*){\****

 ***\*var\**** request ***\*= new\**** XMLHttpRequest***\*();\******//创建新请求**

 request.***\*open\*******\*(\******"GET"\******,\**** url***\*);\******//指定待获取的URL**

 request.onreadystatechange ***\*=\**** ***\*function\*******\*(){\**** **//定义事件监听器**

  **//如果请求完成且成功**

  ***\*if\**** ***\*(\****request.***\*readyState\**** ***\*===\**** ***\*4\**** ***\*&&\**** request.***\*status\**** ***\*===\**** ***\*200\*******\*) {\****

   **//获得响应的类型**

   ***\*var\**** ***\*type\**** ***\*=\**** request.getResponseHeader***\*(\******"Content-Type"\******);\****

   **//检查类型，这样我们不能在将来得到HTML文档**

   ***\*if\**** ***\*(\*******\*type\****.***\*indexOf\*******\*(\******"xml"\******) !== -\*******\*1\**** ***\*&&\**** request.responseXML***\*)\****

​    callback***\*(\****request.responseXML***\*);\******//Document对象响应**

   ***\*else\**** ***\*if\*******\*(\*******\*type\**** ***\*===\**** **"application/json"\******)\**** 

​    callback***\*(\****JSON.***\*parse\*******\*(\****request.responseText***\*));\******//JSON响应**

   ***\*else\****

​    callback***\*(\****request.responseText***\*);\******//字符串响应**

  ***\*}\****

 ***\*};\****

 request.send***\*(\*******\*null\*******\*);\******//立即发送请求**

***\*}\****

服务器响应的正常解码是假设服务器为这个响应发送了"Content-Type"头和正确的MIME类型。例如，如果服务器发送XML文档但没有设置适当的MIME类型，那么XMLHttpRequest对象将不会解析它且设置responseXML属性。或者，如果服务器在"Content-Type"头中包含了错误的"charset"参数，那么XMLHttpRequest将使用错误的编码来解析响应，并且responseText中的字符可能是错的。XHR2定义了overrideMimeType()方法来解决这个问题，并且大量的浏览器已经实现了它。

如果相对于服务器你更了解资源的MIME类型，那么在调用send()之前把类型传递给overrideMimeType()，这将使XMLHttpRequest忽略"Content-Type"头而使用指定的类型。假设你将下载XML文件，而你计划把它当成纯文本对待。可以使用setOverrideMimeType()让XMLHttpRequest知道它不需要把文件解析成XML文档：

//不要把响应作为XML文档处理

request.overrideMimeType("text/plain; charset=utf-8")

***\*编码请\*******\*求主体\****

表单数据编码格式有一个正式的MIME类型：application/x-www-form-urlencoded

下例展示了如何实现对象属性的表单编码。

**/\***

 *** 编码对象的属性，**

 *** 如果它们是来自HTML表单的名/值对，使用application/x-www-form-urlencoded格式**

 ***/**

***\*function\**** encodeFormData***\*(\*******\*data\*******\*){\****

 ***\*if\*******\*(!\*******\*data\*******\*)\**** ***\*return\**** **""\******;\******//一直返回字符串**

 ***\*var\**** pairs ***\*= [];\******//为了保存名=值对**

 ***\*for\*******\*(\*******\*var\**** ***\*name\**** ***\*in\**** ***\*data\*******\*){\******//为每个名字**

  ***\*if\*******\*(!\*******\*data\****.hasOwnProperty***\*(\*******\*name\*******\*))\**** ***\*continue\*******\*;\******//跳过继承属性**

  ***\*if\*******\*(typeof\**** ***\*data\*******\*[\*******\*name\*******\*] ===\**** **"function"\******)\**** ***\*continue\*******\*;\******//跳过方法**

  ***\*var\**** ***\*value\**** ***\*=\**** ***\*data\*******\*[\*******\*name\*******\*]\****.***\*toString\*******\*();\******//把值转换成字符串**

  ***\*name\**** ***\*=\**** encodeURIComponent***\*(\*******\*name\****.***\*replace\*******\*(\******"%20"\******,\**** **"+"\******));\******//编码名字**

  ***\*value\*******\*=\****encodeURIComponent***\*(\*******\*value\****.***\*replace\*******\*(\******"%20"\******,\**** **"+"\******));\******//编码值**

  pairs.***\*push\*******\*(\*******\*name\**** ***\*+\**** **"="** ***\*+\**** ***\*value\*******\*);\******//记住名=值对**

 ***\*}\****  

 ***\*return\**** pairs.***\*join\*******\*(\******'&'\******);\******//返回使用"&"连接的名/值对**

***\*}\****

使用表单编码数据发起一个HTTP POST请求

***\*function\**** postData***\*(\****url***\*,\**** ***\*data\*******\*,\**** callback***\*){\****

 ***\*var\**** request ***\*= new\**** XMLHttpRequest***\*();\****

 request.***\*open\*******\*(\******"POST"\******,\**** url***\*);\******//对指定URL发生POST请求**

 request.onreadystatechange ***\*=\**** ***\*function\*******\*(){\******//简单的事件处理程序**

  ***\*if\*******\*(\****request.***\*readyState\**** ***\*===\**** ***\*4\**** ***\*&&\**** callback***\*)\******//当响应完成**

   callback***\*(\****request***\*);\******//调用回调函数**

 ***\*};\****

 **//设置Content-Type**

 request.setRequestHeader***\*(\******"Content-Type"\******,\**** **"application/x-www-form-urlencoded"\******);\****

 request.send***\*(\****encodeFormData***\*(\*******\*data\*******\*));\******//发送表单编码的数据**

***\*}\****

使用表单编码数据发起GET请求

***\*function\**** getData***\*(\****url***\*,\**** ***\*data\*******\*,\**** callback***\*){\****

 ***\*var\**** request ***\*= new\**** XMLHttpRequest***\*();\****

 **//通过添加的编码数据获取指定的url**

 request.***\*open\*******\*(\******"GET"\******,\**** url ***\*+\**** **"?"** ***\*+\**** encodeFormData***\*(\*******\*data\*******\*));\****

 request.onreadystatechange ***\*=\**** ***\*function\*******\*() {\******//简单的事件处理程序**

  ***\*if\*******\*(\****request.***\*readyState\**** ***\*===\**** ***\*4\**** ***\*&&\**** callback***\*)\******//当响应完成**

   callback***\*(\****request***\*);\******//调用回调函数**

 ***\*};\****

 request.send***\*(\*******\*null\*******\*);\******//发送请求**

***\*}\****

使用JSON编码主体来发起HTTP POST请求

***\*function\**** postJSON***\*(\****url***\*,\**** ***\*data\*******\*,\**** callback***\*) {\****

 ***\*var\**** request ***\*= new\**** XMLHttpRequest***\*();\****

 request.***\*open\*******\*(\******"POST"\******,\**** url***\*);\******//对指定URL发送POST请求**

 request.onreadystatechange ***\*=\**** ***\*function\*******\*() {\******//简单的事件处理程序**

  ***\*if\*******\*(\****request.***\*readyState\**** ***\*===\**** ***\*4\**** ***\*&&\**** callback***\*)\******//当响应完成**

   callback***\*(\****request***\*);\******//调用回调函数**

 ***\*};\****

 request.setRequestHeader***\*(\******"Content-Type"\******,\**** **"application/json"\******);\**** 

 request.send***\*(\****JSON.stringify***\*(\*******\*data\*******\*));\******//发送请求**

***\*}\****

使用XML文档作为其主体的HTTP POST请求

**//在XML中编码什么东西、在哪儿和半径，然后向指定的URL发送POST请求**

**//当接收到响应时，调用回调函数**

***\*function\**** postQuery***\*(\****url***\*,\**** what***\*,\**** where***\*,\**** radius***\*,\**** callback***\*) {\**** 

 ***\*var\**** request ***\*= new\**** XMLHttpRequest***\*();\**** 

 request.***\*open\*******\*(\******"POST"\******,\**** url***\*);\**** **//对指定的URL发送POST请求**

 request.onreadystatechange ***\*=\**** ***\*function\*******\*() {\**** **//简单的事件处理程序**

  ***\*if\*******\*(\****request.***\*readyState\**** ***\*===\**** ***\*4\**** ***\*&&\**** callback***\*)\**** callback***\*(\****request***\*);\****

 ***\*}\**** 

 **// Create an XML document with root element <query>** 

 ***\*var\**** doc ***\*=\**** ***\*document\****.implementation.createDocument***\*(\******""\******,\**** **"query"\******,\**** ***\*null\*******\*);\**** 

 ***\*var\**** query ***\*=\**** doc.documentElement***\*;\**** **// <query>元素**

 ***\*var\**** ***\*find\**** ***\*=\**** doc.createElement***\*(\******"find"\******);\**** **//创建<find>元素**

 query.appendChild***\*(\*******\*find\*******\*);\**** **//并把它添加到<query>中**

 ***\*find\****.***\*setAttribute\*******\*(\******"zipcode"\******,\**** where***\*);\**** **//设置<find>的属性**

 ***\*find\****.***\*setAttribute\*******\*(\******"radius"\******,\**** radius***\*);\**** 

 ***\*find\****.appendChild***\*(\****doc.createTextNode***\*(\****what***\*));\**** **//并设置<find>的内容**

 **//现在向服务器发送XML编码的数据**

 **//注意将自动设置Content-Type头**

 request.send***\*(\****doc***\*);\**** 

***\*}\****

HTML表单的特性之一是当用户通过<input type="file">元素选择文件时，表单将在它产生的POST请求主体中发送文件内容。HTML表单始终能上传文件，但到目前为止它还不能使用XMLHttpRequest API做相同的事情。然后，XHR2 API允许通过向send()方法传人File对象来实现上传文件。

没有File()对象构造函数，脚本仅能获得表示用户当前选择文件的File对象。在支持File对象的浏览器中，每个<input type="file">元素有一个files属性，它是File对象中的类数组对象

示例：使用HTTP POST请求上传文件

**//查找有data-uploadto属性的全部<input type="file">元素，**

**//并注册onchange事件处理程序**

**//这样任何选择的文件都会自动通过POST方法发送到指定的"uploadto"URL** 

**//服务器的响应是忽略的**

whenReady***\*(\*******\*function\*******\*()\**** ***\*{\**** **//当文档准备就绪时运行**

 ***\*var\**** elts ***\*=\**** ***\*document\****.getElementsByTagName***\*(\******"input"\******);\**** **//所有的input元素**

 ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** elts.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** **//遍历它们**

  ***\*var\**** input ***\*=\**** elts***\*[\****i***\*];\**** 

  ***\*if\**** ***\*(\****input.***\*type\**** ***\*!==\**** **"file"\******)\**** ***\*continue\*******\*;\**** **//跳过所有非文件上传元素**

  ***\*var\**** url ***\*=\**** input.***\*getAttribute\*******\*(\******"data-uploadto"\******);\**** **//获取上传URL**

  ***\*if\**** ***\*(!\****url***\*)\**** ***\*continue\*******\*;\**** **//跳过任何没有URL的元素**

  input.addEventListener***\*(\******"change"\******,\**** ***\*function\*******\*(){\**** **//当用户选择文件时**

   ***\*var\**** file ***\*=\**** ***\*this\****.files***\*[\*******\*0\*******\*];\**** **//假设单个文件选择**

   ***\*if\**** ***\*(!\****file***\*)\**** ***\*return\*******\*;\**** **//如果没有文件，不做任何事情**

   ***\*var\**** xhr ***\*=\**** ***\*new\**** XMLHttpRequest***\*();\**** **//创建新请求**

   xhr.***\*open\*******\*(\******"POST"\******,\**** url***\*);\**** **//向这个URL发送POST请求**

   xhr.send***\*(\****file***\*);\**** **//把文件作为主体发送**

  ***\*},\**** ***\*false\*******\*);\**** 

 ***\*}\****

***\*});\****

当HTML表单同时包含文件上传元素和其他元素时，浏览器不能使用普通的表单编码而必须使用称为"multipart/form-data"的特殊Content-Type来用POST方法提交表单。这种编码包括使用长“边界”字符串把请求主体分离成多个部分。对于文本数据，手动创建"multipart/form-data" 请求主体是可能的，但很复杂。

XHR2定义了新的FormData API，它容易实现多部分请求主体。首先，使用FormData()构造函数创建FormData对象，然后按需多次调用这个对象的append()方法把个体“部分”（可以是字符串、File或Blob对象）添加到请求中。最后，把FormData对象传递给send()方法。send()方法将对请求定义合适的边界字符串和设置"Content-Type"头。

示例：使用POST方法发送 multipart/form-data请求主体

***\*function\**** postFormData***\*(\****url***\*,\**** ***\*data\*******\*,\**** callback***\*)\**** ***\*{\**** 

 ***\*if\**** ***\*(typeof\**** FormData ***\*===\**** **"undefined"\******)\**** 

  ***\*throw\**** ***\*new\**** Error***\*(\******"FormData is not implemented"\******);\**** 

 ***\*var\**** request ***\*=\**** ***\*new\**** XMLHttpRequest***\*();\**** **//新HTTP请求**

 request.***\*open\*******\*(\******"POST"\******,\**** url***\*);\**** **//对指定URL发送POST请求**

 request.onreadystatechange ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** **//简单的事件处理程序**

  ***\*if\**** ***\*(\****request.***\*readyState\**** ***\*===\**** ***\*4\**** ***\*&&\**** callback***\*)\**** **//当响应完成时**

   callback***\*(\****request***\*);\**** **//调用回调函数**

 ***\*};\**** 

 ***\*var\**** formdata ***\*=\**** ***\*new\**** FormData***\*();\**** 

 ***\*for\*******\*(\*******\*var\**** ***\*name\**** ***\*in\**** ***\*data\*******\*)\**** ***\*{\**** 

  ***\*if\**** ***\*(!\*******\*data\****.hasOwnProperty***\*(\*******\*name\*******\*))\**** ***\*continue\*******\*;\**** **//跳过继承的属性**

  ***\*var\**** ***\*value\**** ***\*=\**** ***\*data\*******\*[\*******\*name\*******\*];\**** 

  ***\*if\**** ***\*(typeof\**** ***\*value\**** ***\*===\**** **"function"\******)\**** ***\*continue\*******\*;\**** **//跳过方法**

  **//每个属性变成请求的一个部分**

  **//这里允许File对象**

  formdata.append***\*(\*******\*name\*******\*,\**** ***\*value\*******\*);\**** **//作为一部分添加名/值对**

 ***\*}\**** 

 **//在multipart/form-data请求主体中发送名/值对**

 **//每对都是请求的一个部分，注意，当传入FormData对象时**

 **// send()会自动设置Content-Type头**

 request.send***\*(\****formdata***\*);\**** 

***\*}\****

***\*HTTP\*******\*进度事件\****

在之前的示例中，使用readystatechange事件探测HTTP请求的完成。XHR2规范草案定义了更多有用的事件集，有些已经在Firefox、Chrome和Safari中得到支持。在这个新的事件模型中，XMLHttpRequest对象在请求的不同阶段触发不同类型的事件，所以它不再需要检查readyState属性。

在支持它们的浏览器中，这些新事件会像如下这样触发。当调用send() 时，触发单个loadstart事件。当正在加载服务器的响应时，XMLHttpRequest对象会发生progress事件，通常每隔50毫秒左右，所以可以使用这些事件给用户反馈请求的进度。如果请求快速完成，它可能从不会触发progress事件。当事件完成，会触发load事件。

一个完成的请求不一定是成功的请求，例如，load事件的处理程序应该检查XMLHttpRequest对象的status状态码来确定收到的是"200 OK" 而不是"404 Not Found"的HTTP响应。

HTTP请求无法完成有3种情况，对应3种事件。如果请求超时，会触发timeout事件。如果请求中止，会触发abort事件。最后，像太多重定向这样的网络错误会阻止请求完成，但这些情况发生时会触发error事件。

对于任何具体请求，浏览器将只会触发load、abort、timeout和error事件中的一个。XHR2规范草案指出一旦这些事件中的一个发生后，浏览器应该触发loadend事件。但尚未有浏览器实现loadend事件。

可以通过XMLHttpRequest对象的addEventListener()方法为这些progress事件中的每个都注册处理程序。如果每种事件只有一个事件处理程序，通常更容易的方法是只设置对应的处理程序属性，比如onprogress和onload。甚至可以使用这些事件属性是否存在来测试浏览器是否支持progress 事件：

***\*if\**** ("onprogress" ***\*in\**** (new XMLHttpRequest())){

 //支持progress事件

}

除了像type和timestamp这样常用的Event对象属性外，与这些progress事件相关联的事件对象还有3个有用的属性。loaded属性是目前传输的字节数值。total属性是自"Content-Length"头传输的数据的整体长度（单位是字节），如果不知道内容长度则为0。最后，如果知道内容长度则lengthComputable属性为true；否则为false。 显然，total和loaded 属性对progress事件处理程序相当有用：

request.onprogress = ***\*function\****(e) {

 ***\*if\**** (e.lengthComputable)

  progress.innerHTML = Math.round(100*e.loaded/e.total) + "% Complete";

}

除了为监控HTTP响应的加载定义的这些有用的事件外，XHR2也给出了用于监控HTTP请求上传的事件。在实现这些特性的浏览器中，XMLHttpRequest对象将有upload属性。upload属性值是一个对象，它定义了addEventListener()方法和整个progress事件集合，比如onprogress和onload。（但upload对象没有定义onreadystatechange属性，upload仅能触发新的事件类型。）

你能仅仅像使用常见的progress事件处理程序一样使用upload事件处理程序。对于XMLHttpRequest对象x，设置x.onprogress以监控响应的下载进度，并且设置x.upload.onprogress以监控请求的上传进度。

下例演示了如何使用upload progress事件把上传进度反馈给用户。这个示例也演示了如何从拖放API中获得File对象和如何使用FormData API在单个XMLHttpRequest请求中上传多个文件。现在，这些功能依旧在草案中，并且这些示例不能在所有的浏览器中工作。

**//查找所有含有"fileDropTarget"类的元素**

**//并注册DnD事件处理程序使它们能响应文件的拖放**

**//当文件放下时，上传它们到data-uploadto属性指定的URL**

whenReady***\*(\*******\*function\*******\*()\**** ***\*{\**** 

 ***\*var\**** elts ***\*=\**** ***\*document\****.getElementsByClassName***\*(\******"fileDropTarget"\******);\**** 

 ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** elts.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** 

  ***\*var\**** ***\*target\**** ***\*=\**** elts***\*[\****i***\*];\**** 

  ***\*var\**** url ***\*=\**** ***\*target\****.***\*getAttribute\*******\*(\******"data-uploadto"\******);\**** 

  ***\*if\**** ***\*(!\****url***\*)\**** ***\*continue\*******\*;\**** 

  createFileUploadDropTarget***\*(\*******\*target\*******\*,\**** url***\*);\****

 ***\*}\**** 

 ***\*function\**** createFileUploadDropTarget***\*(\*******\*target\*******\*,\**** url***\*)\**** ***\*{\**** 

  **//跟踪当前是否正在上传，因此我们能拒绝放下**

  **//我们可以处理多个并发上传**

  **//但对这个例子使用进度通知太困难了**

  ***\*var\**** uploading ***\*=\**** ***\*false\*******\*;\****

  console.***\*log\*******\*(\*******\*target\*******\*,\**** url***\*);\**** 

  ***\*target\****.ondragenter ***\*=\**** ***\*function\*******\*(\****e***\*)\**** ***\*{\**** 

   console.***\*log\*******\*(\******"dragenter"\******);\**** 

   ***\*if\**** ***\*(\****uploading***\*)\**** ***\*return\*******\*;\**** **//如果正在忙，忽略拖放**

   ***\*var\**** types ***\*=\**** e.dataTransfer.types***\*;\****

   ***\*if\**** ***\*(\****types ***\*&&\**** 

​     ***\*((\****types.***\*contains\**** ***\*&&\**** types.***\*contains\*******\*(\******"Files"\******))\**** ***\*||\**** 

​     ***\*(\****types.***\*indexOf\**** ***\*&&\**** types.***\*indexOf\*******\*(\******"Files"\******)\**** ***\*!==\**** ***\*-\*******\*1\*******\*)))\**** ***\*{\**** 

​    ***\*target\****.classList.add***\*(\******"wantdrop"\******);\****

​    ***\*return\**** ***\*false\*******\*;\**** 

   ***\*}\****

  ***\*};\**** 

  ***\*target\****.ondragover ***\*=\**** ***\*function\*******\*(\****e***\*)\**** ***\*{\**** ***\*if\**** ***\*(!\****uploading***\*)\**** ***\*return\**** ***\*false\*******\*;\**** ***\*};\**** 

  ***\*target\****.ondragleave ***\*=\**** ***\*function\*******\*(\****e***\*)\**** ***\*{\**** 

   ***\*if\**** ***\*(!\****uploading***\*)\**** ***\*target\****.classList.remove***\*(\******"wantdrop"\******);\****

  ***\*};\**** 

  ***\*target\****.ondrop ***\*=\**** ***\*function\*******\*(\****e***\*)\**** ***\*{\**** 

   ***\*if\**** ***\*(\****uploading***\*)\**** ***\*return\**** ***\*false\*******\*;\**** 

   ***\*var\**** files ***\*=\**** e.dataTransfer.files***\*;\**** 

   ***\*if\**** ***\*(\****files ***\*&&\**** files.***\*length\*******\*)\**** ***\*{\**** 

​    uploading ***\*=\**** ***\*true\*******\*;\**** 

​    ***\*var\**** message ***\*=\**** **"Uploading files:<ul>"\******;\**** 

​    ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** files.***\*length\*******\*;\**** i***\*++)\**** 

​     message ***\*+=\**** **"<li>"** ***\*+\**** files***\*[\****i***\*]\****.***\*name\**** ***\*+\**** **"</li>"\******;\**** 

​    message ***\*+=\**** **"</ul>"\******;\**** 

​    ***\*target\****.***\*innerHTML\**** ***\*=\**** message***\*;\**** 

​    ***\*target\****.classList.remove***\*(\******"wantdrop"\******);\**** 

​    ***\*target\****.classList.add***\*(\******"uploading"\******);\**** 

​    ***\*var\**** xhr ***\*=\**** ***\*new\**** XMLHttpRequest***\*();\**** 

​    xhr.***\*open\*******\*(\******"POST"\******,\**** url***\*);\**** 

​    ***\*var\**** body ***\*=\**** ***\*new\**** FormData***\*();\**** 

​    ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** files.***\*length\*******\*;\**** i***\*++)\**** body.append***\*(\****i***\*,\**** files***\*[\****i***\*]);\**** 

​    xhr.upload.onprogress ***\*=\**** ***\*function\*******\*(\****e***\*)\**** ***\*{\**** 

​     ***\*if\**** ***\*(\****e.lengthComputable***\*)\**** ***\*{\**** 

​      ***\*target\****.***\*innerHTML\**** ***\*=\**** message ***\*+\**** 

​       ***\*Math\****.***\*round\*******\*(\****e.loaded***\*/\****e.total***\**\*******\*100\*******\*)\**** ***\*+\**** 

​       **"% Complete"\******;\**** 

​     ***\*}\****

​    ***\*};\****

​    xhr.upload.***\*onload\**** ***\*=\**** ***\*function\*******\*(\****e***\*)\**** ***\*{\**** 

​     uploading ***\*=\**** ***\*false\*******\*;\**** 

​     ***\*target\****.classList.remove***\*(\******"uploading"\******);\**** 

​     ***\*target\****.***\*innerHTML\**** ***\*=\**** **"Drop files to upload"\******;\**** 

​    ***\*};\****

​    xhr.send***\*(\****body***\*);\**** 

​    ***\*return\**** ***\*false\*******\*;\****

   ***\*}\**** 

   ***\*target\****.classList.remove***\*(\******"wantdrop"\******);\****

  ***\*}\****

 ***\*}\****

***\*});\****

***\*中止请求\*******\*和\*******\*超时\****

可以通过调用XMLHttpRequest对象的abort()方法来取消正在进行的HTTP请求。abort()方法在所有的XMLHttpRequest版本和XHR2中可用，调用abort()方法在这个对象上触发abort事件。

调用abort()的主要原因是完成取消或超时请求消耗的时间太长或当响应变得无关时。假设使用XMLHttpRequest为文本输入域请求自动完成推荐。如果用户在服务器的建议达到之前输入了新字符，这时等待请求不再有趣，应该中止。

XHR2定义了timeout属性来指定请求自动中止后的毫秒数，也定义了timeout事件用于当超时发生时触发（不是abort事件）。现在，浏览器暂不支持这些自动超时（并且它们的XMLHttpRequest对象没有timeout和ontimeout属性）。可以用setTimeout()和abort()方法实现自己的超时。

**//发起HTTP GET请求获取指定URL的内容**

**//如果响应成功到达，传入responseText给回调函数**

**//如果响应在timeout毫秒内没有到达，中止这个请求**

**//浏览器可能在abort()后触发"readystatechange"**

**//如果是部分请求结果到达，甚至可能设置status属性**

**//所以需要设置一个标记，当部分且超时的响应到达时不会调用回调函数**

**//如果使用load事件就没有这个风险**

***\*function\**** timedGetText***\*(\****url***\*,\**** timeout***\*,\**** callback***\*)\**** ***\*{\**** 

 ***\*var\**** request ***\*=\**** ***\*new\**** XMLHttpRequest***\*();\**** **//创建新请求**

 ***\*var\**** timedout ***\*=\**** ***\*false\*******\*;\**** **//是否超时**

 **//启动计时器，在timeout毫秒后将中止请求**

 ***\*var\**** timer ***\*=\**** ***\*setTimeout\*******\*(\*******\*function\*******\*()\**** ***\*{\**** **//如果触发，启动一个计时器**

   timedout ***\*=\**** ***\*true\*******\*;\**** **//设置标记**

   request.abort***\*();\**** **//然后中止请求**

  ***\*},\**** 

  timeout***\*);\**** **//中止请求之前的时长**

 request.***\*open\*******\*(\******"GET"\******,\**** url***\*);\**** **//获取指定的URL**

 request.onreadystatechange ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** **//定义事件处理程序**

  ***\*if\**** ***\*(\****request.***\*readyState\**** ***\*!==\**** ***\*4\*******\*)\**** ***\*return\*******\*;\**** **//忽略未完成的请求**

  ***\*if\**** ***\*(\****timedout***\*)\**** ***\*return\*******\*;\**** **//忽略中止请求**

  ***\*clearTimeout\*******\*(\****timer***\*);\**** **//取消等待的超时**

  ***\*if\**** ***\*(\****request.***\*status\**** ***\*===\**** ***\*200\*******\*)\**** **//如果请求成功**

   callback***\*(\****request.responseText***\*);\**** **//把response传给回调函数**

 ***\*};\**** 

 request.send***\*(\*******\*null\*******\*);\**** **//立即发送请求**

***\*}\****

***\*跨域HTTP\*******\*请求\****

作为同源策略的一部分，XMLHttpRequest对象通常仅可以发起和文档具有相同服务器的HTTP请求。这个限制关闭了安全漏洞，但它笨手笨脚并且也阻止了大量合适使用的跨域请求。可以在<form>和<iframe>元素中使用跨域URL，而浏览器显示最终的跨域文档。但因为同源策略，浏览器不允许原始脚本查找跨域文挡的内容。使用XMLHttpRequest，文档内容都是通过responseText属性暴露，所以同源策略不允许XMLHttpRequest进行跨域请求。（注意<script>元素并未真正受限于同源策略：它加载并执行任何来源的脚本。跨域请求的灵活性使得<script>元素成为取代XMLHttpRequest的主流Ajax传输协议。）

XHR2通过在HTTP响应中选择发送合适的CORS（Cross-Origin Resource Sharing，跨域资源共享）允许跨域访问网站。在写本书时，Firefox、Safari、Chrome的当前版本都支持CORS，而IE8通过这里没有列出的专用XDomainRequest对象支持它。作为Web程序员，使用这个功能并不需要做什么额外的工作：如果浏览器支持XMLHttpRequest的CORS且实现跨域请求的网站决定使用CORS允许跨域请求，那么同源策略将不放宽而跨域请求就会正常工作。

虽然实现CORS支持的跨域请求工作不需要做任何事情，但有一些安全细节需要了解。首先，如果给XMLHttpRequest的open()方法传入用户名和密码，那么它们绝对不会通过跨域请求发送（这使分布式密码破解攻击成为可能）。除外，跨域请求通常也不会包含其他任何的用户证书：cookie和HTTP身份验证令牌(token)通常不会作为请求的内容部分发送且任何作为跨域响应来接收的cookie都会丢弃。如果跨域请求需要这几种凭证才能成功，那么必须在用send()发送请求前设置XMLHttpRequest的withCredentials属性为true。这样做不常见，但测试withCredentials的存在性是测试浏览器是否支持CORS的一种方法。

下例是常见的JavaScript代码，它使用XMLHttpRequest实现HTTP HEAD请求以下载文档中<a>元素链接资源的类型、大小和时间等信息。这个HEAD请求按需发起，且由此产生的链接信息会出现在工具提示中。这个示例假设跨域链接的信息不可用，但通过支持CORS的浏览器尝试下载它。

**/\****

 *** linkdetails.js**

 *** 这个常见的JavaScript模块查询有href属性但没有title属性的所有<a>元素**

 *** 并给它们注册onmouseover事件处理程序**

 *** 这个事件处理程序使用XMLHttpRequest HEAD请求取得链接资源的详细信息**

 *** 然后把这些详细信息设置为链接的title属性**

 *** 这样它们将会在工具提示中显示**

 ***/** 

whenReady***\*(\*******\*function\*******\*()\**** ***\*{\**** 

 **//是否有机会使用跨域请求?**

 ***\*var\**** supportsCORS ***\*=\**** ***\*(new\**** XMLHttpRequest***\*())\****.withCredentials ***\*!==\**** undefined***\*;\**** 

 **//遍历文档中的所有链接**

 ***\*var\**** ***\*links\**** ***\*=\**** ***\*document\****.getElementsByTagName***\*(\******'a'\******);\**** 

 ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** ***\*links\****.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** 

  ***\*var\**** ***\*link\**** ***\*=\**** ***\*links\*******\*[\****i***\*];\**** 

  ***\*if\**** ***\*(!\*******\*link\****.***\*href\*******\*)\**** ***\*continue\*******\*;\**** **//跳过没有超链接的锚点**

  ***\*if\**** ***\*(\*******\*link\****.***\*title\*******\*)\**** ***\*continue\*******\*;\**** **//跳过已经有工具提示的链接**

  **//如果这是一个跨域链接**

  ***\*if\**** ***\*(\*******\*link\****.***\*host\**** ***\*!==\**** ***\*location\****.***\*host\**** ***\*||\**** ***\*link\****.***\*protocol\**** ***\*!==\**** ***\*location\****.***\*protocol\*******\*)\**** ***\*{\****

   ***\*link\****.***\*title\**** ***\*=\**** **"站外链接"\******;\**** **//假设我们不能得到任何信息**

   ***\*if\**** ***\*(!\****supportsCORS***\*)\**** ***\*continue\*******\*;\**** **//如果没有CORS支持就退出**

   **//否则，我们能了解这个链接的更多信息**

   **//所以继续前进，注册事件处理程序，于是我们可以尝试**

  ***\*}\****

  **//注册事件处理程序，当鼠标悬停时下载链接详细信息**

  ***\*if\**** ***\*(\*******\*link\****.addEventListener***\*)\**** 

   ***\*link\****.addEventListener***\*(\******"mouseover"\******,\**** mouseoverHandler***\*,\**** ***\*false\*******\*);\**** 

  ***\*else\**** 

   ***\*link\****.attachEvent***\*(\******"onmouseover"\******,\**** mouseoverHandler***\*);\**** 

 ***\*}\****

 ***\*function\**** mouseoverHandler***\*(\****e***\*)\**** ***\*{\****

  ***\*var\**** ***\*link\**** ***\*=\**** e.***\*target\**** ***\*||\**** e.***\*srcElement\*******\*;\**** **//<a>元素**

  ***\*var\**** url ***\*=\**** ***\*link\****.***\*href\*******\*;\**** **//链接URL**

  ***\*var\**** req ***\*=\**** ***\*new\**** XMLHttpRequest***\*();\******//新请求**

  req.***\*open\*******\*(\******"HEAD"\******,\**** url***\*);\**** **//仅仅询问头信息**

  req.onreadystatechange ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** **//事件处理程序**

   ***\*if\**** ***\*(\****req.***\*readyState\**** ***\*!==\**** ***\*4\*******\*)\**** ***\*return\*******\*;\**** **//忽略未完成的请求**

   ***\*if\**** ***\*(\****req.***\*status\**** ***\*===\**** ***\*200\*******\*)\**** ***\*{\**** **//如果成功**

​    ***\*var\**** ***\*type\**** ***\*=\**** req.getResponseHeader***\*(\******"Content-Type"\******);\**** **//获取链接的详细情况**

​    ***\*var\**** size ***\*=\**** req.getResponseHeader***\*(\******"Content-Length"\******);\****

​    ***\*var\**** date ***\*=\**** req.getResponseHeader***\*(\******"Last-Modified"\******);\**** 

​    **//在工具提示中显示详细信息**

​    ***\*link\****.***\*title\**** ***\*=\**** **"类型: "** ***\*+\**** ***\*type\**** ***\*+\**** **"\n"** ***\*+\****

​           **"大小: "** ***\*+\**** size ***\*+\**** **"\n"** ***\*+\**** **"时间: "** ***\*+\**** date***\*;\****

   ***\*}\**** ***\*else\**** ***\*{\**** 

​    **//如果请求失败，且链接没有"站外链接"的工具提示**

​    **//那么显示这个错误**

​    ***\*if\**** ***\*(!\*******\*link\****.***\*title\*******\*)\**** 

​     ***\*link\****.***\*title\**** ***\*=\**** **"Couldn't fetch details:\n"** ***\*+\**** 

​            req.***\*status\**** ***\*+\**** **" "** ***\*+\**** req.statusText***\*;\**** 

   ***\*}\****

  ***\*};\****

  req.send***\*(\*******\*null\*******\*);\**** 

  **//移除处理程序: 仅想一次获取这些头信息**

  ***\*if\**** ***\*(\*******\*link\****.removeEventListener***\*)\**** 

   ***\*link\****.removeEventListener***\*(\******"mouseover"\******,\**** mouseoverHandler***\*,\**** ***\*false\*******\*);\**** 

  ***\*else\**** 

   ***\*link\****.detachEvent***\*(\******"onmouseover"\******,\**** mouseoverHandler***\*);\**** 

 ***\*}\****

***\*});\****

 

 

 

 

 

 

 

 

 

 

 

### ***\*JSONP\****

<script>元素可以作为一种Ajax传输机制：只须设置<script>元素的src属性（假如它还没插入到document 中，需要插入进去），然后浏览器就会发送一个HTTP请求以下载src属性所指向的URL。使用<script>元素进行Ajax传输的一个主要原因是，它不受同源策略的影响，因此可以使用它们从其他的服务器请求数据，第二个原因是包含JSON编码数据的响应体会自动解码（即，执行）。

这种使用<script>元素作为Ajax传输的技术称为JSONP，若HTTP请求所得到的响应数据是经过JSON编码的，则适合使用该技术。P代表“填充”或“前缀”。

假设你已经写了一个服务，它处理GET请求并返回JSON编码的数据。同源的文档可以在代码中使用XMLHttpRequest和JSON.parse()，就像下例中的代码一样。假如在服务器上启用了CORS，在新的浏览器下，跨域的文档也可以使用XMLHttpRequest享受到该服务。在不支持CROS的旧浏览器下，跨域文档只能通过<script>元素访问这个服务。使用JSONP，JSON响应数据（理论上）是合法的JavaScript代码，当它到达时浏览器将执行它。相反，不使用JSONP，而是对JSON编码过的数据解码，结果还是数据，并没有做任何事情。

这就是JSONP中P的意义所在。当通过<script>元素调用数据时，响应内容必须用JavaScript函数名和圆括号包裹起来，而不是发送一段JSON数据。

在实践中，支持JSONP的服务不会强制指定客户端必须实现的回调函数名称，比如handleResponse。相反，它们使用查询参数的值，允许客户端指定一个函数名，然后使用函数名去填充响应。

下例使用一个名为jsonp的查询参数来指定回调函数的名称。许多支持JSONP的服务都能分辨出这个参数名。另一个常见的参数名称是callback，为了让使用到的服务支持类似特殊的需求，就需要在代码上做一些修改了。

**//根据指定的URL发送一个JSONP请求**

**//然后把解析得到的响应数据传递给回调函数**

**//在URL中添加一个名为jsonp的查询参数，用于指定该请求的回调函数的名称**

***\*function\**** getJSONP***\*(\****url***\*,\**** callback***\*)\**** ***\*{\**** 

 **//为本次请求创建一个唯一的回调函数名称**

 ***\*var\**** cbnum ***\*=\**** **"cb"** ***\*+\**** getJSONP.counter***\*++;\**** **//每次自增计数器**

 ***\*var\**** cbname ***\*=\**** **"getJSONP."** ***\*+\**** cbnum***\*;\**** **//作为JSONP函数的属性**

 **//将回调函数名称以表单编码的形式添加到URL的查询部分中**

 **//使用jsonp作为参数名，一些支持JSONP的服务**

 **//可能使用其他的参数名，比如callback**

 ***\*if\**** ***\*(\****url.***\*indexOf\*******\*(\******"?"\******)\**** ***\*===\**** ***\*-\*******\*1\*******\*)\**** **// URL没有查询部分**

  url ***\*+=\**** **"?jsonp="** ***\*+\**** cbname***\*;\**** **//作为查询部分添加参数**

 ***\*else\**** **//否则**

  url ***\*+=\**** **"&jsonp="** ***\*+\**** cbname***\*;\**** **//作为新的参数添加它**

 **//创建script元素用于发送请求**

 ***\*var\**** script ***\*=\**** ***\*document\****.createElement***\*(\******"script"\******);\**** 

 **//定义将被脚本执行的回调函数**

 getJSONP***\*[\****cbnum***\*]\**** ***\*=\**** ***\*function\*******\*(\****response***\*)\**** ***\*{\**** 

  ***\*try\**** ***\*{\**** 

   callback***\*(\****response***\*);\**** **//处理响应数据**

  ***\*}\****

  ***\*finally\**** ***\*{\**** **//即使回调函数或响应抛出错误**

   ***\*delete\**** getJSONP***\*[\****cbnum***\*];\**** **//删除该函数**

   script.parentNode.removeChild***\*(\****script***\*);\**** **//移除script元素**

  ***\*}\****

 ***\*};\****

 **//立即触发HTTP请求**

 script.***\*src\**** ***\*=\**** url***\*;\**** **//设置脚本的URL**

 ***\*document\****.body.appendChild***\*(\****script***\*);\**** **//把它添加到文档中**

***\*}\****

getJSONP.counter ***\*=\**** ***\*0\*******\*;\**** **//用于创建唯一回调函数名称的计数器**

### ***\*基于服务器端推送事件的Comet技术\****

在服务器端推送事件的标准草案中定义了一个EventSource对象，简化了Comet应用程序的编写可以传递一个URL给EventSource()构造函数，然后在返回的实例上监听消息事件。

***\*var\**** ticket = new EventSource("stockprices.php");

ticket.onmessage = ***\*function\****(e) {

 ***\*var\**** type = e.type;

 ***\*var\**** data = e.data;

 //现在处理事件类型和事件的字符串数据  

}

与message事件关联的事件对象有一个data属性，这个属性保存服务器作为该事件的负载发送的任何字符串。如同其他类型的事件一样，该对象还有一个type属性，默认值是message，事件源可以修改这个值。onmessage事件处理程序接收从一个给定的服务器事件源发出的所有事件，如果有必要，也可以根据type属性派发一个事件。

服务器端推送事件的协议很简单。客户端（创建一个EventSource对象时会）建立一个到服务器的连接，服务器保持这个连接处于打开状态。当发生一个事件时，服务器端在连接中写入几行文本，抛给客户端的事件可能看起来是这样：

event: bid   设置时间对象的类型

data: GOOD  设置data属性

data: 999   追加新的一行和更多的数据

​        一个空行会触发消息事件

该协议还有一些额外的细节，比如允许事件携带给定ID，然后再次连上的客户端告诉服务器它收到的最后一个事件的ID，这样服务器就可以重新发送客户端错过的事件。但是这些细节在此处并不重要。

Comet架构的一个常见应用是聊天应用，聊天客户端可以通过XMLHttpRequest向聊天室发送新的消息，也可以通过EventSource对象订阅聊天信息。下例展示了使用EventSource写一个聊天客户端是多么容易。

<script> 

***\*window\****.***\*onload\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** 

 **//注意一些UI细节**

 ***\*var\**** nick ***\*=\**** ***\*prompt\*******\*(\******"Enter your nickname"\******);\**** **//获取用户昵称**

 ***\*var\**** input ***\*=\**** ***\*document\****.getElementByld***\*(\******"input"\******);\**** **//找出input表单元素**

 input.***\*focus\*******\*();\**** **//设置键盘焦点**

 **//通过EventSource注册新消息的通知**

 ***\*var\**** chat ***\*=\**** ***\*new\**** EventSource***\*(\******"/chat"\******);\**** 

 chat.onmessage ***\*=\**** ***\*function\*******\*(\*******\*event\*******\*)\**** ***\*{\**** **//当捕获一条消息时**

  ***\*var\**** msg ***\*=\**** ***\*event\****.***\*data\*******\*;\**** **//从事件对象中取得文本数据**

  ***\*var\**** node ***\*=\**** ***\*document\****.createTextNode***\*(\****msg***\*);\**** **//把它放入一个文本节点**

  ***\*var\**** div ***\*=\**** ***\*document\****.createElement***\*(\******"div"\******);\**** **//创建一个<div>**

  div.appendChild***\*(\****node***\*);\**** **//将文本节点插入div中**

  ***\*document\****.body.insertBefore***\*(\****div***\*,\**** input***\*);\**** **//将div插入input之前**

  input.***\*scrollIntoView\*******\*();\**** **//保证input元素可见**

 ***\*}\****

 **//使用XMLHttpRequest把用户的消息发送给服务器**

 input.***\*onchange\**** ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** **//用户完成输入**

  ***\*var\**** msg ***\*=\**** nick ***\*+\**** **": "** ***\*+\**** input.***\*value\*******\*;\**** **//组合用户名和用户输入的信息**

  ***\*var\**** xhr ***\*=\**** ***\*new\**** XMLHttpRequest***\*();\**** **//创建新的XHR**

  xhr.***\*open\*******\*(\******"POST"\******,\**** **"/chat"\******);\**** **//发送到/chat**

  xhr.setRequestHeader***\*(\******"ContentType"\******,\**** **//指明为普通的UTF-8文本**

​         **"text/plain;charset=UTF-8"\******);\**** 

  xhr.send***\*(\****msg***\*);\**** **//发送消息**

  input.***\*value\**** ***\*=\**** **""\******;\**** **//准备下次输入**

 ***\*}\****

***\*};\****

***\*</script>\****

**<!-- 聊天的UI只是一个单行文本域 -->**

**<!-- 新的聊天信息会插入input域之前 -->**

***\*<input\**** ***\*id=\****"input" ***\*style=\****"width:***\*100\****%"***\*/>\****

用XMLHttpRequest模拟EventSource

**//在不支持EventSource API的浏览器里进行模拟**

**//需要有一个XMLHttpRequest对象在新数据写到长期存在的HTTP连接中时发送readystatechange事件**

**//注意，这个API的实现是不完整的**

**//它不支持readyState属性、close()方法、open和error事件**

**//消息事件也是通过onmessage属性注册的一一这个版本还没有定义add EventListener()方法**

***\*if\**** ***\*(\*******\*window\****.EventSource ***\*===\**** undefined***\*)\**** ***\*{\**** **//如果未定义EventSource对象**

 ***\*window\****.EventSource ***\*=\**** ***\*function\*******\*(\****url***\*)\**** ***\*{\**** **//像这样进行模拟**

  ***\*var\**** xhr***\*;\**** **// HTTP连接器**

  ***\*var\**** evtsrc ***\*=\**** ***\*this\*******\*;\**** **//在事件处理程序中用到**

  ***\*var\**** charsReceived ***\*=\**** ***\*0\*******\*;\**** **//这样我们就可以知道什么是新的**

  ***\*var\**** ***\*type\**** ***\*=\**** ***\*null\*******\*;\**** **//检查属性响应类型**

  ***\*var\**** ***\*data\**** ***\*=\**** **""\******;\**** **//存放消息数据**

  ***\*var\**** eventName ***\*=\**** **"message"\******;\**** **//事件对象的类型字段**

  ***\*var\**** lastEventId ***\*=\**** **""\******;\**** **//用于和服务器再次同步**

  ***\*var\**** retrydelay ***\*=\**** ***\*1000\*******\*;\**** **//在多个连接请求之间设置延迟**

  ***\*var\**** aborted ***\*=\**** ***\*false\*******\*;\**** **//设置为true表示放弃连接**

  **//创建一个XHR对象**

  xhr ***\*=\**** ***\*new\**** XMLHttpRequest***\*();\**** 

  **//定义一个事件处理程序**

  xhr.onreadystatechange ***\*=\**** ***\*function\*******\*()\**** ***\*{\**** 

   ***\*switch\*******\*(\****xhr.***\*readyState\*******\*)\**** ***\*{\**** 

​    ***\*case\**** ***\*3\*******\*:\**** processData***\*();\**** ***\*break\*******\*;\**** **//当数据块到达时**

​    ***\*case\**** ***\*4\*******\*:\**** reconnect***\*();\**** ***\*break\*******\*;\**** **//当请求关闭的时候**

   ***\*}\****

  ***\*};\****

  **//通过connect()创建一个长期存在的连接**

  connect***\*();\**** 

  **//如果连接正常关闭，等待1秒钟再尝试连接**

  ***\*function\**** reconnect***\*()\**** ***\*{\**** 

   ***\*if\**** ***\*(\****aborted***\*)\**** ***\*return\*******\*;\**** **//在终止连接后不进行重连操作**

   ***\*if\**** ***\*(\****xhr.***\*status\**** ***\*>=\**** ***\*300\*******\*)\**** ***\*return\*******\*;\**** **//在报错之后不进行重连操作**

   ***\*setTimeout\*******\*(\****connect***\*,\**** retrydelay***\*);\**** **//等待1秒后进行重连**

  ***\*};\****

  **//这里的代码展示了如何建立一个连接**

  ***\*function\**** connect***\*()\**** ***\*{\**** 

   charsReceived ***\*=\**** ***\*0\*******\*;\**** 

   ***\*type\**** ***\*=\**** ***\*null\*******\*;\**** 

   xhr.***\*open\*******\*(\******"GET"\******,\**** url***\*);\**** 

   xhr.setRequestHeader***\*(\******"Cache-Control"\******,\**** **"no-cache"\******);\****

   ***\*if\**** ***\*(\****lastEventId***\*)\**** xhr.setRequestHeader***\*(\******"Last-Event-ID"\******,\**** lastEventId***\*);\**** 

   xhr.send***\*();\****

  ***\*}\**** 

  **//每当数据到达的时候，会处理并触发onmessage处理程序**

  **//这个函数处理Server-Send Events协议的细节**

  ***\*function\**** processData***\*()\**** ***\*{\**** 

   ***\*if\**** ***\*(!\*******\*type\*******\*)\**** ***\*{\**** **//如果没有准备好，先检查响应类型**

​    ***\*type\**** ***\*=\**** xhr.getResponseHeader***\*(\******'Content-Type'\******);\**** 

​    ***\*if\**** ***\*(\*******\*type\**** ***\*!==\**** **"text/event-stream"\******)\**** ***\*{\**** 

​     aborted ***\*=\**** ***\*true\*******\*;\**** 

​     xhr.abort***\*();\**** 

​     ***\*return\*******\*;\****

​    ***\*}\****

   ***\*}\**** 

   **//记录接收的数据**

   **//获得响应中未处理的数据**

   ***\*var\**** chunk ***\*=\**** xhr.responseText.***\*substring\*******\*(\****charsReceived***\*);\**** 

   charsReceived ***\*=\**** xhr.responseText.***\*length\*******\*;\**** 

   **//将大块的文本数据分成多行并遍历它们**

   ***\*var\**** lines ***\*=\**** chunk.***\*replace\*******\*(/(\****\r\n***\*|\****\r***\*|\****\n***\*)$/,\**** **""\******)\****.***\*split\*******\*(/\****\r\n***\*|\****\r***\*|\****\n***\*/);\****

   ***\*for\*******\*(\*******\*var\**** i ***\*=\**** ***\*0\*******\*;\**** i ***\*<\**** lines.***\*length\*******\*;\**** i***\*++)\**** ***\*{\**** 

​    ***\*var\**** line ***\*=\**** lines***\*[\****i***\*],\**** pos ***\*=\**** line.***\*indexOf\*******\*(\******":"\******),\**** ***\*name\*******\*,\**** ***\*value\*******\*=\******""\******;\**** 

​    ***\*if\**** ***\*(\****pos ***\*==\**** ***\*0\*******\*)\**** ***\*continue\*******\*;\**** **//忽略注释**

​    ***\*if\**** ***\*(\****pos ***\*>\**** ***\*0\*******\*)\**** ***\*{\**** **//字段名称：值**

​     ***\*name\**** ***\*=\**** line.***\*substring\*******\*(\*******\*0\*******\*,\****pos***\*);\**** 

​     ***\*value\**** ***\*=\**** line.***\*substring\*******\*(\****pos***\*+\*******\*1\*******\*);\**** 

​     ***\*if\**** ***\*(\*******\*value\****.***\*charAt\*******\*(\*******\*0\*******\*)\**** ***\*==\**** **" "\******)\**** ***\*value\**** ***\*=\**** ***\*value\****.***\*substring\*******\*(\*******\*1\*******\*);\****

​    ***\*}\**** 

​    ***\*else\**** ***\*name\**** ***\*=\**** line***\*;\**** **//只有字段名称**

​    ***\*switch\*******\*(\*******\*name\*******\*)\**** ***\*{\**** 

​     ***\*case\**** **"event"\******:\**** eventName ***\*=\**** ***\*value\*******\*;\**** ***\*break\*******\*;\**** 

​     ***\*case\**** **"data"\******:\**** ***\*data\**** ***\*+=\**** ***\*value\**** ***\*+\**** **"\n"\******;\**** ***\*break\*******\*;\**** 

​     ***\*case\**** **"id"\******:\**** lastEventId ***\*=\**** ***\*value\*******\*;\**** ***\*break\*******\*;\**** 

​     ***\*case\**** **"retry"\******:\**** retrydelay ***\*=\**** ***\*parseInt\*******\*(\*******\*value\*******\*)\**** ***\*||\**** ***\*1000\*******\*;\**** ***\*break\*******\*;\**** 

​     ***\*default\*******\*:\**** ***\*break\*******\*;\**** **//忽略其他行**

​    ***\*}\****

​    ***\*if\**** ***\*(\****line ***\*===\**** **""\******)\**** ***\*{\**** **//一个空行意味着发送事件**

​     ***\*if\**** ***\*(\****evtsrc.onmessage ***\*&&\**** ***\*data\**** ***\*!==\**** **""\******)\**** ***\*{\**** 

​      **//如果末尾有新行，就裁剪新行**

​      ***\*if\**** ***\*(\*******\*data\****.***\*charAt\*******\*(\*******\*data\****.***\*length\*******\*-\*******\*1\*******\*)\**** ***\*==\**** **"\n"\******)\****

​       ***\*data\**** ***\*=\**** ***\*data\****.***\*substring\*******\*(\*******\*0\*******\*,\**** ***\*data\****.***\*length\*******\*-\*******\*1\*******\*);\****

​      evtsrc.onmessage***\*({\**** **//这里是一个伪造的事件对象**

​       ***\*type\*******\*:\**** eventName***\*,\**** **//事件类型**

​       ***\*data\*******\*:\**** ***\*data\*******\*,\**** **//事件数据**

​       origin***\*:\**** url  **//数据源**

​      ***\*});\****

​     ***\*}\****

​     ***\*data\**** ***\*=\**** **""\******;\**** 

​     ***\*continue\*******\*;\****

​    ***\*}\****

   ***\*}\****

  ***\*}\****

 ***\*};\****

***\*}\**** 

我们通过一个服务器示例结束了Comet架构的探讨。下例展示了一个用服务器端JavaScript为Node编写的定制HTTP服务器。当一个客户端请求根URL "/" 时，它会把上例里展示的聊天客户端代码和模拟代码发送到客户端。当客户端创建了一个指向URL "/chat" 的GET请求时，它会用一个数组来保存响应数据流并保持连接处于打开状态。当客户端发起针对"chat" POST请求时，它会将响应的主体部分作为一条聊天消息使用并写入数据，以"data:"作为Server-Sent Events的前缀，添加到每个己打开的响应数据流上。如果安装了Node，那就可以在本地运行这个服务器例子。它监听8000端口，因此在启动服务器之后，就可以用浏览器访问http://localhost:8000来进行聊天。

**//这个例子用的是服务器的JavaScript，运行在NodeJS平台上**

**//该聊天室的实现比较简单，而且是完全匿名的**

**//将新的消息以POST发送到/chat地址，或者以GET形式从同一个URL获取消息的文本/事件流**

**//创建一个GET请求到"/"来返回一个简单的HTML文件**

**//这个文件包括客户端聊天UI**

***\*var\**** http ***\*=\**** require***\*(\******'http'\******);\**** **// NodeJS HTTP服务器API**

**//聊天客户端使用的HTML文件，在下面会用到**

***\*var\**** clientui ***\*=\**** require***\*(\******'fs'\******)\****.readFileSync***\*(\******"chatclient.html"\******);\**** 

***\*var\**** emulation ***\*=\**** require***\*(\******'fs'\******)\****.readFileSync***\*(\******"EventSourceEmulation.js"\******);\**** 

**//ServerResponse对象数组，用于接收发送的事件**

***\*var\**** clients ***\*=\**** ***\*[];\**** 

**//每20秒发送一条注释到客户端**

**//这样它们就不会关闭连接再重连**

***\*setInterval\*******\*(\*******\*function\*******\*()\**** ***\*{\**** 

 clients.forEach***\*(\*******\*function\*******\*(\****client***\*)\**** ***\*{\**** 

  client.***\*write\*******\*(\******":ping?n"\******);\**** 

 ***\*});\**** 

***\*},\**** ***\*20000\*******\*);\**** 

**//创建一个新服务器**

***\*var\**** server ***\*=\**** ***\*new\**** http.Server***\*();\**** 

**//当服务器获取到一个新的请求，运行回调函数**

server.on***\*(\******"request"\******,\**** ***\*function\**** ***\*(\****request***\*,\**** response***\*)\**** ***\*{\**** 

 **//解析请求的URL**

 ***\*var\**** url ***\*=\**** require***\*(\******'url'\******)\****.***\*parse\*******\*(\****request.url***\*);\****

 **//如果请求是发送到"/"，服务器就发送客户端聊天室UI**

 ***\*if\**** ***\*(\****url.***\*pathname\**** ***\*===\**** **"/"\******)\**** ***\*{\**** **//聊天客户端的UI请求**

  response.writeHead***\*(\*******\*200\*******\*,\**** ***\*{\******"Content-Type"\******:\**** **"text/html"\******});\**** 

  response.***\*write\*******\*(\******"<script>"** ***\*+\**** emulation ***\*+\**** **"</script>"\******);\****

  response.***\*write\*******\*(\****clientui***\*);\****

  response.end***\*();\**** 

  ***\*return\*******\*;\****

 ***\*}\**** 

 **//如果请求是发送到"/chat"之外的地址，则返回404**

 ***\*else\**** ***\*if\**** ***\*(\****url.***\*pathname\**** ***\*!==\**** **"/chat"\******)\**** ***\*{\**** 

  response.writeHead***\*(\*******\*404\*******\*);\**** 

  response.end***\*();\**** 

  ***\*return\*******\*;\****

 ***\*}\**** 

 **//如果请求类型是post，那么就有一个客户端发送了一条新的消息**

 ***\*if\**** ***\*(\****request.***\*method\**** ***\*===\**** **"P0ST"\******)\**** ***\*{\**** 

  request.setEncoding***\*(\******"utf8"\******);\**** 

  ***\*var\**** body ***\*=\**** **""\******;\****

  **//在获取到数据之后，将其添加到请求主体中**

  request.on***\*(\******"data"\******,\**** ***\*function\*******\*(\****chunk***\*)\**** ***\*{\**** body ***\*+=\**** chunk***\*;\**** ***\*});\**** 

  **//当请求完成时，发送一个空响应**

  **//并将消息传播到所有处于监听状态的客户端中**

  request.on***\*(\******"end"\******,\**** ***\*function\*******\*()\**** ***\*{\**** 

   response.writeHead***\*(\*******\*200\*******\*);\**** **//响应该请求**

   response.end***\*();\**** 

   **//将消息转换成文本/事件流格式**

   **//确保每一行的前缀都是"data:"**

   **//并以两个换行符结束**

   message ***\*=\**** **'data: '** ***\*+\**** body.***\*replace\*******\*(\******'\n'\******,\**** **'\ndata: '\******)\**** ***\*+\**** **"\r\n\r\n"\******;\**** 

   **//发送消息给所有监听的客户端**

   clients.forEach***\*(\*******\*function\*******\*(\****client***\*)\**** ***\*{\**** client.***\*write\*******\*(\****message***\*);\**** ***\*});\**** 

  ***\*});\****

 ***\*}\****

 **// Otherwise, a client is requesting a stream of messages** 

 ***\*else\**** ***\*{\**** 

  **//如果不是P0ST类型的请求，则客户端正在请求一组消息**

  response.writeHead***\*(\*******\*200\*******\*,\**** ***\*{\******'Content-Type'\******:\**** **"text/event-stream"** ***\*});\**** 

  response.***\*write\*******\*(\******"data: Connected\n\n"\******);\**** 

  **//如果客户端关闭了连接**

  **//从活动客户端数组中删除对应的响应对象**

  request.connection.on***\*(\******"end"\******,\**** ***\*function\*******\*()\**** ***\*{\**** 

   clients.***\*splice\*******\*(\****clients.***\*indexOf\*******\*(\****response***\*),\**** ***\*1\*******\*);\**** 

   response.end***\*();\**** 

  ***\*});\**** 

  **//记下响应对象，这样就可以向它发送未来的消息**

  clients.***\*push\*******\*(\****response***\*);\**** 

 ***\*}\****

***\*});\****

**//启动服务器，监听8000端口，访问http://localhost:8000/来进行使用它**

server.listen***\*(\*******\*8000\*******\*);\**** 

***\*客户端存储\****

客户端存储遵循"同源策略"，因此不同站点的页面是无法互相读取对方存储的数据，而同一站点的不同页面之间是可以互相共享存储数据的，它为我们提供了一种通信机制。

客户端存储有以下几种形式：

l Web存储

l cookie

l IE User Data

l 离线Web应用

l Web数据库

l 文件系统API

 

### ***\*localStorage和sessionStorage\****

实现了"Web存储"草案标准的浏览器在Window对象上定义了两个属性: localStorage和sessionStorage。这两个属性都代表同一个Storage对象——一个持久化关联数组，数组使用字符串来索引，存储的值也都是字符串形式的。

localStorage和sessionStorage两者的区别在于存储的有效期和作用域的不同:数据可以存储多长时间以及谁拥有数据的访问权。

通过localStorage存储的数据是永久性的，除非Web应用刻意删除存储的数据，或者用户通过设置浏览器配置（浏览器提供的特定UI）来删除，否则数据将一直保留在用户的电脑上，永不过期。localStorage的作用域是限定在文档源(document origin)级别的。文档源是通过协议、主机名以及端口三者来确定的。需要注意的是localStorage的作用域也受浏览器供应商限制。

通过sessionStorage存储的数据的有效期和存储数据的脚本所在的最顶层的窗口或者是浏览器标签页是一样的。一旦窗口或者标签页被永久关闭了，那么所有通过sessionStorage存储的数据也都被删除了。sessionStorage的作用域也是限定在文档源中，还被限定在***\*窗口\****中。这里提到的基于窗口作用域的sessionStorage指的窗口只是顶级窗口。

setItem(name, value), getItem(name)

removeItem(name), clear()

length, key(index)

对象和数组类型的值通常是可变的，因此存储对象要求存储它们的副本，以确保之后任何对这类对象的改变都不影响到存储的对象。

其他的存储机制的顶层API对其也是兼容的。下面这段代码使用cookie和IE userData来实现存储API。

//识别出使用的是哪类存储机制

***\*var\**** memory = window.localStorage ||

​      (window.UserDataStorage && new UserDataStorage()) ||

​      new cookieStorage();

//然后在对应的机制中查询数据

***\*var\**** username = memory.getItem("username");

无论什么时候存储在localStorage或者sessionStorage的数据发生改变，浏览器都会在其他对该数据可见的窗口对象上触发存储事件（但是，在对数据进行改变的窗口对象上是不会触发的）。sessionStorage的作用域是限制在顶层窗口的，因此对sessionStorage的改变只有当有相牵连的窗口的时候才会触发存储事件。还有要注意的是，只有当存储数据真正发生改变的时候才会触发存储事件。像给已经存在的存储项设置一个一模一样的值，抑或是删除一个本来就不存在的存储项都是不会触发存储事件的。

与存储事件相关的事件对象有5个非常重要的属性：

l key：被设置或者移除的项的名字或者键名。

l newValue：保存该项的新值

l oldValue：改变或者删除该项前，保存该项原先的值

l storageArea：这个属性值就好比是目标Window对象上的localStorage属性或者是sessionStorage属性。

l url：触发该存储变化脚本所在文挡的URL。

最后要注意的是: localStorage和存储事件都是采用广播机制的，浏览器会对目前正在访问同样站点的所有窗口发送消息。

### ***\*cookie\****

coookie的作用域并不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。如果想要延长cookie的有效期，可以通过设置max-age属性，但是必须要明确告诉浏览器cookie的有效期是多长(单位是秒)。一且设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。

cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。设置cookie的path属性，这样一来，来自同一个Web服务器的Web页面，只要其URL是以指定的路径前缀开始的，都可以共享cookie。如果把路径设置成"/"，那么该cookie对整个网站可见。

cookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。比如， order.example.com域下的服务器想要读取catalog.example.com域下设置的cookie值。这个时候就需要通过设置cookie的domain属性来达到目的。如果domain属性设置成".example.com"，那么该cookie对任何example.com域下的服务器可见。cookie的域只能设置为当前服务器的域。

最后要介绍的cookie的属性是secure ，它是一个布尔类型的属性，用来表明cookie的值以何种形式通过网络传递。cookie默认是以不安全的形式传递的。而一且cookie被标识为"安全的"，那就只能当浏览器和服务器通过HTTPS或者其他的安全协议连接的时候才能传递它。

cookie的设计初衷是给服务端脚本用来存储少量数据的，该数据会在每次请求一个相关的URL时传递到服务器中。RFC 2965鼓励浏览器供应商供应商对cookie的数目和大小不做限制。可是，要知道，该标准不允许浏览器保存超过300个cookie，为每个Web服务器保存的cookie数不能超过20个（是对整个服务器而言，而不仅仅指服务器上的页面和站点），而且，每个cookie保存的数据不能超过4KB（即名字和值的总量不能超过4KB的限制）。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍然有4KB的限制。

### ***\*IE userData\****

 

### ***\*应用程序存储和离线Web应用\****

HTML5 中新增了“应用程序缓存”，允许Web应用将应用程序自身本地保存到用户的浏览器中。

想要将应用程序“安装”到应用程序缓存中，首先要创建一个清单：包含了所有应用程序依赖的所有URL列表。然后，通过在应用程序主HTML页面的<html>标签中设置manifest属性，指向到该清单文件就可以了。

清单文件中的首行内容必须以"CACHE MANIFEST" 字符串开始。其余就是要缓存的文件URL列表，一行一个URL 。相对路径的URL都相对于清单文件的URL。会忽略内容中的空行，会作为注释而忽略以"#"开始的行。注释前面可以有空格，但是在同一行注释后面是不允许有非空字符的。

应用程序缓存清单文件约定以.appcache作为文件扩展名。但是，这也仅仅只是约定而已，Web服务器真正识别清单文件的方式是通过"text/cache-manifest"这个MIME类型的一个清单。如果服务器将清单丈件的Content-Type的头信息设置成其他MIME类型，那么就不会缓存应用程序了。因此，可能需要对Web服务器做一定的配置来使用这个MIME类型，比如，在Web应用目录下创建Apache服务器的一个.htaccess 文件。

一个应用从应用程序缓存中载入的时候，只有其清单文件中列举出来的资源文件会载入。前面例子中的清单文件一次列举一个资源的URL。事实上，清单文件还有比这更复杂的语法，列举资源的方式也还有另外两种。在清单文件中可以使用特殊的区域头来标识该头信息之后清单项的类型。像该例中列举的简单缓存项事实上都属于"CACHE:" 区域，这也是默认的区域。另外两种区域是以"Network:" 和"FALLBACK:" 头信息开始的（一个清单可以有任意数量的区域，而且在相邻两个区域之间可以根据需要相互切换）。

"NETWORK:" 区域标识了该URL中的资源从不缓存，总要通过网络获取。通常，会将一些服务端的脚本资源放在"NETWORK:" 区域中，而实际上该区域中的资源的URL都只是URL前缀，用来表示以此URL前缀开头的资源都应该要通过网络加载。当然，如果浏览器处于离线状态，那么这些资源都将获取失败。"NETWORK:" 区域中的URL还支持"*"通配符。该通配符表示对任何不在清单中的资源，浏览器都将通过网络加载。这实际上违背了这样一条规则:缓存应用程序必须要在清单中列举所有应用相关的资源!

"FALLBACK:" 区域中的清单项每行都包含两个URL。第二个URL是指需要加载和存储在缓存中的资源，第一个URL是一个前缀。任何能够匹配到该前缀的URL都不会缓存起来，但是可能的话，它们会从网络中载入。如果从网络中载入这样一个URL失败的话，就会使用第二个URL指定的缓存资源来代替，从缓存中获取。想象一个Web应用包含一定数量的视频教程。这些视频都很大，显然把它们缓存到本地是不合适的。因此，在离线状态下，通过清单文件中的fallback区域，就可以使用一些机遇文本的帮助文件来代替了。

当一个Web应用从缓存中载入的时候，所有与之相关的文件也是直接从缓存中获取。在线状态下，浏览器会异步地检查清单文件是否有更新。如果有更新，新的清单文件以及清单中列举的所有文件都会下载下来重新保存到应用程序缓存中。但是，要注意的是，浏览器只是检查清单文件，而不会去检查缓存的文件是否有更新：只检查清单文件。比如，如果修改了一个缓存的JavaScript文件，并且要想让该文件生效，就必须去更新下清单文件。由于应用程序依赖的文件列表其实并没有变化，因此最简单的方式就是更新版本号：

CACHE MANIFEST

\# MyApp version 1 （更改这个数字以便让浏览器重新下载这个文件）

MyApp.html

MyApp.js

同样，如果想要让Web应用从缓存中"卸载"，就要在服务器端删除清单文件，使得请求该文件的时候返回HTTP 404无也找到的错误，同时，修改HTML文件以便他们与该清单列表"断开链接"。

要注意的是，浏览器检查清单文件以及更新缓存的操作是异步的，可能是在从缓存中载入应用之前，也有可能同时进行。因此，对于简单的Web应用而言，在更新清单文件之后，用户必须载入应用两次才能保证最新的版本生效:第一次是从缓存中载入老版本随后更新缓存；第二次才从缓存中载入最新的版本。

浏览器在更新缓存过程中会触发一系列事件，可以通过注册处理程序来跟踪这个过程同时提供反馈给用户。如下例所示：

// Notify the user if there is a new version of this application available.

// We could also force a reload here with location.reload()

window.applicationCache.onupdateready = function() {

​    status("A new version of this application is available. Reload to run it");

};

要注意的是，该事件处理程序是注册在ApplicationCache对象上的，该对象是Window的applicationCache属性的值。支持应用程序缓存的浏览器会定义该属性。此外，除了上面例子中的updateready事件之外，还有其他7种应用程序缓存事件可以监控。

每次载入一个设置了manifest属性的HTML文件，浏览器都会触发"checking" 事件，并通过网络载入该清单文件。不过之后，会随着不同的情况触发不同的事件。

l 没有可用的更新

如果应用程序已经缓存并且清单文件没有改动，则浏览器会触发"noupdate" 事件。

l 有可用的更新

如果应用程序已经缓存了并且清单文件发生了改动，则浏览器会触发"downloading" 事件，并开始下载和缓存清单文件中列举的所有资源。随着下载过程的进行，浏览器还会触发"progress" 事件，在下载完成后，会触发"updateready" 事件。

l 首次载入新的应用程序

如果还未缓存应用程序，如上所述，"downloading" 事件和"progress" 事件都会触发。但是，当下载完成后，浏览器会触发"cached" 事件而不是"updateready"事件。

l 浏览器处于离线状态

如果浏览器处于离线状态，它无陆检查清单文件，同时它会触发"error" 事件。如果一个未缓存的应用程序引用一个不存在的情单文件，浏览器也会触发该事件。

l 清单文件不存在

如果浏览器处于在线状态，应用程序也已经缓存起来了，但是清单文件不存在（返回404无法找到错误），浏览器会触发"obsolete"事件，并将该应用程序从缓存中移除。

除了使用事件处理程序之外，还可以使用applicationCache.status属性来查看当前缓存状态。该属性有6个可能的属性值：

ApplicationCache.UNCACHED(0)

应用程序没有设置manifest属性：未缓存

ApplicationCache.IDLE(1)

清单文件已经检查完毕，并且已经缓存了最新的应用程序

ApplicationCache.CHECKING(2)

浏览器正在检查清单文件

ApplicationCache.DOWNLOADING(3)

浏览器正在下载并缓存清单中列举的所有文件

ApplicationCache.UPDATEREADY(4)

已经下载和缓存了最新版的应用程序

ApplicationCache.OBSOLETE(5)

清单文件不存在，缓存将被清除

ApplicationCache对象还定义了两个方法: update()方法显式调用了更新缓存算法以检测是否有最新版本的应用程序。这导致浏览器检测同一个清单文件（并触发相同的事件），这和第一次载入应用程序时的效果是一样的。

还有一个方法是swapCache()，该方法更加巧妙。还记得当浏览器下载并缓存更新版本的应用时，用户仍然在运行老版本的应用吧。只有当用户再次载入应用时，才会访问到最新版本。但是如果用户没有重新载入，就必须要保证老版本的应用也要工作正常。同时要注意的是，老版本应用程序的相关资据可能是从缓存中加载的：比如，应用程序可能使用XMLHttpRequest去获取文件，而这些请求也务必要保证能够从老版本缓存中的文件获取到。因此，浏览器在用户再次载入应用前必须在缓存中保留老版本的应用。

swapCache()方法告诉浏览器它可以弃用老的缓存，所有的请求都从新缓存中获取。要注意的是，这并不会重新载入应用程序：所有已经载入的HTML文件、图片、脚本等资源都不会改变。但是，之后的请求都将从最新的缓存中获取。这会导致“版本错乱”的问题，因此，一般不推荐使用，除非应用程序设计得很好，确保这样的方式没有问题。

要注意的是，只有当状态属性是ApplicationCache.UPDATEREADY或者ApplicationCache.OBSOLETE时，调用swapCache()方法才有意义（当状态是OBSOLETE时，调用swapCache()方法可以立即弃用废弃的缓存，让之后所有的请求都通过网络获取）。如果在状态属性是其他数值的时候调用swapCache()方法，它就会抛出异常。

离线Web应用指的是将自己"安装"在应用程序缓存中的程序，使得哪怕在浏览器处于离线状态时候依然可访问它。

为了在离线状态可用，Web应用需要可以告知别人自己是离线还是在线，同时当网络连接的状态发生改变时候也能"感知"到。通过navigator.onLine属性，可以检测浏览器是否在线，同时，在Window对象上注册在线和离线事件的处理程序，可以检测网络连接状态的改变。

***\*多媒体和图形编程\****

能够在浏览器中动态生成复杂图形是非常重要的，因为：

l 用于在客户端生成图形的代码大小要比图片本身小很多，这样可以减少部分带宽

l 通过一些实时数据来动态生成图形，需要消耗大量的CPU周期。而如果把这个任务放到客户端做，就可以有效地减轻服务器的负担，某种程度上也是节约了硬件开销。

l 在客户端生成图形也是符合现代Web应用的架构：服务器提供数据，然后客户端负责展现这些数据。

 

### ***\*脚本化图片\****

为了有用起见，像图片翻转这样的效果需要较高响应度。这也意味着需要想办法来确保一些必要的图片要预提取，让浏览器缓存起来。客户端JavaScript定义了一个专用的API来达到这一目的：为了强制让图片缓存起来，首先利用Image()构造函数来创建一个屏幕外图片对象，之后，将该对象的src属性设置成期望的URL。由于图片元素并没有添加到文档中，因此，它是不可见的，但是浏览器还是会加载图片并将其缓存起来。这样一来，之后当设置成同样的URL来显示该屏幕内图片的时候，它就能很快从浏览器缓存中加载，而不需要再通过网络加载。

<script>(new Image()).src = "images/help_rollover.gif";</script>

<img src="images/help.gif"

​		onmouseover=***\*"this.src='images/help_rollover.gif'"\****

​	onmouseout=***\*"this.src='images/help.gif'"\****>

优雅的图片翻转实现方式请查看代码

 

### ***\*脚本化音频和视频\****

从理论上说，HTML5引入的<audio>和<video>元素，使用起来和<img>元素一样简单。对于支持HTML5的浏览器，不再需要使用插件（像Flash）来在HTML文档中嵌入音频和视频。

实际上，使用这些元素的时候要更加巧妙。由于各家浏览器制造商未能在对标准音频和视频编解码器支持上达成一致，因此，通常都需要使用<source>元素来指定不同格式的媒体源

支持<audio>和<video>元素的浏览器不会渲染这些元素的内容。而不支持它们的浏览器则会将它们的内容都渲染出来，因此，可以在这些元素中放置后备内容





 <!-- Firefox和Chrome支持的WebM格式-->

 <source src=***\*"news.webm"\**** type=***\*'video/webm; codecs="vp8, vorbis"'\****>

 <!-- IE和Safari支持的H.264格式-->

 <source src=***\*"news.mp4"\**** type=***\*'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'\****>

 <!-- Flash插件作为后备方案-->





  <!--这里的参数元素用于配置Flash视频播放器-->

  <!--文本是最终的后备内容-->



video element not supported and Flash plugin not installed.



 </object>

</video>



<audio controlslist="nodownload" controls="" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 0px;"></audio>



正如可以使用Image()构造函数来创建一张屏幕外图片那样，HTML5 中的媒体API 同样也允许使用Audio()构造函数

new Audio("chime.wav").play(); //载入并播放声音效果

Audio()是音频元素特有的API，换句话说，视频元素是没有类似Video()这样的构造函数的。

想要测试一个媒体元素能否播放指定类型的媒体文件，可以调用canPlayType()方法并将媒体的MIME类型（有时需要包含codec参数）传递进去。如果它不能播放该类型的媒体文件，该方法会返回一个空的字符串（一个假值），反之，它会返回一个字符串:"maybe" 或者"probably"。之所以返回"probably" 这样不确定的结果，是因为音频和视频编解码器本身就非常复杂，在没有真正下载并尝试播放指定类型的媒体前很难确定是否真的可以支持播放此类型文件:

***\*var\**** a ***\*=\**** ***\*new\**** Audio***\*();\****

***\*if\**** ***\*(\****a***\*.\****canPlayType***\*(\****"audio/wav"***\*))\**** ***\*{\****

 a***\*.\****src ***\*=\**** "soundeffect.wav"***\*;\****

 a***\*.\****play***\*();\****

***\*}\****

当设置媒体元素的src属性的时候，加载媒体的过程就开始了（除非将preload设置成"auto"，否则，只会加载少量内容，因此该过程不会持续很长时间）。当设置src属性的时候，如果有其他的媒体文件正在加载或者播放，则会中止它们的加载或者播放过程。如果通过在媒体元素中添加<source>元素而不是设置src属性的方式指定媒体源，媒体元素无法知道是否已经将一系列<source>元素都添加完毕了，因此它也不会开始选择并加载<source>元素指定的媒体源文件，除非显式地调用load()方法。



<audio controlslist="nodownload" controls="" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 0px;"></audio>



// 文档载入完成后，开始播放背景音乐

window.addEventListener("load", ***\*function\****() {

 document.getElementById("music"). play();

}, ***\*false\****);

可以通过设置currentTime属性来进行定点播放。

volume属性表示播放音量，介于0(静音) ~ 1(最大音量)之间。将muted属性设置为true则会进入静音模式，设置为false则会恢复之前指定的音量继续播放。

playbackRate属性用于指定媒体播放的速度。该属性值为1.0表示正常速度，大于1 则表示"快进"，0~1之间的值则表示"慢放"。负值则表示回放。<audio>和<video>元素还有一个defaultPlaybackRate属性。不管是否调用play()方法来播放媒体，playbackRate属性默认值都会被设置成defaultPlaybackRate的值。

loop属性是布尔类型，它指定媒体是否需要循环播放，true表示需要循环播放，false则表示播放到最后就停止。

preload属性指定在用户开始播放媒体前，是否或者多少媒体内容需要预加载。该属性值为"none" 则表示不需要预加载数据。为"metadata" 则表示诸如时长、比特率、帧大小这样的元数据而不是媒体内容需要加载。其实，在不设置preload属性的情况下，浏览器默认也会加载这些元数据的。preload属性值如果为"auto" 则表示浏览器应当预加载它认为适量的媒体内容。

最后，autoplay属性指定当已经缓存足够多的媒体内容时是否需要自动开始播放。将该属性设置为"true" 就等于是告诉浏览器需要预加载媒体内容。



<audio controlslist="nodownload" controls="" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 0px;"></audio>



duration属性指定了媒体的时长，单位是秒。如果在媒体元数据还未载入前查询该属性，它会返回NaN。对于像Internet广播这样有无限时长的流媒体而言，该属性会返回Infinity。

initialTime属性指定了媒体的开始时间，单位也是秒。对于固定时长的媒体剪辑而言，该属性值通常是0。而对于流媒体而言，该属性表示已经缓存的数据的最早时间以及能够回退到的最早时间。当设置currentTime属性时，其值不能小于initialTime的值。

其他三个属性分别指定包含媒体时间轴、播放和缓冲状态的较细粒度视图。played属性返回已经播放的时间段。buffered属性返回当前已经缓冲的时间段，seekable属性则返回当前播放器需要跳到的时间段。（可以使用这些属性来实现一个进度条，显示currentTime、duration以及媒体的播放量和缓冲量。）

played、buffered和seekable都是TimeRanges对象。每个对象都有一个length属性以及start() 和end() 方法，前者表示当前的一个时间段，后者分别返回当前时间段的起始时间点和结束时间点（单位都是秒）。对于一段常见的连续时间段来说，一般使用start(0) 和end(0)。例如，假设媒体文件从开始缓存起中间没有定点播放发生（跳过一段播放），可以使用如下代码来确定当前缓存内容的百分比：

***\*var\**** percent_loaded = Math.floor(song.buffered.end(0) / song.duration * 100);

最后，还有另外三个属性: readyState、networkState和error，它们包含<audio>和<video>元素更加底层的一些状态细节。每个属性都是数字类型的，而且为每个有效值都定义了对应的常量。不过要注意的是，这些常量是定义在媒体对象（或者错误对象）上的。可以按照如下方式来使用一个属性：

***\*if\**** (song.readyState === song.HAVE_ENOUGH_DATA) song.play();

readyState属性指定当前已经加载了多少媒体内容，因此同时也暗示着是否已经准备好可以播放了。如下表格展示了该属性的取值以及对应的意义:

| ***\*常量\****    | ***\*值\**** | ***\*描述\****                                               |
| ----------------- | ------------ | ------------------------------------------------------------ |
| HAVE_NOTHING      | 0            | 没有加载任何媒体内容或者元数据                               |
| HAVE_METADATA     | 1            | 媒体元数据已经加载完毕，但是媒体内容还没有加载。也就是说，这个时候可以获取媒体的时长或者视频文件的维度，以及可以通过设置currentTime来定点播放，不过，由于没有加载任何媒体内容，因此浏览器还是无法从设置的currentTime开始播放 |
| HAVE_CURRENT_DATA | 2            | currentTime的媒体内容已经加载完成，但是还没有加载完足够的内容播放媒体。对于视频文件而言，表示当前帧的数据已经加载完成，但是下一帧的数据还未加载。这种状态通常发生在到达一个音频或者视频文件的最后的时候 |
| HAVE_FUTURE_DATA  | 3            | 已经加载一些的媒体内容，可以开始播放了。但是，还没有达到足够多的内容能够允许流畅地播放全部媒体内容 |
| HAVE_ENOUGH_DATA  | 4            | 所有媒体内容都已经加载完毕，可以流畅地播放（中间没有任何暂停） |

NetworkState属性指定媒体元素是否使用网络或者为什么媒体文件不使用网络:

| ***\*常量\****    | ***\*值\**** | ***\*描述\****                                               |
| ----------------- | ------------ | ------------------------------------------------------------ |
| NETWORK_EMPTY     | 0            | 媒体元素还没有开始使用网络。比如，在还未设置媒体元素的src属性之间，就是这种状态 |
| NETWORK_IDLE      | 1            | 媒体元素当前没有通过网络来加载内容。这种情况有可能是内容已经加载完毕或者是所需的内容都从缓存中直接读取了，又或者是preload属性设置成了"none"，还没有要求加载或者播放媒体 |
| NETWORK_LOADING   | 2            | 媒体元素当前通过网络来加载媒体内容                           |
| NETWORK_NO_SOURCE | 3            | 媒体元素无法获取媒体源                                       |

当在加载媒体或者播放媒体过程中发生错误时，浏览器就会设置<audio>或者<video>元素的error属性。在没有错误发生的情况下，error属性值为null。反之，error的属性值是一个对象，包含了描述错误的数值code属性。同时，error对象也定义了一些描述可能的错误代码的常量：

| ***\*常量\****              | ***\*值\**** | ***\*描述\****                                       |
| --------------------------- | ------------ | ---------------------------------------------------- |
| MEDIA_ERR_ABORTED           | 1            | 用户要求浏览器停止加载媒体内容                       |
| MEDIA_ERR_NETWORK           | 2            | 媒体类型正确，但是发生了网络错误导致无法加载         |
| MEDIA_ERR_DECODE            | 3            | 媒体类型正确，但是由于编码错误导致无法正常解码和播放 |
| MEDIA_ERR_SRC_NOT_SUPPORTED | 4            | 通过src属性指定的媒体文件浏览器不支持，无法播放      |

可以以如下方式使用error属性:

***\*if\**** (song.error.code == song.error.MEDIA_ERR_DECODE) 

 alert("Can't play song: corrupt audio data.");



<audio controlslist="nodownload" controls="" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 0px;"></audio>



| ***\*事件类型\**** | ***\*描述\****                                               |
| ------------------ | ------------------------------------------------------------ |
| loadstart          | 当媒体元素开始请求媒体数据内容的时候触发。相应的networkState属性值为NETWORK_LOADING |
| progress           | 正在通过网络加载媒体内容，对应的networkState属性值为NETWORK_LOADING。此事件一般每秒触发2-8次 |
| loadedmetadata     | 媒体元数据已经加载完成，对应的媒体时长和维度数据也已经获取。此时， readyState属性值第一次变为HAVE_METADATA |
| loadeddata         | 当前播放位置的媒体内容首次加载完毕，同时readyState属性值变为HAVE_CURRENT_DATA |
| canplay            | 已经加载一些媒体内容，可以开始播放，但是还需要继续缓冲更多数据。此时readyState属性值为HAVE_FUTURE_DATA |
| canplaythrough     | 所有媒体内容加载完毕，可以流畅播放，无须暂停也无须再缓冲更多数据。此时readyState属性值为HAVE_ENOUGH_DATA |
| suspend            | 已经缓冲大量数据，暂时停止下载。此时networkState属性值变为NETWORK_IDLE |
| stalled            | 尝试加载数据，但是无法获取到数据。此时networkState始终为NETWORK_LOADING |
| play               | 调用play()方法或者设置相应的autoplay属性。如果已经加载足够多的数据，紧接着还会触发playing事件；否则，紧接着触发waiting事件 |
| waiting            | 由于未缓冲足够数据导致播放未能开始或者播放停止。当缓冲足够多数据后，接着会触发playing事件 |
| playing            | 已经开始播放媒体文件                                         |
| timeupdate         | currentTime属性发生改变了。在一般播放过程中，此事件每秒会触发4-60次，具体次数可能取决于系统加载速度以及事件处理程序处理完成时间 |
| pause              | 调用了pause()方法，暂停了播放                                |
| seeking            | 通过脚本或者用户通过播放控件将当前播放时间调至一个还未缓冲的时间点，导致在内容没有加载完时，停止播放。此时，seeking属性值为true |
| seeked             | seeking属性值又变回false                                     |
| ended              | 媒体播放完毕，播放停止                                       |
| durationchange     | duration属性值发生改变                                       |
| volumechange       | volume或者muted属性值发生改变                                |
| ratechange         | playbackRate或者defaultPlaybackRate发生改变                  |
| abort              | 通常是用户要求停止加载媒体内容。对应的error.code值为MEDIA_ERR_ABORTED |
| error              | 由于发生网络错误或者其他错误阻止媒体内容的加载。此时，error.code 值不会是MEDIA_ERR_ABORTED |
| emptied            | 发生了错误或者中止，导致networkState属性值又变回NETWORK_EMPTY |

 

### ***\*SVG: 可伸缩的矢量图形\****

SVG是一种用于描述图形的XML语曲。顾名思义，其中"vector" 一词表示它完全不同于光栅图像格式，诸如GIF、JPEG和PNG(用像素值来描绘的矩阵)。一个"SVG" 图形是对画该图形时的必要路径的一种精准、分辨率无关(因此是可伸缩的)的描述。

SVG不仅可以用于简单的基本图形的绘制以外，还支持任意曲线、文本以及动圆的绘制。SVG图形甚至还能整合JavaScript脚本和CSS样式表来添加行为和展示信息。

要了解关于SVG的详细内容，可以参阅SVG的标准文档，该文档比较全面地介绍了SVG。这份文档由W3C负责维护，地址在: http://www.w3.org/TR/SVG/。

在新的浏览器中，可以使用普通的<img>元素来展示SVG 图片。而早期的浏览器(比如: Firefox3.6)还不支持SVG，需要使用<object>元素:





当使用<img>或者<object>元素展示SVG图形的时候，SVG就变成了另外一种图片格式了，这种方式对于JavaScript程序员来说是不友好的。更好的方式是直接将SVG 图片嵌入到HTML文档中，这样这些图片就可以通过脚本的方式来控制。

 

### ***\*<canvas> 中的图形\****

<canvas>元素自身是没有任何外观的，但是它在文档中创建了一个画板，同时还提供了很多强大的绘制客户端JavaScript的API。IE9之前的浏览器不支持<canvas>元素，但是可以使用开源的ExplorerCanvas项目(http://code.google.com/p/explorercanvas/) 在IE6-8 中模拟<canvas>元素。

<canvas>元素和SVG之间一个重要的区别是：使用canvas来绘制图形是通过调用它提供的方法而使用SVG绘制图形是通过构建一棵XML元素树来实现的。这两种方式都很强大：两者之间都可以互相模拟。但是，从表面上看，这两者还是不同的，并且各有优劣。比如：使用SVG来绘制图形，可以很简单地通过移除相应的元素来编辑图片。而使用<canvas>来绘制，要移除图片中的元素就不得不把当前的擦除再重新绘制一遍。Canvas的绘制API是基于JavaScript的，并且相对比较简洁(不像SVG语法那么复杂)。

大部分的画布绘制API都不是在<canvas>元素自身上定义的，而是定义在一个"绘制上下文"对象上，获取该对象可以通过调用画布的getContext()方法。调用getContext()方法时，传递一个"2d" 参数，会在得一个CanvasRenderingContext2D对象，使用该对象可以在画布上绘制二维图形。这里很重要的一点是要搞清楚，画布元素和它的上下文对象是两个完全不同的对象。由于CanvasRenderingContext2D名字太长了，因此这里做个约定，统一简称为"上下文对象"。同样地，"画布API" 指的也就是CanvasRenderingContext2D对象的方法。

浏览器提供商正在开始实现<canvas>元素用于绘制3D图形的API。这些API称为："WebGL"，它是绑定到OpenGL标准API的一个JavaScript。

要在画布上绘制线段以及填充这些线段闭合的区域，从定义一条路径开始。路径有许多子路径组成，子路径又是由两个或多个点之间连接而成的线段组成。调用beginPath()方法开始定义一条新的路径，而调用moveTo()方法则开始定义一条新的子路径。一且使用moveTo()方法确定了子路径的起点，接下来就可以调用lineTo()方法来将该点与新的一个点通过直线连接起来。

要在路径中绘制（或者勾勒）两条线段，可以通过调用stroke()方法，要填充这些线段闭合的区域可以通过调用fill()方法。

可以调用closePath()方法将子路径的起点和终点真正连接起来。

关于stoke()方法和fill()方法还有另外非常重要的两点。第一点是：这两个方法都是作用在当前路径上的所有子路径。第二点是：stroke()方法和fill()方法都不更改当前路径。

要检测一个点P是否在路径的内部，使用非零绕数原则：想象一条从点P 出发沿着任意方向无限延伸（或者一直延伸到路径所在的区域外某点）的射线。现在从0开始初始化一个计数器，然后对所有穿过这条射线的路径进行枚举。每当一条路径顺时针方向穿过射线的时候，计数器就加1；反之，就减1。最后，枚举完所有的路径之后，如果计数器的值不是0，那么就认为P是在路径内。反之，如果计数器的位是0，则认为P在路径外。

画布API 中在CanvasRenderingContext2D对象上定义了15个图形属性。

| ***\*属性\****           | ***\*含义\****                     |
| ------------------------ | ---------------------------------- |
| fillStyle                | 填充时候的颜色、渐变或图案等样式   |
| font                     | 绘制文本时候的CSS字体              |
| globalAlpha              | 绘制像素时候要添加的透明度         |
| globalCompositeOperation | 如何合并新的像素点和下面的像素点   |
| lineCap                  | 如何渲染线段的末端                 |
| lineJoin                 | 如何渲染顶点                       |
| lineWidth                | 外框线的宽度                       |
| miterLimit               | 紧急斜接顶点的最大长度             |
| textAlign                | 文本水平对齐方式                   |
| textBaseline             | 文本垂直对齐方式                   |
| shadowBlur               | 阴影的清晰或模糊程度               |
| shadowColor              | 下拉阴影的颜色                     |
| shadowOffsetX            | 阴影的水平偏移量                   |
| shadowOffsetY            | 阴影的垂直偏移量                   |
| strokeStyle              | 勾勒线段时的颜色、渐变或图案等样式 |

每个<canvas>元素只有一个上下文对象，因此每次调用getContext()方法都会返回相同的CanvasRenderingContext2D对象。

尽管画布API只允许一次设置单一的图形属性集合，但是它允许保存当前图形状态，这样就可以在多个状态之间切换，之后也可以很方便地恢复。调用save()方法会将当前图形状态压入用于已保存状态的栈上。调用restore()方法会从栈中弹出并恢复最近一次保存的状态。

<canvas>元素的width以及height属性和对应的画布对象的宽度以及高度属性决定了画布的尺寸。画布的尺寸是不能随意更改的，除非完全重置画布。重置画布的width属性或者height属性(哪怕重置的时候属性值不变)，都会清空整个画布，擦除当前的路径并且会重置所有的图形属性(包括当前的变换和裁剪区域)为初始状态。

默认情况下，<canvas>会按照它设置的HTML width和height属性值来显示画布大小(以css像素为单位)。但是，和其他HTML元素一样，<canvas>元素还可以通过css 的width和height样式属性来设置它的屏幕显示大小。如果指定画布的屏幕显示大小和它的实际尺寸不同，那么画布上所有的像素都会自动缩放以适合通过css属性指定的屏幕显示尺寸。画布的屏幕显示大小不会影响画布位图的css像素或者硬件像素的个数，它的缩放是采用图片缩放方式处理的。如果屏幕显示尺寸要远远大于画布的实际尺寸，那么会导致像素化图形。

***\*经验总结\****

### ***\*ActiveXObject\****

示例

function calling() {

 try {

  var wsh = new ActiveXObject("WScript.shell");

  var reg = wsh.RegRead("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{F231F7C1-E4F3-4ABE-A0E4-E8C882975094}_is1\InstallLocation");

  var a = reg + "AutoRun.exe";

  var b = a.indexOf('Program Files');

  if (b > 1) {

   a = a.replace("Program Files", "Progra~1");

  }

  wsh.Run(a);//运行程序

 } catch (e) { 

  alert("Internet选项-->安全-->自定义级别--> 对没有标记为安全的ActiveX控件进行初始化和脚本运行-->启用!"); 

 }

}

function getExplorer() {

 var explorer = window.navigator.userAgent;

 //ie 

 if (explorer.indexOf("MSIE") >= 0) {

  alert("ie");

 }

 //firefox 

 else if (explorer.indexOf("Firefox") >= 0) {

  alert("Firefox");

 }

 //Chrome

 else if (explorer.indexOf("Chrome") >= 0) {

  alert("Chrome");

 }

 //Opera

 else if (explorer.indexOf("Opera") >= 0) {

  alert("Opera");

 }

 //Safari

 else if (explorer.indexOf("Safari") >= 0) {

  alert("Safari");

 }

 var myShell = new ActiveXObject("wscript.shell");

 myShell.Run("E:/firefox/firefox.exe http://www.baidu.com");//指定用firefox浏览器打开baidu首页

}

### ***\*获取JS对象\****

首先声明的是：

document.getElementByName方法没有。

document.getElement***\*s\****TagName得到的是标签的数组

document.getElementId得到的是某一个标签





​	<input name="content" type="text"/>

</form>

然而可以用很浅显的方式得到如：

var fn = document.getElementsByName("form_write")[0]; //得到这个form下的对象

fn.content.value;//就直接去用这个对象取值就可以了。

1、getElementById 

作用：一般页面里ID是唯一的，用于准备定位一个元素

语法：document.getElementById(id) 

参数：id :必选项为字符串(String) 

返回值：对象; 返回相同id对象中的第一个，按在页面中出现的次序,如果无符合条件的对象，则返回 null 

example：document.getElementById("id1").value; 

2、getElementsByName 

作用：按元素的名称查找，返回一个同名元素的数组

语法：document.getElementsByName(name) 

参数：name :必选项为字符串(String) 

返回值：数组对象；如果无符合条件的对象，则返回空数组，按在页面中出现的次序

注意：返回数组值为value属性的值，如果某标签无value属性，当你添加上value属性并赋值后，getElementsByName也能取到其值，当未对value属性赋值时，getElementsByName返回数组值将是undefined，但仍能获得相同name标签的个数document.getElementsByName(name).length 

当未设置name属性时document.getElementsByName仍能使用，它将根据你id取得value属性的值

example：

document.getElementsByName("name1")[0].value; 

document.getElementsByName("name1")[1].value; 

全部" 

全部" 

span标签其实没有name和value属性

但document.getElementsByName("CBylawIndexName")仍将取得value的值

3、getElementsByTagName 

作用：按HTML标签名查询，返回一个相同标签元素的数组

语法： object.getElementsByTagName(tagname) 

object可以是document或event.srcElement.parentElement等

参数：tagname:必选项为字符串(String)，根据HTML标签检索。

返回值：数组对象; 如果无符合条件的对象，则返回空数组，按在页面中出现的次序

example：

document.getElementsByTagName("p")[0].childNodes[0].nodeValue; 

document.getElementsByTagName("p")[1].childNodes[0].nodeValue; 













***\*附录\****

 

***\*转义字符表\****

| ***\*转义字符\**** | ***\*含义\****                      |
| ------------------ | ----------------------------------- |
| \o                 | NUL字符(\u0000)                     |
| \b                 | 退格符(\u0008)                      |
| \t                 | 水平制表符(\u0009)                  |
| \n                 | 换行符(\u000A)                      |
| \v                 | 垂直制表符(\u000B)                  |
| \f                 | 换页符(\u000C)                      |
| \r                 | 回车符(\u000D)                      |
| "                  | 双引号(\u0022)                      |
| '                  | 撇号或单引号(\u0027)                |
| \                  | 反斜线(\u005C)                      |
| \xXX               | 由两位16进制数XX指定的Latin-1字符   |
| \uXXXX             | 由四位16进制数XXXX指定的Unicode字符 |

 

***\*类型转换\****

| ***\*值\****                                                 | ***\*转换为字符串\****              | ***\*数字\**** | ***\*布尔值\****            | ***\*对象\****                                               |
| ------------------------------------------------------------ | ----------------------------------- | -------------- | --------------------------- | ------------------------------------------------------------ |
| undefinednull                                                | "undefined""null"                   | NaN0           | falsefalse                  | throws TypeErrorthrows TypeError                             |
| truefalse                                                    | "true""false"                       | 10             |                             | new Boolean(true)new Boolean(false)                          |
| ""（空字符串）"1.2"（非空，数字）"one"（非空，非数字）       |                                     | 01.2NaN        | falsetruetrue               | new String("")new String("1.2")new String("one")             |
| 0-0NaNInfinity-Infinity1（无穷大，非零）                     | "0""0""NaN""Infinity""-Infinity""1" |                | falsefalsefalsetruetruetrue | new Number(0)new Number(-0)new Number(NaN)new Number(Infinity)new Number(-Infinity)new Number(1) |
| {}（任意对象）[]（任意数组）[9]（1个数字元素）['a']（其它数组）function(){}（任意函数） | """9"使用join()方法                 |                | truetruetruetruetrue        |                                                              |

转换为数字的情形比较微妙。那些以数字表示的字符串可以直接转换为数字，也***\*允许在开始和结尾处带有空格\****。但在开始和结尾处的任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN。有一些数字转换看起来让人奇怪：true转换为1，false、空字符串("")转换为0。

尽管JavaScript可以自动做许多类型转换，但有时仍需要做显式转换，或者***\*为了使代码变得清晰易读而做显式转换\****。

做显式类型转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数。***\*当不通过new运算符调用这些函数时，它们会作为类型转换函数\****。

需要注意的是，除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String() 方法的返回结果一致。同样需要注意的是，如果试图将null或undefined转换为对象，则会抛出一个类型错误(TypeError)。Object()函数在这种情况下不会抛出异常：它仅简单地返回一个新创建的空对象。

JavaScript中的某些运算符会做隐式的类型转换。如果"+"运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元"+"运算符将其操作数转换为数字。同样，一元"!"运算符将其操作数转换为布尔值并取反。

Number类定义的toString()方法可以接收表示转换基数(radix)的可选参数，如果不指定此参数，转换规则将是基于十进制。同样，亦可以将数字转换为其他进制数（范围在2-36之间）。

var n = 17; 

binary_string = n.toString(2);     //转换为"10001"

octal_string = "0" + n.toString(8);   //转换为"021"

hex_string = "0x" + n.toString(16);   //转换为"0x11"

当处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数记数法。Number类为这种数字到字符串的类型转换场景定义了三个方法。toFixed()根据小数点后的指定位数将数字转换为字符串，它从不使用指数记数法。toExponential()使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定（也就是说有效数字位数比指定的位数要多一位）， toPrecision()根据指定的有效数字位数将数字转换成字符串。如果有效数字的位数少于数字整数部分的位数，则转换成指数形式。我们注意到，所有三个方法都会适当地进行四舍五入或填充0 。看一下下面几个例子：

***\*var\**** n = 123456.789;

n.toFixed(0);     //"1234567"

n.toFixed(2);     //"123456.79"

n.toFixed(5);     //"123456.78900"

n.toExponential(1);  //"1.2e+5"

n.toExponential(3);  //"1.235e+5"

n.toPrecision(4);   //"1.235e+5"

n.toPrecision(7);   //"123456.8"

n.toPrecision(10);  //"123456.7890"

如果通过Number()转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符。parseInt()函数和parseFloat()函数（它们是全局函数，不从属于任何类的方法）更加灵活。parseInt()只解析整数，而parseFloat()则可以解析整数和浮点数。如果字符串前缀是"0x"或者"0X"，parseInt()将其解释为十六进制数，parseInt()和parseFloat()都会***\*跳过任意数量的前导空格\****，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回NaN。

parseInt("3 blind mice")   // => 3

parseFloat(" 3.14 meters")  // => 3.14

parseInt("-12.34")      // => -12

parseInt("0xFF")       // => 255

parseInt("0xff")       // => 255

parseInt("-0XFF")      // => -255

parseFloat(".1")       // => 0.1

parseInt("0.1")       // => 0

parseInt(".1")        // => NaN: 整数不能以"."开始

parseFloat("$72.47");    // => NaN: 数字不能以"$"开始

parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2-36。

parseInt("11", 2);   // => 3 (1*2 + 1)

parseInt ("ff", 16);  // => 255 (15*16 + 15)

parseInt("zz", 36);  // => 1295 (35*36 + 35)

parseInt("077", 8);  // => 63 (7*8 + 7)

parseInt("077", 10);  // => 77 (7*10 + 7)

对象到布尔值的转换非常简单：所有的对象（包括数组和函数）都转换为true。对于包装对象亦是如此：***\*new Boolean(false)\**** 是一个对象而不是原始值，它将转换为true。

对象到字符串(object-to-string)和对象到数字(object-to-number)的转换是通过调用待转换对象的一个方法来完成的。一个麻烦的事实是，JavaScript对象有两个不同的方法来执行转换，并且接下来要讨论的一些特殊场景更加复杂。值得注意的是，这里提到的字符串和数字的转换规则只适用于本地对象(native object)。宿主对象（例如，由Web浏览器定义的对象）根据各自的算法可以转换成字符串和数字。

所有的对象继承了两个转换方法。第一个是toString()，它的作用是返回一个反映这个对象的字符串。默认的toString()方法并不会返回一个有趣的值。

({X:1, y:2}).toString()       // =>"[object Object]"

[1,2,3].toString()         // =>"1, 2, 3"

(***\*function\****(x) { f(x); }).toString() // =>"function(x) {\n f(x);\n}"

/\d+/g.toString()          // =>"/\d+/g"

new Date(2010,0,1).toString()    // =>"Fri Jan 01 2010 00:00:00 GMT-0800 (PST)"

另一个转换对象的函数是valueOf()。这个方法的任务并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回对象本身。***\*日期类定义的valueOf()方法会返回它的一个内部表示：1970年1 月1 日以来的毫秒数\****。

***\*var\**** d = new Date(2010, 0, 1); // 2010年1 月1 日（太平洋时间）

d.valueOf()          // => 1262332800000

通过使用我们刚刚讲解过的toString()和valueOf()方法，就可以做到对象到字符串和对象到数字的转换了。但需要注意的是，在某些特殊的场景中，JavaScript执行了完全不同的对象到原始值的转换。

JavaScript中***\*对象到字符串的转换\****经过了如下这些步骤：

l 如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。

l 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。如果存在这个方法，则JavaScript调用它。如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。

l 否则，JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。

在***\*对象到数字的转换\****过程中，JavaScript做了同样的事情，只是它会首先尝试使用valueOf()方法：

l 如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回这个数字。

l 否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回

l 否则，JavaScript抛出一个类型错误异常。

对象转换为数字的细节解释了为什么空数组会被转换为数字，以及为什么具有单个元素的数组同样会转换成一个数字。数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法。空数组转换成为空字符串，空字符串转换成为数字0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素，这个数字转换为字符串，再转换回数字。

***\*var\**** now = new Date();  // 创建一个日期对象

typeof (now + 1)    // => "string": "+"将日期转换为字符串

typeof (now - 1)    // => "number": "-"使用对象到数字的转换

now == now.toString()  // => true: 隐式的和显式的字符串转换

now > (now -1)     // => true: ">"将日期转换为数字

示例：

null、0、NaN和空字符串转化成false，其他所有的值都会转化成true。

===精确相等（值和类型），!==不精确相等

'5' * 5 = 25

null + 's' = 'nulls'

's' * 5 = NaN

 

 

***\*总结\****

\1. 在ECMAScript3中，字符串直接量必须写在一行中，而在ECMAScript5中，字符串直接量可以拆分成数行，每行以 ***\**\*** 结束，反斜线和行结束符都不算是字符串直接量的内容。如果希望在字符串直接量中另起一行，可以使用转义字符\n。

\2. 在JavaScript中，字符串是固定不变的，可以看成是只读数组。通过调用API返回的字符串一般都是一个新字符串。

\3. 任意JavaScript的值都可以转换为布尔值：undefined、null、0、-0、NaN、"" 会被转换为false，所有其他值，包括所有对象（数组）都会转换成true。

\4. null和undefined

null是JavaScript语言的关键字，它表示一个特殊值，常用来描述“***\*空值\****”。对null执行typeof预算，结果返回字符串"object" ，也就是说，可以将null认为是一个特殊的对象值，含义是“***\*非对象\****”。但实际上，通常认为null是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。

JavaScript还有第二个值来表示值的空缺。用未定义的值表示更深层次的“空值”。它是变量的一种取值，表明变量***\*没有初始化\****，如果要查询对象属性或数组元素的值时返回undefined则说明这个属性或元素不存在。如果函数没有返回任何值，则返回undefined。引用没有提供实参的函数形参的值也只会得到undefined。undefined是预定义的全局变量（它和null不一样，它不是关键字），它的值就是“***\*未定义\****”。

尽管null和undefined是不同的，但它们都表示“***\*值的空缺\****”，两者往往可以互换。判断相等运算符"=="认为两者是相等的（要使用严格相等运算符"==="来区分它们）。在希望值是布尔类型的地方它们的值都是***\*假\****值，和false 类似。null和undefined都不包含任何属性和方法。实际上，使用"."和"[]"来存取这两个值的成员或方法都会产生一个类型错误。

\5. 全局对象

global object在JavaScript中有着重要的用途：全局对象的属性是全局定义的符号，JavaScript程序可以***\*直接使用\****。当JavaScript解释器启动时（或者任何Web浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性：

l 全局属性，比如undefined、Infinity和NaN

l 全局函数，比如isNaN()、parseInt()、eval()

l 构造函数，比如Date()、RegExp()、String()、Object()、Array()

l 全局对象，比如Math和JSON

全局对象的初始属性并不是保留字，但它们应该当做保留字来对待。

在代码的最顶级一一不在任何函数内的JavaScript代码一一可以使用JavaScript关键字this来引用全局对象：

var global = this; // 定义一个引用全局对象的全局变量

在客户端JavaScript中，在其表示的浏览器窗口中的所有JavaScript代码中，Window对象充当了全局对象。这个全局Window对象有一个属性window引用其自身，它可以代替this来引用全局对象。Window对象定义了核心全局属性，但它也针对Web浏览器和客户端JavaScript定义了一少部分其他全局属性。

当初次创建的时候，全局对象定义了JavaScript中所有的预定义全局值。这个特殊对象同样包含了为程序定义的全局值。如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性。JavaScript全局变量是全局对象的属性，这是在ECMAScript规范中强制规定的。

当使用var声明一个变量时，创建的这个属性是***\*不可配置\****的，也就是说这个变量无法通过delete运算符删除。可能你已经注意到了，如果你没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们。

**6.** ***\*★\**** 包装对象

字符串既然不是对象，为什么它会有属性呢？只要引用了字符串的属性，JavaScript就会将字符串值通过调用new 5tring(s)的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁(其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样)。

同字符串一样，数字和布尔值也具有各自的方提:通过Number()和Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。null和undefined没有包装对象：访问它们的属性会造成一个类型错误。

var s = "test"; //创建一个字符串

s.len = 4;    //给它设置一个属性

var t = s.len;  //查询这个属性

当运行这段代码时，t的值是undefined。第二行代码创建一个临时字符串对象，并给其len属性赋值为4 ，随即销毁这个对象。第三行通过原始的（没有被修改过）字符串值创建一个新字符串对象，尝试读取其len属性，这个属性自然不存在，表达式求值结果为undefined。这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的像对象一样。但如果你试图给其属性赋值，则会***\*忽略\****这个操作：修改只是发生在临时对象身上，而这个临时对象并未继续保留下来。

存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。通常，包装对象只是被看做是一种实现细节，而不用特别关注。由于字符串、数字和布尔值的属性都是只读的，并且不能给它们定义新属性，因此你需要明白它们是有别于对象的。

需要注意的是，可通过String()，Number()或Boolean()构造函数来显式创建包装对象。

"=="等于运算符将原始值和其包装对象视为相等，但"==="全等运算符将它们视为不等。通过typeof运算符可以看到原始值和其包装对象的不同。

\7. 原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）

原始值不可更改：数字和布尔值显然如此，字符串就不那么明显了。

因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，JavaScript禁止这样做。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串。

原始值的比较是值的比较。对象和原始值不同，首先，它们是可变的一一它们的值是可修改的。对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，它们也可能是不相等的。

我们通常将对象称为***\*引用类型\****(reference type)，以此来和JavaScript的基本类型区分。依照术语的叫法，对象值都是引用(reference)，对象的比较均是引用的比较：当且仅当它们引用同一个对象时，它们才相等。

将对象（或数组）赋值给一个变量，仅仅是赋值的引用值：对象本身并没有复制一次。如果你想得到一个对象或数组的副本，则必须显式复制对象的每个属性或数组的每个元素。同样的，如果我们想比较两个单独的对象或者数组，则必须比较它们的属性或元素。

**8.** ***\*★\**** 变量作用域

***\*在函数体内，局部变量的优先级高于同名的全局变量\****。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。

在全局作用域编写代码时可以不写var语句，但声明局部变量时则必须使用var语句。

scope ***\*=\**** "global"***\*;\**** //声明一个全局变量，甚至不用var来声明***\*function\**** checkscope2***\*()\**** ***\*{\**** scope ***\*=\**** "local"***\*;\**** //糟糕！我们刚修改了全局变量	myscope ***\*=\**** "local"***\*;\**** //这里显式地声明了一个新的全局变量	***\*return\**** ***\*[\****scope***\*,\**** myscope***\*];\****//返回两个值***\*}\****	checkscope2***\*()\**** // => ["local" , "local"]: 产生了副作用scope // => "local": 全局变量修改了myscope // => "local": 全局命名空间搞乱了

***\*声明提前\****

JavaScript中没有块级作用域，取而代之地使用了函数作用域(function scope)：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

***\*function\**** test***\*(\****o***\*)\**** ***\*{\**** ***\*var\**** i ***\*=\**** 0***\*;\**** // i 在整个函数体内均是有定义的	***\*if\**** ***\*(\*******\*typeof\**** o ***\*==\**** "object"***\*)\**** ***\*{\**** 	***\*var\**** j ***\*=\**** 0***\*;\**** // j在函数体内是有定义的，不仅仅是在这个代码段内		***\*for\*******\*(\*******\*var\**** k***\*=\****0***\*;\**** k***\*<\****10***\*;\**** k***\*++)\**** ***\*{\**** // k在函数体内是有定义的，不仅仅是在循环内			console***\*.\****log***\*(\****k***\*);\**** //输出数字0-9		***\*}\**** 	console***\*.\****log***\*(\****k***\*);\**** // k已经定义了，输出10	***\*}\**** console***\*.\****log***\*(\****j***\*);\**** // j已经定义了，但可能没有初始化***\*}\****

JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式地称为***\*声明提前\****(hoisting)，即***\*JavaScript函数里声明的所有变量\*******\*（\*******\*但不涉及赋值\*******\*）\*******\*都被\*******\*“\*******\*提前\*******\*”\*******\*至函数体的顶部\****。

“声明提前”这步操作是在JavaScript引擎的“预编译”时进行的，在代码开始运行之前。

***\*var\**** scope ***\*=\**** "global"***\*;\*******\*function\**** f***\*()\**** ***\*{\**** console***\*.\****log***\*(\****scope***\*);\**** //输出"undefined"，而不是"global"	***\*var\**** scope ***\*=\**** "local"***\*;\**** //变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的	console***\*.\****log***\*(\****scope***\*);\**** //输出"local"***\*}\****

当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除。可能你已经注意到了，如果你没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们:

***\*var\**** truevar = 1;    // 声明一个不可删除的全局变量

fakevar = 2;      // 创建全局对象的一个可删除的属性

***\*this\****.fakevar2 = 3;   // 同上

***\*delete\**** truevar     // => false: 变量并没有被删除

***\*delete\**** fakevar     // => true: 变量被删除

***\*delete\**** ***\*this\****.fakevar2  // => true: 变量被删除

***\*作用域链\****

每一段JavaScript代码（全局代码或函数）都有一个与之关联的***\*作用域链\****(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值的时候（这个过程称做“变量解析”(variable resolution)），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性X，那么就认为这段代码的作用域链上不存在X，并最终抛出一个引用错误(ReferenceError)异常。

在JavaScript的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解作用域链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别（在每次调用外部函数时，内部函数的代码都是相同的），而关联这段代码的作用域链也不相同。

作用域链的概念对于理解with语句是非常有帮助的，同样对理解闭包的概念也至关重要。

\9. 表达式和运算符

表达式(expression)是JavaScript中的一个短语，JavaScript解释器会将其计算(evaluate)出一个结果。将简单表达式组合成复杂表达式最常用的方法就是使用运算符(operator)。

***\*原始表达式\****

原始表达式是表达式的最小单位一一它们不再包含其他表达式。

l 直接量：1.23  "hello"  /pattern/

l 保留字：true  false  null  this

l 变量：i  sum  undefined

***\*对象和数组的初始化表达式\****

对象和数组初始化表达式实际上是一个新创建的对象和数组。这些初始化表达式有时称做“对象直接量”和“数组直接量”。

l [] //一个空数组：[]内留空即表示该数组没有任何元素

l [1+2,3+4] //拥有两个元素的数组，第一个是3，第二个是7

l var matrix = [[1,2,3],[4,5,6],[7,8,9]]; // 数组初始化表达式中的元素初始化表达式也可以是数组初始化表达式。也就是说，这些表达式是可以嵌套的

l var sparseArray = [1,,,,5]; //数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值undefined。数组直接量的元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值为undefined的元素。

l var p = { x:2.3, y:-1.2 }; //一个拥有两个属性成员的对象

l var q = {}; //一个空对象

l q.x = 2.3; q.y = -1.2; //q的属性成员和p的一样

l var rectangle = { upperLeft: { x: 2, y: 2 }, lowerRight: { x: 4, y: 5 } }; //对象直接量也可以嵌套

l var side = 1; 

var square = { "upperLeft": { x: p.x, y: p.y }, 'lowerRight': { x: p.x + side, y: p.y + side}};

对象直接量中的属性名称可以是字符串而不是标识符（这在那些只能使用保留字或一些非捷标识符作为属性名的地方非常有用）。

### ***\*函数定义表达式\****

函数定义表达式定义一个JavaScript函数。表达式的值是这个新定义的函数。从某种意义上讲，函数定义表达式可称为“函数直接量”，毕竟对象初始化表达式也称为“对象直接量”。一个典型的函数定义表达式包含关键字function，跟随其后的是一对圆括号，括号内是一个以逗号分割的列表，列表含有0个或多个标识符(参数名)，然后再跟随一个由花括号包裹的JavaScript代码段(函数体)，例如：

//这个函数返回传入参数值的平方

***\*var\**** square = ***\*function\****(x) { ***\*return\**** x * x; }

函数定义表达式同样可以包含函数的名字。函数也可以通过函数语句来定义，而不是函数表达式。

### ***\*属性访问表达式\****

属性访问表达式运算得到一个对象属性或一个数组元素的值。JavaScript为属性访问定义了两种语法：

expression.identifier

expression[expression]

第二种写法更灵活，可以针对属性名称是关键字或者不确定属性名称的情况。

### ***\*调用表达式\****

JavaScript 中的调用表达式(invocation expression)是一种调用(或者执行)函数或方法的语法表示。

l f(o) //f是一个函数表达式，o是一个参数表达式

l Math.max(x,y,z) // Math.max 是一个函数; x, y 和z 是参数

l a.sort() // a.sort是一个函数，它没有参数

任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。如果这个表达式是一个属性访问表达式，那么这个调用称做"方法调用" (method invocation) 。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this 的指向。这种特性使得在面向对象编程范例中，函数(其OO名称为"方法" )可以调用其宿主对象。

并不是方法调用的调用表达式通常使用全局对象作为this 关键字的值。然而在ECMAScript 5中，那些通过严格模式定义的函数在调用时将使用undefined作为this 的值， this不会指向全局对象。

### ***\*对象创建表达式\****

对象创建表达式(object creation expression) 创建一个对象并调用一个函数(这个函数称做构造函数)初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字new。

l new Object()

l new Point(2 ,3)

l new Object //如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略掉的。

l new Date 

当计算一个对象创建表达式的值时，和对象初始化表达式通过{}创建对象的做法一样，JavaScript首先创建一个新的空对象，然后，JavaScript通过传入指定的参数并将这个新对象当做this 的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建对象的属性。那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个***\*对象\****值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

### ***\*运算符概述\****

下表是按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级。被水平分割线分隔开来的运算符具有不同的优先级。标题为A的列表示运算符的结合性，L(从左至右)或R( 从右至左)，标题为N的列表示操作数的个数。标题为"类型"的列表示期望的操作数类型，以及运算符的结果类型(在"->"符号之后)。lval是left-value的简写，意思是"左值"。

| ***\*运算符\****                                 | ***\*操作\****                                               | ***\*A\**** | ***\*N\**** | ***\*类型\****                                               |
| ------------------------------------------------ | ------------------------------------------------------------ | ----------- | ----------- | ------------------------------------------------------------ |
| ++---+~!deletetypeofvoid                         | 前/后增量前/后减量求反转换为数字按位求反逻辑非检测操作数类型返回undefined值 | RRRRRRRRR   | 111111111   | lval-> numlval -> numnum -> numnum -> numint -> intbool -> boollval -> boolany -> strany -> undef |
| *、/、%                                          | 乘、除、求余                                                 | L           | 2           | num, num -> num                                              |
| +、-+                                            | 加、减字符串连接                                             | LL          | 22          | num, num -> numstr, str -> str                               |
| <<>>>>>                                          | 左移位有符号右移无符号右移                                   | LLL         | 222         | int, int -> intint, int -> intint, int -> int                |
| <、<=、>、>=<、<=、>、>=instanceofin             | 比较数字顺序比较在字母表中的顺序测试对象类测试属性是否存在   | LLLL        | 2222        | num, num -> boolstr, str -> boolobj, func -> boolstr, obj -> bool |
| ==!====!==                                       | 判断相等判断不等判断恒等判断非恒等                           | LLLL        | 2222        | any, any -> boolany, any -> boolany, any -> boolany, any -> bool |
| &                                                | 按位与                                                       | L           | 2           | int, int -> int                                              |
| ^                                                | 按位异或                                                     | L           | 2           | int, int -> int                                              |
| \|                                               | 按位或                                                       | L           | 2           | int, int -> int                                              |
| &&                                               | 逻辑与                                                       | L           | 2           | any, any -> any                                              |
| \|\|                                             | 逻辑或                                                       | L           | 2           | any, any -> any                                              |
| ?:                                               | 条件运算符                                                   | R           | 3           | bool, any, any -> any                                        |
| =*=、/=、%=、+=、-=、&=、^=、\|=、<<=、>>=、>>>= | 变量赋值或对象属性赋值运算且赋值                             | RR          | 22          | lval, any -> anylval, any -> any                             |
| ,                                                | 忽略第一个操作数，返回第二个操作数                           | L           | 2           | any, any -> any                                              |

左值(lvalue)是一个古老的术语，它是指"表达式只能出现在赋值运算符的左侧"。在JavaScript中，变量、对象属性和数组元素均是左值。ECMAScript规范允许内置函数返回一个左值，但自定义的函数则不能返回左值。

计算一个简单的表达式(比如2*3)不会对程序的运行状态造成任何影响，程序后续执行的计算也不会受到该计算的影响。而有一些表达式则具有很多副作用，前后的表达式运算会相互影响。赋值运算符是最明显的一个例子:如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会发生改变。"++"和"--"递增和递减运算符与此类似，因为它们包含隐式的赋值。delete运算符同样有副作用:删除一个属性就像(但不完全一样)给这个属性赋值undefined。

其他的JavaScript运算符都没有副作用，但函数调用表达式和对象创建表达式有些特别，在函数体或者构造函数内部运用了这些运算符并产生了副作用的时候，我们说函数调用表达式和对象创建表达式是有副作用的。

运算符的优先级可以通过显式使用圆括号来重写。需要注意的是，属性访问表达式和调用表达式的优先级要比表中列出的所有运算符都要高。实际上，如果你真的不确定你所使用的运算符的优先级，最简单的方法就是使用圆括号来强行指定运算次序。

***\*var\**** a = 1;      // 1

***\*var\**** b = (a++) + a;  // 3

### ***\*算术表达式\****

***\*+运算符\****

偏爱字符串

Ø 1 + 2 // 3 加法

Ø "hello" + " " + "angel" // "hello angel" 字符串连接

Ø "1" + "2" // "12" 

Ø "1" + 2 // "12" 数字转换为字符串后进行字符串连接

Ø 1 + {} // "1[object Object]" 对象转换为字符串后进行字符串连接

Ø true + true // 2 布尔值转换为数字后做加法

Ø 2 + null // 2  null转换为0后做加法

Ø 2 + undefined // NaN  undefined转换为NaN后做加法

Ø 1 + 2 + " blind mice"; // => "3 blind mice" 运算顺序的影响

Ø 1 + (2 + " blind mice"); // => "12 blind mice"

***\*一元算术运算符\****

一元运算符作用于一个单独的操作数，并产生一个新值。在JavaScript中，一元运算符具有很高的优先级，而且都是右结合(right-associative)。

l +：一元加法运算符把操作数转换为数字(或者NaN)，并返回这个转换后的数字

l -：当"-"用做一元运算符时，它会根据需要把操作数转换为数字，然后改变运算结果的符号。

l ++：var i = 1, j = ++i // i和j的值都是2

var i = 1, j = i++ // i是2，j是1

l --：如上，有前置和后置之分

***\*位运算符\****

位运算符可以对由数字表示的二进制数据进行更低层级的按位运算。位运算符要求它的操作数是整数，这些整数表示为32位整型而不是64位浮点型。必要时，位运算符首先将操作数转换为数字，并将数字强制表示为32位整型，这会忽略原格式中的小数部分和任何超过32位的二进制位。

移位运算符要求右操作数在0-31之间。在将其操作数转换为无符号32位整数后，它们将舍弃第5位之后的二进制位，以便生成一个位数正确的数字。需要注意的是，位运算符会将NaN、Infinity和-Infinity都转换为0。

l &：对它的整型操作数逐位执行布尔与(AND)操作

l |：对它的整型操作数逐位执行布尔或(OR)操作

l ^：对它的整型操作数逐位执行布尔异或(XOR)操作

l ~：一元运算符，位于一个整型参数之前，它将操作数的所有位取反。根据JavaScript中带符号的整数的表示方法，对一个值使用"~"运算符相当于改变它的符号并减1

l <<：将第一个操作数的所有二进制位进行左移操作，移动的位数由第二个操作数指定，移动的位数是0-31之间的一个整数，将一个值左移1位相当于它乘以2，左移两位相当于乘以4，以此类推。

l >>：将第一个操作数的所有位进行右移操作，移动的位数由第二个操作数指定，移动的位数是0-31之间的一个整数。右边溢出的位将忽略。填补在左边的位由原操作数的符号决定，以便保持结果的符号与原操作数一致。如果第一个操作数是正数，移位后用0填补最高位，如果第一个操作数是负的，移位后就用1填补高位。将一个值右移1 位，相当于用它除以2，右移两位，相当于它除以4，以此类推

l >>>：和运算符">>"一样，只是左边的高位总是填补0，与原来的操作数符号无关

### ***\*关系表达式\****

***\*相等和不等运算符\****

l =：赋值

l ==：相等，自动类型转换，JS对象比较的是引用（栈），不是具体对象（堆）

u 如果一个值是null，另一个是undefined，则它们相等。

u 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。

u 如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false ，则将其转换为0再进行比较。

u 如果一个值是对象，另一个值是数字或字符串，则使用转换规则将对象转换为原始值，然后再进行比较。对象通过toString()方法或者valueOf()方法转换为原始值。JavaScript语言核心的内置类首先尝试使用valueOf()，再尝试使用toString()，除了日期类，日期类只使用toString()转换。那些不是JavaScript语言核心中的对象则通过各自的实现中定义的方法转换为原始值。

u 其他不同类型之间的比较均不相等。

l !=

l ===：严格相等，不转换类型

u 如果两个值类型不相同，则它们不相等。

u 如果两个值都是null或者都是undefined，则它们不相等。

u 如果其中一个值是NaN，或者两个值都是NaN，则它们不相等。NaN和其他任何值都是不相等的，包括它本身!通过x!==x来判断x是否为NaN，只有在x为NaN的时候，这个表达式的值才为true。

u 两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的16位值。JavaScript并不对Unicode进行标准化的转换，因此像这样的字符串通过"=="和"==="运算符的比较结果也不相等。

l !==

***\*比较运算符\****

<, >, <=, >=

偏爱数字

比较操作符的操作数可能是任意类型。然而，只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换，类型转换规则：

l 如果是object，转换成原始值：1)valueOf() 2)toString()

l 如果能转成字符串，两个字符串按照16位Unicode字符的索引顺序进行比较

l 如果不能转成字符串，就转成数字，Infitity最大，-Infinity最小，其中一个是NaN，总返回false

String.localCompare()更健壮，参照本地语言字母表字符顺序。

***\*in\*******\*运算符\****

in运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true

***\*instanceof\*******\*运算符\****

instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。

如果左侧的对象是右侧类的实例，则表达式返回true，否则返回false 。

如果instanceof的左操作数不是对象的话， instanceof返回false 。

JS中对象的类是通过初始化它们的构造函数来定义，因此右操作数应该是一个函数。如果右操作数不是函数，则抛出一个类型错误异常。

***\*逻辑\*******\*表达式\****

&&、||、!

&&示例：a&&b，a为“假值”，返回a，否则返回b。短路特性，a为真，b执行；否则b不执行

||示例：a||b，a为“真值”，返回a，否则返回b。短路特性，a为假，b执行；否则b不执行

！运算符总是返回true、false；!!a返回a的等价bool值

 

***\*赋值\*******\*表达式\****

示例：(a = b) == 0

"="具有非常低的优先级，用括号改变优先级。

赋值操作符的结合性是从右至左，也就是说，如果一个表达式中出现了多个赋值运算符，运算顺序是从右到左。

运算符"+="执行的是加法运算和赋值操作。

在大多数情况下，表达式为: a op= b

这里op代表一个运算符，这个表达式和下面的表达式等价：a=a op b

a op= b，表达式a计算了一次，a=a op b，表达式a计算了两次。只有在a包含具有***\*副作用\****的表达式(比如函数调用和赋值操作)的时候，两者才不等价。比如，下面两个表达式就不等价：

data[i++] *= 2;

data[i++] = data[i++] * 2;

***\*表达式\*******\*计算\****

***\*eval()\****

eval()只有一个参数。

如果传入的参数不是字符串，它直接返回这个参数。

如果参数是字符串，它会把字符串当成JavaScript代码进行编译。

如果编译失败则抛出一个语法错误（SyntaxError）异常。

如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值。

如果最后一个表达式或语句没有值，则最终返回undefined。

如果字符串抛出一个异常，这个异常将把该调用传递给eval()。

eval()使用了调用它的变量作用域环境。

***\*var\**** geval = eval;         //使用别名调用eval将是全局eval

***\*var\**** x = "global", y = "global";  //两个全局变量

***\*function\**** f() {           //函数内执行的是局部eval

  ***\*var\**** x = "local";        //定义局部变量

  eval("x += ' changed';");    //直接eval更改了局部变量的值

  ***\*return\**** x;           //返回更改后的局部变量

}

***\*function\**** g() {           //这个函数内执行了全局eval

  ***\*var\**** y = "local";        //定义局部变量

  geval("y += ' changed';");   //间接调用改变了全局变量的值

  ***\*return\**** y;           //返回未更改的局部变量

}

console.log(f() , x);       //更改了局部变量:输出"local changed global"

console.log(g() , y);       //更改了全局变量:输出"local global changed"

delete是一元操作符，它用来删除对象属性或者数组元素。就像赋值、递增、递减运算符一样，delete也是具有副作用的，它是用来做删除操作的，不是用来返回一个值的。

***\*var\**** o = { x:1, y:2 }; // 定义一个对象

***\*delete\**** o.x;      // 删除一个属性

"x" ***\*in\**** o        // =>false：这个属性在对象中不再存在

 

***\*var\**** a = [1,2,3];    // 定义一个数组

***\*delete\**** a[2];      // 删除最后一个数组元素

a ***\*in\**** a;        // =>false：元素2在数组中已经不存在

a.length        // =>3：注意，数组长度并没有改变，尽管上一行代码删除了这个元素，

​            // 但删除操作留下了一个“洞”，实际上并没有修改数组的长度

***\*其他运算符\****

***\*?:\****

三元运算符，从右向左执行

***\*typeof\****

typeof是一元运算符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。

l undefined        "undefined"

l null           "object"

l true或false      "boolean"

l 任意数字或NaN      "number"

l 任意字符串        "string"

l 任意函数         "function"

l 任意内置对象(非函数)   "object"

l 任意宿主对象由编译器各自实现的字符串，但不是"undefined"，"boolean" 、"number" 或"string"

 

***\*delete\****

delete希望他的操作数是一个左值

如果它不是左值，那么delete将不进行任何操作同时返回true。

否则，delete将试图删除这个指定的左值。

如果删除成功，delete将返回true。

然而并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也不能删除。

***\*var\**** o = {x:1, y:2}; //定义一个变量，初始化为对象

***\*delete\**** o.x;     //删除一个对象属性，返回true

typeof o.x;     //属性不存在，返回"undefined"

***\*delete\**** o.x;     //删除不存在的属性，返回true

***\*delete\**** o;      //不能删除通过var声明的变量，返回false

​           //在严格模式下，将抛出一个异常

***\*delete\**** 1;      //参数不是一个左值，返回true

***\*this\****.x = 1;     //给全局对象定义一个属性，这里没有使用var

***\*delete\**** x;      //试图删除它，在非严格模式下返回true

​           //在严格模式下会抛出异常，这时使用"delete this.x" 来代替

x;          //运行时错误，没有定义x

***\*void\****

一元运算符，它出现在操作数之前，操作数可以是任意类型。

操作数会照常计算，但忽略计算结果并返回undefined。

这个运算符最常用在客户端的javascript: URL 中，在URL中可以写带有副作用的表达式，而void则让浏览器不必显示这个表达式的计算结果。

打开一个新窗口

***\*,\****

逗号运算符是二元运算符，它的操作数可以是任意类型。

它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。

***\*语句\****

 

### ***\*表达式\*******\*语句\****

具有副作用的表达式是JavaScript 中最简单的语句。

### ***\*复合语句\****

示例：（注意没有块级作用域）

***\*{\****

 x***\*=\****Math***\*.\****PI***\*;\****

 cx***\*=\****Math***\*.\****cos***\*(\****x***\*);\****

***\*}\**** ***\*//不需要分号结尾\****

### ***\*空语句\****

;

### ***\*声明语句\****

var用来声明变量，function用来声明函数

delete无法删除

var：声明提前，赋值不提前

function：函数声明和函数体（包括内部嵌套函数）都提前

### ***\*条件\*******\*语句\****

if (condition1) {

​	…

} else if (condition2) {

​		…

} else {

​	…

}

 

switch(expression) {

​	case value1: 

​		…

​		break;//switch确定了起点，没有确定终点，没有break，程序会逐条执行下去

​	case value2:

​		…

​		break

​	default:

​		…

}

### ***\*循环\*******\*语句\****

while

do … while 必定执行一次

for

for/in 遍历（对象可枚举属性，数组索引）

### ***\*跳转\****

不能越过函数边界

identifier: statement

continue (identifier)

break (identifier)

return (expression)

throw (expression)

try/catch/finally：

​	先执行try

​	 有异常

​	  catch，执行catch

​    没有catch

   没异常

​	然后执行finally

   有异常

​    向上抛出，try被覆盖

​	 没异常

​		有返回

​     返回finally，try被覆盖（即使异常也会被覆盖）

​		没返回

​		 返回try

### ***\*其它\*******\*语句\****

***\*with\****

with语句用于临时扩展作用域链，它具有如下的语法：

with (object)

statement

这条语句将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原始状态。

***\*with\****(document.forms[o]) {

  // 直接访问表单元素，例如:

  name.value = "";

  address.value = "";

  email. value = "";

}

在严格模式中禁止使用with语句，尽可能避免使用with语句。

只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用它，看一下下面这行代码：

with(o) x = 1;

如果对象o有一个属性x，那么这行代码给这个属性赋值为1。但如果o中没有定义属性x，这段代码和不使用with语句的代码x=1是一模一样的。它给一个局部变量或者全局变量x赋值，或者创建全局对象的一个新属性。with语句提供了一种读取o的属性的快捷方式，但它并不能创建o的属性。

***\*debugger\****

debugger语句通常什么也不做。然而，当调试程序可用并运行的时候，JavaScript解释器将会(非必需)以调式模式运行。实际上，这条语句用来产生一个断点(breakpoint),JavaScript代码的执行会停止在断点的位置，这时可以使用调试器输出变量的值、检查调用栈等。

***\*use strict\****

"use strict" 是ECMAScript 5 引人的一条指令。指令不是语句(但非常接近于语句)。"use strict" 指令和普通的语句之间有两个重要的区别：

l 它不包含任何语言的关键字，指令仅仅是一个包含一个特殊字符串直接量的表达式(可以是使用单引号也可以使用双引号)，对于那些没有实现ECMAScript 5的JavaScript解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。

l 它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为"use strict"指令之后或之前都可能有其他字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。

使用"use strict"指令的目的是说明(脚本或函数中)后续的代码将会解析为严格代码(strict code)。

严格代码以严格模式执行。ECMAScript 5中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下：

l with禁用

l 使用变量前必须声明

l 调用的函数中的this值是undefined（非严格模式下，是全局对象）。利用这个特性判断是否支持严格模式

***\*var\**** hasStrictMode ***\*=\**** ***\*(\*******\*function\*******\*(){\****

​	"use strict"***\*;\****

​	***\*return\**** ***\*this\*******\*===\****undefined***\*;\****

***\*}());\****

l 给只读属性赋值和给不可扩展的对象创建新成员会报错

l 传入eval()的代码不能在程序所在上下文声明变量或定义函数；因为变量和函数的定义在eval()创建的新作用域中，这个作用域在eval返回时弃用

l arguments对象拥有传入函数值的静态副本（非严格下，arguments里的数组元素和函数参数都是指向同一个值的引用）

l delete跟随非法标识符，会抛异常

l 试图删除不可配置属性会抛异常（非严格下，操作失败，返回false）

l 在对象直接量中，定义多个同名属性将产生语法错误

l 不允许使用8进制整数直接量

l eval、arguments是关键字，不能更改，不能赋值，不能声明为变量，不能用作函数名，不能用做函数参数，不能做catch块的标识符

l 限制了对调用栈的检测能力，arguments.caller和arguments.callee会抛类型错误



# javascript

## 目录

## API

### 地理定位

定位用户的位置

HTML5 Geolocation API 用于获得用户的地理位置。

鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。

实例

```
<!DOCTYPE html>
<html>
<body>
<p id="demo">点击这个按钮，获得您的坐标：</p>
<button onclick="getLocation()">试一下</button>
<script>
var x=document.getElementById("demo");
function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showPosition/*,showError*/);
  } else {
    x.innerHTML="Geolocation is not supported by this browser.";
  }
}
function showPosition(position) {
  x.innerHTML="Latitude: " + position.coords.latitude + "<br />Longitude: " + position.coords.longitude;
}
</script>
</body>
</html>
```

例子解释：

- 检测是否支持地理定位
- 如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。
- 如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象
- showPosition() 函数获得并显示经度和纬度

上面的例子是一个非常基础的地理定位脚本，不含错误处理。

处理错误和拒绝

getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数：

```
function showError(error) {
  switch(error.code) {
    case error.PERMISSION_DENIED:
      x.innerHTML="User denied the request for Geolocation."
      break;
    case error.POSITION_UNAVAILABLE:
      x.innerHTML="Location information is unavailable."
      break;
    case error.TIMEOUT:
      x.innerHTML="The request to get user location timed out."
      break;
    case error.UNKNOWN_ERROR:
      x.innerHTML="An unknown error occurred."
      break;
  }
}
```

错误代码：

- Permission denied - 用户不允许地理定位
- Position unavailable - 无法获取当前位置
- Timeout - 操作超时

在地图中显示结果

如需在地图中显示结果，您需要访问可使用经纬度的地图服务，比如谷歌地图或百度地图：

```
function showPosition(position) {
  var latlon=position.coords.latitude+","+position.coords.longitude;
  var img_url="http://maps.googleapis.com/maps/api/staticmap?center="
    +latlon+"&zoom=14&size=400x300&sensor=false";
  document.getElementById("mapholder").innerHTML="<img src='"+img_url+"' />";
}
```

给定位置的信息

本页演示的是如何在地图上显示用户的位置。不过，地理定位对于给定位置的信息同样很有用处。

案例：

- 更新本地信息
- 显示用户周围的兴趣点
- 交互式车载导航系统 (GPS)

getCurrentPosition() 方法 - 返回数据

若成功，则 getCurrentPosition() 方法返回对象。始终会返回 latitude、longitude 以及 accuracy 属性。如果可用，则会返回其他下面的属性。

| 属性                    | 描述                   |
| ----------------------- | ---------------------- |
| coords.latitude         | 十进制数的纬度         |
| coords.longitude        | 十进制数的经度         |
| coords.accuracy         | 位置精度               |
| coords.altitude         | 海拔，海平面以上以米计 |
| coords.altitudeAccuracy | 位置的海拔精度         |
| coords.heading          | 方向，从正北开始以度计 |
| coords.speed            | 速度，以米/每秒计      |
| timestamp               | 响应的日期/时间        |

Geolocation对象 - 其他有趣的方法

- watchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。
- clearWatch() - 停止 watchPosition() 方法

下面的例子展示 watchPosition() 方法。您需要一台精确的 GPS 设备来测试该例（比如 iPhone）：

实例

```
<script>
var x=document.getElementById("demo");
function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.watchPosition(showPosition);
  } else {
    x.innerHTML="Geolocation is not supported by this browser.";
  }
}
function showPosition(position) {
  x.innerHTML="Latitude: " + position.coords.latitude + "<br />Longitude: " + position.coords.longitude;
}
</script>
```

### 拖放

拖放（Drag 和 Drop）是很常见的特性。它指的是您抓取某物并拖入不同的位置。

拖放是 HTML5 标准的组成部分：任何元素都是可拖放的。

```
<!DOCTYPE HTML>
<html>
<head>
<script>
  function allowDrop(ev) {
    ev.preventDefault();
  }

  function drag(ev) {
    ev.dataTransfer.setData("text", ev.target.id);
  }

  function drop(ev) {
    ev.preventDefault();
    var data = ev.dataTransfer.getData("text");
    ev.target.appendChild(document.getElementById(data));
  }
</script>
</head>
<body>
  <div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
  <img id="drag1" src="img_logo.gif" draggable="true" ondragstart="drag(event)" width="336" height="69">
</body>
</html>
```

***把元素设置为可拖放\***

首先：为了把一个元素设置为可拖放，请把 draggable 属性设置为 true

拖放的内容 - ondragstart 和 setData()

然后，规定当元素被拖动时发生的事情。

在上面的例子中，ondragstart 属性调用了一个 drag(event) 函数，规定拖动什么数据。

dataTransfer.setData() 方法设置被拖动数据的数据类型和值

在本例中，数据类型是 "text"，而值是这个可拖动元素的 id ("drag1")。

拖到何处 - ondragover

ondragover 事件规定被拖动的数据能够被放置到何处。

默认地，数据/元素无法被放置到其他元素中。为了实现拖放，我们必须阻止元素的这种默认的处理方式。

这个任务由 ondragover 事件的 event.preventDefault() 方法完成

进行放置 - ondrop

当放开被拖数据时，会发生 drop 事件。

在上面的例子中，ondrop 属性调用了一个函数，drop(event)

代码解释：

- 调用 preventDefault() 来阻止数据的浏览器默认处理方式（drop 事件的默认行为是以链接形式打开）
- 通过 dataTransfer.getData() 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据
- 被拖数据是被拖元素的 id ("drag1")
- 把被拖元素追加到放置元素中

### 本地存储

HTML 本地存储：优于 cookies。

***什么是 HTML 本地存储？\***

通过本地存储（Local Storage），web 应用程序能够在用户浏览器中对数据进行本地的存储。

在 HTML5 之前，应用程序数据只能存储在 cookie 中，包括每个服务器请求。本地存储则更安全，并且可在不影响网站性能的前提下将大量数据存储于本地。

与 cookie 不同，存储限制要大得多（至少5MB），并且信息不会被传输到服务器。

本地存储经由起源地（origin）（经由域和协议）。所有页面，从起源地，能够存储和访问相同的数据。

#### HTML本地存储对象

HTML 本地存储提供了两个在客户端存储数据的对象：

- window.localStorage - 存储没有截止日期的数据
- window.sessionStorage - 针对一个 session 来存储数据（当关闭浏览器标签页时数据会丢失）

在使用本地存储时，请检测 localStorage 和 sessionStorage 的浏览器支持：

```
if (typeof(Storage) !== "undefined") {
  // 针对 localStorage/sessionStorage 的代码
} else {
  // 抱歉！不支持 Web Storage ..
}
```

##### localStorage对象

localStorage 对象存储的是没有截止日期的数据。当浏览器被关闭时数据不会被删除，在下一天、周或年中，都是可用的。

```
// 存储
localStorage.setItem("lastname", "Gates");
// 取回
document.getElementById("result").innerHTML = localStorage.getItem("lastname");
```

实例解释：

- 创建 localStorage 名称/值对，其中：name="lastname"，value="Gates"
- 取回 "lastname" 的值，并把它插到 id="result" 的元素中

上例也可这样写：

```
// 存储
localStorage.lastname = "Gates";
// 取回
document.getElementById("result").innerHTML = localStorage.lastname;
```

删除 "lastname" localStorage 项目的语法如下：

```
localStorage.removeItem("lastname");
```

注释：名称/值对始终存储为字符串。如果需要请记得把它们转换为其他格式！

下面的例子对用户点击按钮的次数进行计数。在代码中，值字符串被转换为数值，依次对计数进行递增：

```
if (localStorage.clickcount) {
  localStorage.clickcount = Number(localStorage.clickcount) + 1;
} else {
  localStorage.clickcount = 1;
}
document.getElementById("result").innerHTML = "您已经点击这个按钮 " + localStorage.clickcount + " 次。";
```

##### sessionStorage对象

sessionStorage 对象等同 localStorage 对象，不同之处在于只对一个 session 存储数据。如果用户关闭具体的浏览器标签页，数据也会被删除。

下例在当前 session 中对用户点击按钮进行计数：

```
if (sessionStorage.clickcount) {
  sessionStorage.clickcount = Number(sessionStorage.clickcount) + 1;
} else {
  sessionStorage.clickcount = 1;
}
document.getElementById("result").innerHTML = "在本 session 中，您已经点击这个按钮 " + sessionStorage.clickcount + " 次。";
```

#### 应用程序缓存

使用应用程序缓存，通过创建 cache manifest 文件，可轻松创建 web 应用的离线版本。

***什么是应用程序缓存？\***

HTML5 引入了应用程序缓存（Application Cache），这意味着可对 web 应用进行缓存，并可在没有因特网连接时进行访问。

应用程序缓存为应用带来三个优势：

1. 离线浏览 - 用户可在应用离线时使用它们
2. 速度 - 已缓存资源加载得更快
3. 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源

示例

```
<!DOCTYPE HTML>
<html manifest="demo.appcache">
<body>
文档内容 ......
</body>
</html>
```

***Cache Manifest 基础\***

如需启用应用程序缓存，请在文档的 `<html>` 标签中包含 manifest 属性

每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。

manifest 文件的建议文件扩展名是：".appcache"。

注意：manifest 文件需要设置正确的 MIME-type，即 "text/cache-manifest"。必须在 web 服务器上进行配置。

***Manifest 文件\***

manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。

manifest 文件有三个部分：

- CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
- NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
- FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

***CACHE MANIFEST\***

第一行，CACHE MANIFEST，是必需的：

```
CACHE MANIFEST
/theme.css
/logo.gif
/main.js
```

上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件被加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然可用。

***NETWORK\***

下面的 NETWORK 部分规定文件 "login.php" 永远不会被缓存，且离线时是不可用的：

```
NETWORK:
login.asp
```

可以使用星号来指示所有其他其他资源/文件都需要因特网连接：

```
NETWORK:
*
```

```
FALLBACK
/html/ /offline.html
```

下面的 FALLBACK 部分规定如果无法建立因特网连接，则用 "offline.html" 替代 /html/ 目录中的所有文件。

注释：第一个 URI 是资源，第二个是替补。

更新缓存

一旦应用被缓存，它就会保持缓存直到发生下列情况：

- 用户清空浏览器缓存
- manifest 文件被修改（参阅下面的提示）
- 由程序来更新应用缓存

实例 - 完整的 Cache Manifest 文件

```
CACHE MANIFEST
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:
login.asp

FALLBACK:
/html/ /offline.html
```

提示：以 "#" 开头的是注释行，但也可满足其他用途。应用的缓存只会在其 manifest 文件改变时被更新。如果您编辑了一幅图像，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。

***关于应用程序缓存的注意事项\***

请留心缓存的内容。

一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新 manifest 文件。

注释：浏览器对缓存数据的容量限制可能不太一样（某些浏览器的限制是每个站点 5MB）。

### Web&nbsp;Workers

Web worker 是运行在后台的 JavaScript，不会影响页面的性能。

***什么是 Web Worker？\***

当在 HTML 页面中执行脚本时，页面是不可响应的，直到脚本已完成。

Web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 运行在后台。

示例

```
<!DOCTYPE html>
<html>
<body>
  <p>计数: <output id="result"></output></p>
  <button onclick="startWorker()">开始 Worker</button>
  <button onclick="stopWorker()">停止 Worker</button>
  <br /><br />
  <script>
    var w;
    function startWorker() {
      if(typeof(Worker)!=="undefined") {
        if(typeof(w)=="undefined") {
          w=new Worker("/example/html5/demo_workers.js");
        }
        w.onmessage = function (event) {
          document.getElementById("result").innerHTML=event.data;
        };
      } else {
        document.getElementById("result").innerHTML="Sorry, your browser does not support Web Workers...";
      }
    }
    function stopWorker() {
      w.terminate();
      w = undefined;
    }
  </script>
</body>
</html>
```

***检测 Web Worker 支持\***

在创建 web worker 之前，请检测用户浏览器是否支持它

创建 Web Worker 文件

现在，让我们在一个外部 JavaScript 文件中创建我们的 web worker。

在此处，我们创建了计数脚本。该脚本存储于 "demo_workers.js" 文件中

```
var i=0;
function timedCount() {
  i=i+1;
  postMessage(i);
  setTimeout("timedCount()",500);
}
timedCount();
```

以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。

注释: web worker 通常不用于如此简单的脚本，而是用于更耗费 CPU 资源的任务。

***创建 Web Worker 对象\***

现在我们已经有了 web worker 文件，我们需要从 HTML 页面调用它。

上面的代码行检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 "demo_workers.js" 中的代码

然后我们就可以从 web worker 发生和接收消息了。

向 web worker 添加一个 "onmessage" 事件监听器

当 web worker 传送消息时，会执行事件监听器中的代码。来自 web worker 的数据会存储于 event.data 中。

***终止 Web Worker\***

当创建 web worker 后，它会继续监听消息（即使在外部脚本完成后）直到其被终止为止。

如需终止 web worker，并释放浏览器/计算机资源，请使用 terminate() 方法

***复用 Web Worker\***

如果您把 worker 变量设置为 undefined，在其被终止后，可以重复使用该代码

***Web Worker 和 DOM\***

由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：

- window 对象
- document 对象
- parent 对象

### Server-Sent事件

Server-Sent 事件允许网页从服务器获得更新。

***Server-Sent 事件 - One Way Messaging\***

以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过 Server-Sent 事件，更新能够自动到达。

例如：Facebook/Twitter 更新、股价更新、新的博文、赛事结果，等等。

***接收 Server-Sent 事件通知\***

EventSource 对象用于接收服务器发送事件通知：

```
var source = new EventSource("demo_sse.php");
source.onmessage = function(event) {
  document.getElementById("result").innerHTML += event.data + "<br>";
};
```

例子解释：

- 创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 "demo_sse.php"）
- 每当接收到一次更新，就会发生 onmessage 事件
- 当 onmessage 事件发生时，把已接收的数据推入 id 为 "result" 的元素中

***检测 Server-Sent 事件支持\***

```
if(typeof(EventSource) !== "undefined") {
  // 是的！支持服务器发送事件！
  // 一些代码.....
} else {
  // 抱歉！不支持服务器发送事件！
}
```

***服务器端代码实例\***

为了使上例运行，您需要能够发送数据更新的服务器（比如 PHP）。

服务器端事件流的语法非常简单。请把 "Content-Type" 报头设置为 "text/event-stream"。现在，您可以开始发送事件流了。

```
<?php
header('Content-Type: text/event-stream');
header('Cache-Control: no-cache');

$time = date('r');
echo "data: The server time is: {$time}\n\n";
flush();
?>
```

代码解释：

- 把报头 "Content-Type" 设置为 "text/event-stream"
- 规定不对页面进行缓存
- 输出要发送的日期（始终以 "data: " 开头）
- 向网页刷新输出数据

***EventSource 对象\***

在上例中，我们使用 onmessage 事件来获取消息。不过还可以使用其他事件：

| 事件      | 描述                     |
| --------- | ------------------------ |
| onopen    | 当通往服务器的连接被打开 |
| onmessage | 当接收到消息             |
| onerror   | 当发生错误               |



# 目录

1. 简介
   - [HTTPS原理](#HTTPS原理)
   - [window和document](#window和document)
   - [object](#object)
     - [wbbrowser](#wbbrowser)
       - 打印示例
     - [地理位置](#地理位置)
     - [历史记录管理](#历史记录管理)
     - [跨域消息传递](#跨域消息传递)
     - [Web Worker](#WebWorker)
   - [伪元素](#伪元素)
   - [embed标签](#embed标签)
   - [Function.prototype.bind](#Function.prototype.bind)
   - [document.write](#document.write)
   - [document.execCommand](#document.execCommand)
   - [获取数组中最大值和最小值的方法汇总](#获取数组中最大值和最小值的方法汇总)
   - [with](#with)
   - [异步](#异步)
   - [跨域](#跨域)
   - [类型检测](#类型检测)
   - [正则表达式](#正则表达式)
   - [剪切板](#剪切板)
   - [动态加载JS和CSS](#动态加载JS和CSS)
   - [判断IE版本的HTML语句详解](#判断IE版本的HTML语句详解)
   - [让IE6/IE7/IE8支持CSS3属性的8种方法介绍](#让IE6/IE7/IE8支持CSS3属性的8种方法介绍)
2. 实战
   - [阻止冒泡和默认行为](#阻止冒泡和默认行为)
3. 参考
   - [流式编程](#流式编程)
     - 概念
       - [流式应用](#流式应用)
       - [瀑布流](#瀑布流)
       - [实时计算](#实时计算)
       - [流处理](#流处理)
     - 来源和结论
       - [页面结构](#页面结构)
       - [接口请求](#接口请求)
       - [优化顺序](#优化顺序)
     - 实例分析
       - [单接口情况](#单接口情况)
       - [多接口](#多接口)
       - [实时+触发](#实时+触发)
       - [复杂页面](#复杂页面)
   - [DOM操作成本到底高在哪儿](#DOM操作成本到底高在哪儿)
     - [什么是DOM？](#什么是DOM)
     - [浏览器渲染过程](#浏览器渲染过程)

## HTTPS原理

随着 HTTPS 建站的成本下降，现在大部分的网站都已经开始用上 HTTPS 协议。大家都知道 HTTPS 比 HTTP 安全，也听说过与 HTTPS 协议相关的概念有 SSL 、非对称加密、 CA证书等，但对于以下灵魂三拷问可能就答不上了：

1. 为什么用了 HTTPS 就是安全的？
2. HTTPS 的底层原理如何实现？
3. 用了 HTTPS 就一定安全吗？

本文将层层深入，从原理上把 HTTPS 的安全性讲透。

### HTTPS 的实现原理

大家可能都听说过 HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实，HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。

HTTPS的整体过程分为 **证书验证** 和 **数据传输** 阶段，具体的交互过程如下：

![x](./Resource/https1.jpg)

#### 1、证书验证阶段

1. 浏览器发起 HTTPS 请求
2. 服务端返回 HTTPS 证书
3. 客户端验证证书是否合法，如果不合法则提示告警

#### 2、数据传输阶段

1. 当证书验证合法后，在本地生成随机数
2. 通过公钥加密随机数，并把加密后的随机数传输到服务端
3. 服务端通过私钥对随机数进行解密
4. 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

**为什么数据传输是用对称加密？**

首先，非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；

另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。

**为什么需要 CA 认证机构颁发证书？**

HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。

首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题。

“中间人攻击”的具体过程如下：

![x](./Resource/https2.jpg)

过程原理：

1. 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器
2. 中间人服务器返回中间人自己的证书
3. 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
4. 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
5. 中间人以客户端的请求内容再向正规网站发起请求
6. 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据
7. 中间人凭借与正规网站建立的对称加密算法对内容进行解密
8. 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
9. 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。

浏览器是如何确保 CA 证书的合法性？

**1、证书包含什么信息？**

- 颁发机构信息
- 公钥
- 公司信息
- 域名
- 有效期
- 指纹
- ......

**2、证书的合法性依据是什么？**

首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。

另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。

**3、浏览器如何验证证书的合法性？**

浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：

1. 验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；

2. 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；

   ![x](./Resource/https3.jpg)

3. 判断证书是否被篡改。需要与 CA 服务器进行校验；

4. 判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率

以上任意一步都满足的情况下浏览器才认为证书是合法的。

这里插一个我想了很久的但其实答案很简单的问题：

既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？

其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。

**4、只有认证机构可以生成证书吗？**

如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。例如早期的 12306 采用的便是手动安装私有证书的形式实现 HTTPS 访问。

**Q：本地随机数被窃取怎么办？**

证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？

其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。

**Q：用了 HTTPS 会被抓包吗？**

HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。

但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。

通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。

**Q：既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？**

A: 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。

**Q: 为什么需要证书？**

A: 防止”中间人“攻击，同时可以为网站提供身份证明。

**Q: 使用 HTTPS 会被抓包吗？**

A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

## embed标签

一、基本语法：embed src=url

说明：embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等，
      Netscape及新版的IE 都支持。url为音频或视频文件及其路径，可以是相对路径或绝对路径。

示例：

```html
<embed src="your.mid">
```

二、属性设置：

1、自动播放：

语法：autostart=true、false

说明：该属性规定音频或视频文件是否在下载完之后就自动播放。

- true：音乐文件在下载完之后自动播放；
- false：音乐文件在下载完之后不自动播放。

示例：

```html
<embed src="your.mid" autostart=true>
<embed src="your.mid" autostart=false>
```

2、循环播放：

语法：loop=正整数、true、false

说明：该属性规定音频或视频文件是否循环及循环次数。

属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；

- 属性值为true时，音频或视频文件循环；
- 属性值为false时，音频或视频文件不循环。

示例：

```html
<embed src="your.mid" autostart=true loop=2>
<embed src="your.mid" autostart=true loop=true>
<embed src="your.mid" autostart=true loop=false>
```

3、面板显示：

语法：hidden=ture、no

说明：该属性规定控制面板是否显示，默认值为no。

- ture：隐藏面板；
- no：显示面板。

示例：

```html
<embed src="your.mid" hidden=ture>
<embed src="your.mid" hidden=no>
```

4、开始时间：

语法：starttime=mm:ss（分：秒）

说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。

示例：

```html
<embed src="your.mid" starttime="00:10">
```

5、音量大小：

语法：volume=0-100之间的整数

说明：该属性规定音频或视频文件的音量大小。未定义则使用系统本身的设定。

示例：

```html
<embed src="your.mid" volume="10">
```

6、容器属性：

语法：height=# width=#

说明：取值为正整数或百分数，单位为像素。该属性规定控制面板的高度和宽度。

- height：控制面板的高度；
- width：控制面板的宽度。

示例：

```html
<embed src="your.mid" height=200 width=200>
```

7、容器单位：

语法：units=pixels、en

说明：该属性指定高和宽的单位为pixels或en。

示例：

```html
<embed src="your.mid" units="pixels" height=200 width=200>
<embed src="your.mid" units="en" height=200 width=200>
```

8、外观设置：

语法：controls=console、smallconsole、playbutton、pausebutton、stopbutton、
      volumelever 说明：该属性规定控制面板的外观。默认值是console。

- console：一般正常面板；
- smallconsole：较小的面板；
- playbutton：只显示播放按钮；
- pausebutton：只显示暂停按钮；
- stopbutton：只显示停止按钮；
- volumelever：只显示音量调节按钮。

示例：

```html
<embed src="your.mid" controls=smallconsole>
<embed src="your.mid" controls=volumelever>
```

9、对象名称：

语法：name=#

说明：#为对象的名称。该属性给对象取名，以便其他对象利用。

示例：

```html
<embed src="your.mid" >
```

10、说明文字：

语法：title=#

说明：#为说明的文字。该属性规定音频或视频文件的说明文字。

示例：

```html
<embed src="your.mid" title="第一首歌">
```

11、前景色和背景色：

语法：palette=color|color

说明：该属性表示嵌入的音频或视频文件的前景色和背景色，第一个值为前景色，第二个值为背景
      色，中间用 | 隔开。color可以是RGB色（RRGGBB）也可以是颜色名，还可以是transparent
     （透明）。 示例：<embed src="your.mid" palette="red|black">

12、对齐方式：

语法：align=top、bottom、center、baseline、 left、right、texttop、middle、
      absmiddle、absbottom

说明：该属性规定控制面板和当前行中的对象的对齐方式。

- center：控制面板居中；
- left：控制面板居左；
- right：控制面板居右；
- top：控制面板的顶部与当前行中的最高对象的顶部对齐；
- bottom：控制面板的底部与当前行中的对象的基线对齐；
- baseline：控制面板的底部与文本的基线对齐；
- texttop：控制面板的顶部与当前行中的最高的文字顶部对齐；
- middle：控制面板的中间与当前行的基线对齐；
- absmiddle：控制面板的中间与当前文本或对象的中间对齐；
- absbottom：控制面板的底部与文字的底部对齐。

示例：

```html
<embed src="your.mid" align=top>
<embed src="your.mid" align=center>
```

## with

**简要说明：**

with语句可以方便地用来引用某个特定对象中已有的属性，但是不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  

**语法格式：**

```js
with(object instance) {
  //代码块  
}
```

有时候，我在一个程序代码中，多次需要使用某对象的属性或方法，照以前的写法，都是通过 `对象.属性` 或者 `对象.方法` 这样的方式来分别获得该对象的属性和方法，着实有点麻烦，学习了with语句后，可以通过类似如下的方式来实现：

```js
with(objInstance) {
  var str = 属性1;
  .....  
}
```

去除了多次写对象名的麻烦。

**举例：**

```html
<script language="javascript">  
<!--  
function Lakers() {  
  this.name = "kobe bryant";  
  this.age = "28";  
  this.gender = "boy";  
}  
var people=new Lakers();  
with(people) {  
  var str = "姓名: " + name + "<br>";  
  str += "年龄：" + age + "<br>";  
  str += "性别：" + gender;  
  document.write(str);  
}  
//-->  
</script>
```

代码执行效果如下:  

```sh
姓名: kobe bryant  
年龄：28  
性别：boy
```



## 跨域

1.什么是跨域

我们经常会在页面上使用ajax 请求访问其他服务器的数据，此时，客户端会出现跨域问题.跨域问题是由于javascript语言安全限制中的同源策略造成的。

简单来说，同源策略是指一段脚本只能读取来自同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合。

例如：

| URL                                                         | 说明                           | 是否允许通信                           |
| ----------------------------------------------------------- | ------------------------------ | -------------------------------------- |
| `http://www.a.com/a.js`, `http://www.a.com/b.js`            | 同一域名下                     | 允许                                   |
| `http://www.a.com/lab/a.js`, `http://www.a.com/script/b.js` | 同一域名下不同文件夹           | 允许                                   |
| `http://www.a.com:8000/a.js`, `http://www.a.com/b.js`       | 同一域名，不同端口             | 不允许                                 |
| `http://www.a.com/a.js`, `https://www.a.com/b.js`           | 同一域名，不同协议             | 不允许                                 |
| `http://www.a.com/a.js`, `http://70.32.92.74/b.js`          | 域名和域名对应ip               | 不允许                                 |
| `http://www.a.com/a.js`, `http://script.a.com/b.js`         | 主域相同，子域不同             | 不允许                                 |
| `http://www.a.com/a.js`, `http://a.com/b.js`                | 同一域名，不同二级域名（同上） | 不允许（cookie这种情况下也不允许访问） |
| `http://www.cnblogs.com/a.js`, `http://www.a.com/b.js`      | 不同域名                       | 不允许                                 |

2.实现原理

ajax通过XMLHttpRequest进行数据交互，浏览器出于安全考虑，不允许js代码进行跨域操作。

一般jQuery解决跨域是通过jsonp的方式，添加callback=xxx，服务器返回xxx(...)

通过CORS（跨域资源共享） Proxy对请求进行转发，就可以实现跨域访问。服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的

什么是JSONP

1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；

2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有"src"这个属性的标签都拥有跨域的能力，比如`<script>`、`<img>`、`<iframe>`）；

3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；

4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；

5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。

6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。

7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。

如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。

JSONP的客户端具体实现：

不管jQuery也好，ExtJs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：

1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。

远程服务器remoteserver.com根目录下有个remote.js文件代码如下：

```js
alert('我是远程文件');
```

本地服务器localserver.com下有个jsonp.html页面代码如下：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
</body>
</html>
```

毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。

2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。

jsonp.html页面代码如下：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <script type="text/javascript">
    var localHandler = function (data) {
      alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
  </script>
  <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
</body>
</html>
```

remote.js文件代码如下：

```js
localHandler({"result":"我是远程js带来的数据"});
```

这里对返回的数据有个要求，即：服务器返回的数据不能是单纯的JSON。如果返回的是个json字符串，我们是没有办法引用这个字符串的，必须将它赋值给一个变量或者直接调用客户端JS方法。

运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。

3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。

看jsonp.html页面的代码：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function (data) {
      alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
  </script>
</head>
<body>
</body>
</html>
```

这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。

我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。

OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：

```js
flightHandler({
  "code": "CA1998",
  "price": 1780,
  "tickets": 5
});
```

我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！

4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。

什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>Untitled Page</title>
  <script type="text/javascript" src=jquery.min.js"></script>
  <script type="text/javascript">
    jQuery(document).ready(function () {
      $.ajax({
        type: "get",
        async: false,
        url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
        dataType: "jsonp",
        jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
        jsonpCallback: "flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
        success: function (json) {
          alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
        },
        error: function () {
          alert('fail');
        }
      });
    });
  </script>
</head>
<body>
</body>
</html>
```

通过jquery的jsonp的方式。使用此方式，对服务器端有要求。

服务器端如下:

```C#
protected void Page_Load(object sender, EventArgs e)
{
    string callback = Request.QueryString["jsoncallback"];
    string result = callback + "({\"name\":\"zhangsan\",\"date\":\"2012-12-03\"})";
    Response.Clear();
    Response.Write(result);
    Response.End();
}
```

是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳 了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？

好啦，写到这里，我已经无力再写下去，又困又累，得赶紧睡觉。朋友们要是看这不错，觉得有启发，给点个“推荐”呗！由于实在比较简单，所以就不再提供demo源码下载了。

没想到上了博客园的头条推荐。看到大家对这篇文章的认可和评论，还是很开心的，这里针对ajax与jsonp的异同再做一些补充说明：

1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；

2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。

3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。

4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。

总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！
说道这里很多人还不明白后台如何处理数据，这里稍微的说一下：

拿php来说吧 比如 $items_list 是一个数组

```php
$items_list=json_encode($items_list);
$callback=$_GET['callback'];
echo $callback."($items_list)";
exit;
```

服务端对于CORS的支持，主要通过设置Access-Control-Allow_Origin来进行

[http://www.phonegap100.com/portal.php?mod=view&aid=72](http://www.phonegap100.com/portal.php?mod=view&aid=72)

[http://www.cnblogs.com/oneword/archive/2012/12/03/2799443.html](http://www.cnblogs.com/oneword/archive/2012/12/03/2799443.html)

## 类型检测

### typeof

语法：

```js
typeof(表达式)
typeof 变量名
```

返回值：

```sh
1. 'undefined'  # 未定义的变量或值
2. 'boolean'    # 布尔类型的变量或值
3. 'string'     # 字符串类型的变量或值
4. 'number'     # 数字类型的变量或值
5. 'object'     # 对象类型的变量或值，或者null
6. 'function'   # 函数类型的变量或值
```

>将 `null` 作为 `object` 类型处理是 js 历史遗留问题。

## 正则表达式

```js
MatchCollection collection = Regex.Matches(html, "<(a|link|img|script|input|form).[^>]*(href|src|action)=(\\\"|'|)(.[^\\\"']*)(\\\"|'|)[^>]*>", RegexOptions.IgnoreCase);

foreach (Match match in collection) {
  if (match.Groups[match.Groups.Count - 2].Value.IndexOf("~") != -1) {
    string url = this.Page.ResolveUrl(match.Groups[match.Groups.Count - 2].Value);
    html = html.Replace(match.Groups[match.Groups.Count - 2].Value, url);
  }
}
```

## 剪切板

IE浏览器支持直接读写剪切板内容：

```js
window.clipboardData.clearData();  
window.clipboardData.setData('Text', 'abcd');
```

chrome/Firefox

```js
// 覆盖浏览器粘贴事件
document.addEventListener('paste', function (e) {
    var clipboardData = e.clipboardData;
    if (!(clipboardData && clipboardData.items)) {//是否有粘贴内容
        return;
    }
    for (var i = 0, len = clipboardData.items.length; i < len; i++) {
        var item = clipboardData.items[i];
        if (item.kind === "string" && item.type == "text/plain") {
            item.getAsString(function (str) {
                // str 是获取到的字符串,创建文本框
                //处理粘贴的文字内容
            })
        } else if (item.kind === "file") {//file 一般是各种截图base64数据
            var pasteFile = item.getAsFile();
            // pasteFile就是获取到的文件
            var reader = new FileReader();
            reader.onload = function (event) {
                var base64Img = event.target.result;
            }; // data url  
            reader.readAsDataURL(pasteFile);
        }
        var copy_content = e.clipboardData.getData('text/plain');
    }
})

// 写入系统剪切板，实测无效
e.clipboardData.setData('text/plain', defaultText);

// 1) 监听copy事件，触发copy命令
document.addEventListener("paste", function (e) {
    console.log(e.clipboardData.getData("text"));
});
document.onkeydown = function (e) {
    if (e.ctrlKey && e.keyCode == 67) {//ctrl+C
        function handler(event) {
            event.clipboardData.setData('text/plain', "自定义复制内容");
            document.removeEventListener('copy', handler, true);
            event.preventDefault();
        }
        document.addEventListener('copy', handler, true);
        document.execCommand('copy');
    }
}

// 2）通过将需要复制的内容赋值到文本中，将文本框内容选中，执行copy命令
// 复制  
document.onkeydown = function (e) {
    if (e.ctrlKey && e.keyCode == 86) {//ctrl+V
        var cloneActiveElement = "需要复制的内容";
        var copyText = document.getElementById("copy_text");
        copyText.innerHTML = cloneActiveElement;
        copyText.readOnly = false;
        copyText.select();
        copyText.setSelectionRange(0, copyText.value.length);
        document.execCommand("copy");
        copyText.readOnly = true;
    }
}

// 事件触发
if ("createEvent" in document) {
    var evt = document.createEvent("HTMLEvents");
    evt.initEvent("paste", false, true);
    element.dispatchEvent(evt);
} else {
    element.fireEvent("onchange");
}
```

## 伪元素

虽然标题里写的是伪元素,不过这篇文章主要是说::before和::after，其余几个伪元素（::first-letter、::first-line、::selection等)由于没有content属性，所以本文一笔带过，其实方法是一样的。

伪元素的重点在于一个**伪**，虽然它们可以被浏览器渲染引擎识别并正确渲染，然而<b style="color:red">伪元素本身并不是DOM元素</b>,所以无法被js直接操作——因此任何基于JS直接选取DOM元素的CSS更改方法对伪元素都不起作用。（JQ看似万能，这个问题上是直接就栽了。因为JQ的选择符都是基于DOM元素）关于JS和JQ选择器，可以参考这两篇文档：[Selectors API Level 1](http://www.w3.org/TR/selectors-api/)、[jQuery Selectors](http://api.jquery.com/category/selectors/)

### 获取伪元素的属性值

- `window.getComputedStyle`

  ```js
  var div=document.querySelector('div');
  var fontSize=window.getComputedStyle(div,'::before').getPropertyValue('font-size');//获取before伪元素的字号大小
  ```

  关于这个方法，详解可以参考这篇文章：[获取元素CSS值之getComputedStyle方法熟悉](http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/)

### 更改伪元素的属性值

1. js更改data-*属性值来更改伪元素的content值
2. 创建多个class，通过切换class来达到改变样式的目的
3. 利用CSSStyleSheet的insertRule方法来添加样式
4. 利用内部css样式的高优先级来覆盖外部css

以上实现思路的推荐程度***依次递减***

data-*是HTML5新增的DOM元素属性，作用大致可以理解为标记。具体用法可以参考MDN的这篇文章.而伪元素的content属性值除了常规赋值外，还有一种特殊的attr()方法来获取。

html:

```html
<div class="test" data-text="TEXT" data-color="red"></div>
```

css:

```css
.test::before{
    content: attr(data-text);
}
```

结果：

```sh
TEXT
```

另外content其实可以多个attr连写，而且attr()内的可以是DOM元素的任意属性（比如class等，甚至非W3C标准属性也支持，不过不推荐这么做)所以很方便凑一些模版文字。像下面这种写法也是完全没问题的。***注意用空格连接，不要用"+"号***。

```css
.test::before {
  content: '我的类是' attr(class) '想要变成' attr(data-color);
}
```

虽然W3C给attr()赋予了[无限可能性](http://www.w3.org/TR/css3-values/#attr-notation)，包括color,width等属性在未来都有希望用这个方法更改，然而**目前只有`content`支持该方法**，其余的都还是草稿状态，尚未有浏览器支持。之所以把这个方法放在第一位只是因为相比别的实现手法来说，这个方法真的太简单太优雅。

### 更改class来实现伪元素样式的更改

class切换大法，不适合多状态的场景（比如实时改变伪元素文字大小等）

### 利用CSSStyleSheet的insertRule方法来添加样式

CSSStyleSheet是浏览器存放页面内所有css样式表的对象方法（不包括行内样式)，每个link和style标签都代表一个CSSStyleSheet对象，获取他们可以用document.styleSheets方法。(需要注意的是虽然styleSheets方法返回的结果把link标签引进的外部样式也算进去了，但是非IE浏览器没办法获取到他们的cssRules属性，只有内嵌的style标签内的元素可以被获取到)

```js
document.styleSheets[0].insertRule('.test::before{color:green}',0)//chrome,firefox等非IE浏览器使用
document.styleSheets[0].addRule('.test::before{color:green}',0)//IE系列浏览器使用
/* 虽然部分浏览器也可以通过id来指定,'document.styleSheets.id.insertRule()'这种写法在chrome和IE下都行得通，但是firefox会返回'undefined',所以建议还是使用index值来获取stylesheet */
```

.insertRule的语法是stylesheet.insertRule(rule, index),另一个参数是index，意思是在对应的styleSheets里的cssRules样式表中的位置，这个值越大则样式优先级越高，但是值不能超过当前样式表规则（cssRules）长度（CSS中先定义的样式总是会被后定义的覆盖就是这个缘故。），当值小于cssRules长度时，添加的样式规则会插入到index值定义的位置，之前其余的规则依次顺延。

>addrule和insertRule方法本质上没区别，只是后者不被IE浏览器识别，所以前者作为浏览器兼容方法存在。

上面的代码看似简单一行，然而却不是每次都有效的。原因有以下几点：

1. document.styleSheets虽然按照style和link的顺序返回对应的StyleSheetList，然而第一个如果是link而不是style,前面讲过此时无法获取对应的cssRules，则document.styleSheets[0].cssRules为null，insertRule方法不起作用。（此情况只针对非IE浏览器，IE浏览器正常，但是定义的早往往意味着被后面的样式覆盖，所以意义不大）
2. 同上，如果页面内没有内嵌样式的style标签，则insertRule方法也无法发挥作用。
3. index值不够大的话很有可能会早于css文件开始的定义位置，导致被覆盖。因此有个折衷办法就是给添加的样式增加!important，虽然我个人比较反感这么做。

由此可见此方法的局限性，但是这种方法的优雅之处在于避免了直接写内嵌样式，而是通过css api来做更改。相比下面的方法来说，稍微好点。

### HEAD中添加style标签强制覆盖初始属性

这个方法是利用内部css样式的高优先级来覆盖外部css，好处是简单易理解，实现简单。坏处就是吃相太难看，过于粗暴。

```js
var style=document.createElement('style');
style.innerHTML=".test::before{color:green}";//添加样式内容的话也可以用上面提到过的`insertRule`,相对例子里的硬编码会更优雅点。
document.head.appendChild(style);
```

看到这里可能有些人反应过来了，其实加style标签这种方法可以是insertRule实现方法的大前提——因为不是所有页面一开始都有内嵌的style样式的。这种方法虽然不是很好，但是有时候却又确确实实是必须的——比如“拖动滑块改变伪元素内文字大小”这个需求。

### 练习

功能需求：

1. 拖动滑块改变伪元素内的文字大小
2. 且伪元素内随时显示当前字号
3. 通过一个按钮可以改变伪元素内文字颜色

这个需求可以将本文前面提到的四种改变伪元素样式的方法都塞进去。具体实现参照[DEMO](http://codepen.io/chitanda/pen/OVBJEw/)，不再做具体分析。



## Function.prototype.bind

在初学Javascript时，我们也许不需要担心函数绑定的问题。但是当我们需要在另一个函数中保持上下文对象this时，就会遇到相应的问题了。

我见过很多人处理这种问题都是先将this赋值给一个变量（比如self、_this、that等），尤其是var that = this是我见的最多的。这样当你改变环境之后就可以使用它。这些都是可以的，但是还有一种更好的、更专有的方法，那就是使用`Function.prototype.bind`。下面进行详尽的讲解。

### 第一部分：需要解决的问题

首先看下面的代码：

```js
var myObj = {
  specialFunction: function () {},
  anotherSpecialFunction: function () {},
  getAsyncData: function (cb) {
    cb();
  },
  render: function () {
    this.getAsyncData(function () {
      this.specialFunction();
      this.anotherSpecialFunction();
    });
  }
};

myObj.render();
```

这里我希望创建一个对象。包含了前面两个普通的方法；第三个方法可以传递一个函数，传入的这个函数立即执行。最后一个方法会调用myObj对象的getAsyncData方法，这里使用了this。然后在getAsyncData方法中传入了一个函数，这个函数继续调用这个对象的前两个方法，仍使用了this。这时很多人实际上就可以看出问题所在了，将上述代码输入控制台，得到下面的结果：

```sh
TypeError: this.specialFunction is not a function
```

### 第二部分：问题剖析

- 在对象中render方法中的this的确是指向myObj对象的，所以我们可以通过this.getAsyncData来调用这个对象中的函数。
- 但是当我们给其传递函数作为参数时，这里的this就指向了全局环境window了，因为全局环境中没有对象中的前两个方法，所以才会报错。

### 第三部分：解决问题的几种方式

所以我们需要做的就是正确调用对象中的前两个方法 ，很多人使用的方法便是：

- 首先在对象的环境中获取this赋值给另一个变量，这时就可以在后面的环境中调用了，如下所示：

  ```js
  render: function () {
    var that = this;
    this.getAsyncData(function () {
      that.specialFunction();
      that.anotherSpecialFunction();
    });
  }
  ```

  虽然这种方法是可行的。但是使用Function.prototype.bind()会使代码更清晰、易懂，如下所示：

  ```js
  render: function () {
    this.getAsyncData(function () {
      this.specialFunction();
      this.anotherSpecialFunction();
    }.bind(this));
  }
  ```

  这里我们就成功地把this绑定到了环境中。下面是另外一个简单的例子：

  ```js
  var foo = { x: 3 }
  
  var bar = function () {
    console.log(this.x);
  }
  
  bar(); // undefined
  
  var boundFunc = bar.bind(foo);
  boundFunc(); // 3
  ```

  下面的例子也是常见的：

  ```js
  this.x = 9; // this refers to global "window" object here in the browser
  
  var module = {
    x: 81,
    getX: function() { return this.x; }
  };
  module.getX(); // 81
  
  var retrieveX = module.getX;
  retrieveX();
  // returns 9 - The function gets invoked at the global scope
  // Create a new function with 'this' bound to module
  // New programmers might confuse the
  // global var x with module's property x
  var boundGetX = retrieveX.bind(module);
  boundGetX(); // 81
  ```

  如果有兴趣想知道 `Function.prototype.bind()` 内部长什么样以及是如何工作的，这里有个非常简单的例子：

  ```js
  Function.prototype.bind = function (scope) {
    var fn = this;
    return function () {
      return fn.apply(scope);
    };
  }
  ```

### 第四部分：浏览器支持

但是这个方法在IE8及以下是不被支持的，所以我们可以使用MDN提供的方法来使得IE低版本支持.bind()方法：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () { },
      fBound = function () {
        return fToBind.apply(this instanceof fNOP && oThis
          ? this
          : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
  };
}
```

## document.write

可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。该方法需要一个字符串参数，它是写到窗口或框架中的HTML内容。这些字符串参数可以是变量或值为字符串的表达式，写入的内容常常包括HTML标记语言。

记住，在载入页面后，浏览器输出流自动关闭。在此之后，任何一个对当前页面进行操作的document.write()方法将打开—个新的输出流，它将清除当前页面内容(包括源文档的任何变量或值)。因此，假如希望用脚本生成的HTML替换当前页面，就必须把HTML内容连接起来赋给一个变量，使用一个document.write()方法完成写操作。不必清除文档并打开一个新数据流，一个document.write()调用就可完成所有的操作。

关于document.write()方法还有一点要说明的是它的相关方法document.close()。脚本向窗口（不管是本窗口或其他窗口）写完内容后，必须关闭输出流。在延时脚本的最后一个document.write()方法后面，必须确保含有document.close()方法，不这样做就不能显示图像和表单。并且，任何后面调用的document.write()方法只会把内容追加到页面后，而不会清除现有内容来写入新值。为了演示document.write()方法，我们提供了同一个应用程序的两个版本。一个向包含脚本的文档中写内容，另—个向一个单独的窗口写内容。请在文本编辑器中键入每个文档，以.html文件扩展名保存，并在浏览器中打开文档。

示例1创建一个按钮，它为文档组合新的HTML内容，包括新文档标题的HTML标记和标记的颜色属性。示例中有一个读者所不熟悉的操作符+＝，它把其右侧的字符串加到其左侧的变量中，这个变量用来存放字符串，这个操作符能很方便地把几个单独的语句组合成—个长字符串。使用组合在newContent变量中的内容，document.write()语句可以把所有新内容写到文档中，完全清除示例1中的内容。然后需要调用document.close()语句关闭输出流。当载入该文档并单击按钮时，可以注意到浏览器标题栏中的文档标题因此而改变。当回到原始文档并再次单击该按钮时，可以看到动态写入的第二个页面的载入速度甚至比重载原始文档还要快。

示例1：在当前窗口使用document.write()。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Writing to Same Doc</title>
  <script language="JavaScript">
    function reWrite(){
      // assemble content for new window
      var newContent = "<html><head><title>A New Doc</title></head>"
      newContent += "<body bgcolor='aqua'><h1>This document is brand new.</h1>"
      newContent += "Click the Back button to see original document."
      newContent += "</body></html>"
      // write HTML to new window document
      document.write(newContent)
      document.close() // close layout stream
    }
  </script>
</head>
<body>
  <form>
    <input type="button" value="Replace Content" onClick="reWrite()">
  </form>
</body>
</html>
```

示例2中，情况有点复杂，因为脚本创建了一个子窗口，整个脚本生成的文档都将写入该窗口中。为了使新窗口的引用在两个函数中保持激活状态，我们将newWindow变量声明为全局变量。页面载入时，onLoad事件处理调用makeNewWindow()函数，该函数生成一个空的子窗口。另外，我们在window.open()方法的第三个参数中加入一个属性，使子窗口的状态栏可见。

页面上的按钮调用subWrite()方法，它执行的第一个任务是检查子窗口的closed属性。假如关闭了引用窗口，该属性（只在较新的浏览器版本中存在）返回true。如果是这种情况（假如用户手动关闭窗口），该函数再次调用makeNewWindow()函数来重新打开那个窗口。

窗口打开后，新的内容作为字符串变量组合在一起。与示例1一样，一次性写入内容（虽然对单独的窗口没有必要），接下来调用close()方法。但是注意一个重要的区别：write()和close()方法都明显地指定了子窗口。

示例2：在另一个窗口中使用document.write()

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Writing to Subwindow</title>
  <script language="JavaScript">
    var newWindow
    function makeNewWindow(){
      newWindow = window.open("","","status,height=200,width=300")
    }
    function subWrite(){
      // make new window if someone has closed it
      if(newWindow.closed){
        makeNewWindow()
      }
      // bring subwindow to front
      newWindow.focus()
      // assemble content for new window
      var newContent = "<html><head><title>A New Doc</title></head>"
      newContent += "<body bgcolor='coral'><h1>This document is brand new.</h1>"
      newContent += "</body></html>"
      // write HTML to new window document
      newWindow.document.write(newContent)
      newWindow.document.close()    // close layout stream
    }
  </script>
</head>
<body onLoad="makeNewWindow()">
  <form>
    <input type="button" value="Write to Subwindow" onClick="subWrite()">
  </form>
</body>
</html>
```

## document.execCommand

document.execCommand()方法处理Html数据时常用语法格式如下:

```js
document.execCommand(sCommand [, 交互方式, 动态参数])
```

其中：sCommand为指令参数（如下例中的"2D-Position"），交互方式参数如果是true的话将显示对话框，如果为false的话，则不显示对话框（下例中的"false"即表示不显示对话框），动态参数一般为一可用值或属性值（如下例中的"true"）。

```js
document.execCommand("2D-Position", "false", "true");
```

调用execCommand()可以实现浏览器菜单的很多功能。如保存文件、打开新文件、撤消、重做操作…等等。有了这个方法，就可以很容易的实现网页中的文本编辑器。使用的例子如下：

1、【全选】命令的实现

```js
格式：document.execCommand("selectAll")
说明：将选种网页中的全部内容！
```

2、【打开】命令的实现

```js
格式：document.execCommand("open")
说明：这跟VB等编程设计中的webbrowser控件中的命令有些相似，大家也可依此琢磨琢磨。
```

3、【另存为】命令的实现

```js
格式：document.execCommand("saveAs")
说明：将该网页保存到本地盘的其它目录！
```

4、【打印】命令的实现

```js
格式：document.execCommand("print")
说明：当然，你必须装了打印机！
```

**下面列出的是指令参数及意义：**

```js
//相当于单击文件中的打开按钮
document.execCommand("Open");
//将当前页面另存为
document.execCommand("SaveAs");
//剪贴选中的文字到剪贴板;
document.execCommand("Cut", "false" ,null);
//删除选中的文字;
document.execCommand("Delete", "false", null);
//改变选中区域的字体;
document.execCommand("FontName", "false", sFontName);
//改变选中区域的字体大小;
document.execCommand("FontSize", "false", sSize|iSize);
//设置前景颜色;
document.execCommand("ForeColor", "false", sColor);
//使绝对定位的对象可直接拖动;
document.execCommand("2D-Position", "false", "true");
//使对象定位变成绝对定位;
document.execCommand("AbsolutePosition", "false", "true");
//设置背景颜色;
document.execCommand("BackColor", "false", sColor);
//使选中区域的文字加粗;
document.execCommand("Bold", "false", null);
//复制选中的文字到剪贴板;
document.execCommand("Copy", "false", null);
//设置指定锚点为书签;
document.execCommand("CreateBookmark", "false", sAnchorName);
//将选中文本变成超连接,若第二个参数为true,会出现参数设置对话框;
document.execCommand("CreateLink", "false", sLinkURL);
//设置当前块的标签名;
document.execCommand("FormatBlock", "false", sTagName);
```

document对象execCommand通常在IE中在线处理Html数据时非常有用，它可以让你轻而易举实现文字的加粗、加颜色、加字体等一系列的命令。

- D-Position 允许通过拖曳移动绝对定位的对象。
- AbsolutePosition 设定元素的 position 属性为"absolute"（绝对）。
- BackColor 设置或获取当前选中区的背景颜色。
- BlockDirLTR 目前尚未支持。
- BlockDirRTL 目前尚未支持。
- Bold 切换当前选中区的粗体显示与否。
- BrowseMode 目前尚未支持。
- Copy 将当前选中区复制到剪贴板。
- CreateBookmark 创建一个书签锚或获取当前选中区或插入点的书签锚的名称。
- CreateLink 在当前选中区上插入超级链接，或显示一个对话框允许用户指定要为当前选中区插入的超级链接的 URL。
- Cut 将当前选中区复制到剪贴板并删除之。
- Delete 删除当前选中区。
- DirLTR 目前尚未支持。
- DirRTL 目前尚未支持。
- EditMode 目前尚未支持。
- FontName 设置或获取当前选中区的字体。
- FontSize 设置或获取当前选中区的字体大小。
- ForeColor 设置或获取当前选中区的前景（文本）颜色。
- FormatBlock 设置当前块格式化标签。
- Indent 增加选中文本的缩进。
- InlineDirLTR 目前尚未支持。
- InlineDirRTL 目前尚未支持。
- InsertButton 用按钮控件覆盖当前选中区。
- InsertFieldset 用方框覆盖当前选中区。
- InsertHorizontalRule 用水平线覆盖当前选中区。
- InsertIFrame 用内嵌框架覆盖当前选中区。
- InsertImage 用图像覆盖当前选中区。
- InsertInputButton 用按钮控件覆盖当前选中区。
- InsertInputCheckbox 用复选框控件覆盖当前选中区。
- InsertInputFileUpload 用文件上载控件覆盖当前选中区。
- InsertInputHidden 插入隐藏控件覆盖当前选中区。
- InsertInputImage 用图像控件覆盖当前选中区。
- InsertInputPassword 用密码控件覆盖当前选中区。
- InsertInputRadio 用单选钮控件覆盖当前选中区。
- InsertInputReset 用重置控件覆盖当前选中区。
- InsertInputSubmit 用提交控件覆盖当前选中区。
- InsertInputText 用文本控件覆盖当前选中区。
- InsertMarquee 用空字幕覆盖当前选中区。
- InsertOrderedList 切换当前选中区是编号列表还是常规格式化块。
- InsertParagraph 用换行覆盖当前选中区。
- InsertSelectDropdown 用下拉框控件覆盖当前选中区。
- InsertSelectListbox 用列表框控件覆盖当前选中区。
- InsertTextArea 用多行文本输入控件覆盖当前选中区。
- InsertUnorderedList 切换当前选中区是项目符号列表还是常规格式化块。
- Italic 切换当前选中区斜体显示与否。
- JustifyCenter 将当前选中区在所在格式化块置中。
- JustifyFull 目前尚未支持。
- JustifyLeft 将当前选中区所在格式化块左对齐。
- JustifyNone 目前尚未支持。
- JustifyRight 将当前选中区所在格式化块右对齐。
- LiveResize 迫使 MSHTML 编辑器在缩放或移动过程中持续更新元素外观，而不是只在移动或缩放完成后更新。
- MultipleSelection 允许当用户按住 Shift 或 Ctrl 键时一次选中多于一个站点可选元素。
- Open 目前尚未支持。
- Outdent 减少选中区所在格式化块的缩进。
- OverWrite 切换文本状态的插入和覆盖。
- Paste 用剪贴板内容覆盖当前选中区。
- PlayImage 目前尚未支持。
- Print 打开打印对话框以便用户可以打印当前页。
- Redo 目前尚未支持。
- Refresh 刷新当前文档。
- RemoveFormat 从当前选中区中删除格式化标签。
- RemoveParaFormat 目前尚未支持。
- SaveAs 将当前 Web 页面保存为文件。
- SelectAll 选中整个文档。
- SizeToControl 目前尚未支持。
- SizeToControlHeight 目前尚未支持。
- SizeToControlWidth 目前尚未支持。
- Stop 目前尚未支持。
- StopImage 目前尚未支持。
- StrikeThrough 目前尚未支持。
- Subscript 目前尚未支持。
- Superscript 目前尚未支持。
- UnBookmark 从当前选中区中删除全部书签。
- Underline 切换当前选中区的下划线显示与否。
- Undo 目前尚未支持。
- Unlink 从当前选中区中删除全部超级链接。
- Unselect 清除当前选中区的选中状态。

```html
// 最后更新时间
<script>document.lastModified</script>

// 2秒后载入指定网页
<meta http-equiv="refresh" content="2;URL=http://你的网址">

// 添加到收藏夹
<script Language="Javascript">
function bookmarkit() {
  window.external.addFavorite('http://你的网址', '你的网站名称');
}
if (document.all)
  document.write('<a href="#" onClick="bookmarkit()">加入收藏夹</a>');
</script>

// 禁止鼠标右键的动作
<script Language = "Javascript">
function click() {
  if (event.button==2 || event.button==3) {
　　alert('禁止鼠标右键');
　}
}
document.onmousedown=click
</script>
```

## 获取数组中最大值和最小值的方法汇总

```js
// 方法一：
// 最小值
if (typeof Array.prototype[min] == 'undefined') {
  Array.prototype.min = function() {
    var min = this[0];
    var len = this.length;
    for (var i = 1; i < len; i++){
      if (this[i] < min){
        min = this[i];
      }
    }
    return min;
  }
}
//最大值
if (typeof Array.prototype['max'] == 'undefined') {
  Array.prototype.max = function() {
    var max = this[0];
    var len = this.length;
    for (var i = 1; i < len; i++){
      if (this[i] > max) {
        max = this[i];
      }
    }
    return max;
  }
}

/*
方法二：
用Math.max和Math.min方法可以迅速得到结果。apply能让一个方法指定调用对象与传入参数，并且传入参数是以数组形式组织的。恰恰现在有一个方法叫Math.max，调用对象为Math，与多个参数
*/
Array.max = function(array){
  return Math.max.apply(Math, array);
};
Array.min = function(array){
  return Math.min.apply(Math, array);
};
// Math对象也是一个对象，我们用对象的字面量来写，又可以省几个比特了，直接使用null也可以
Array.max = function(array){
  return Math.max.apply({}, array);
};
Array.min = function(array){
  return Math.min.apply({}, array);
};
```

## 动态加载JS和CSS

1、直接document.write

```html
<script language="javascript">
  document.write("<script src='test.js'><\/script>");
</script>
```

2、动态改变已有script的src属性

```html
<script src='' id="s1"></script>
<script language="javascript">
  s1.src="test.js"
</script>
```

3、动态创建script元素

```html
<script>
  var oHead = document.getElementsByTagName('head').item(0);
  var oScript= document.createElement("script");
  oScript.type = "text/javascript";
  oScript.src="test.js";
  oHead.appendChild( oScript);
</script>
```

4、原理：用 `XMLHTTP` 取得脚本的内容，再创建 `Script` 对象。

>注意：a.js必须用UTF8编码保存，要不会出错。因为服务器与XML使用UTF8编码传送数据。

主页面代码：

```html
<script language="JavaScript">
function GetHttpRequest() {
  if (window.XMLHttpRequest) //Gecko
    return new XMLHttpRequest() ;
  else if (window.ActiveXObject) //IE
    return new ActiveXObject("MsXml2.XmlHttp") ;
}

function AjaxPage(sId, url){
  var oXmlHttp = GetHttpRequest();
  oXmlHttp.OnReadyStateChange = function() {
    if (oXmlHttp.readyState == 4) {
      if (oXmlHttp.status == 200 || oXmlHttp.status == 304) {
        IncludeJS(sId, url, oXmlHttp.responseText);
      } else {
        alert('XML request error: ' + oXmlHttp.statusText + ' (' + oXmlHttp.status + ')') ;
      }
    }
  }
  oXmlHttp.open('GET', url, true);
  oXmlHttp.send(null);
}

function IncludeJS(sId, fileUrl, source) {
  if (source != null && !document.getElementById(sId)){
    var oHead = document.getElementsByTagName('head').item(0);
    var oScript = document.createElement("script");
    oScript.language = "javascript";
    oScript.type = "text/javascript";
    oScript.id = sId;
    oScript.defer = true;
    oScript.text = source;
    oHead.appendChild(oScript);
  }
}

AjaxPage("srcA", "b.js");

// 动态加载css文件
function loadStyles(url) {
  var link = document.createElement("link");
  link.type = "text/css";
  link.rel = "stylesheet";
  link.href = url;
  document.getElementsByTagName("head")[0].appendChild(link);
}
// 测试
loadStyles("css/secondindex.css");

// 动态加载css脚本
function loadStyleString(cssText) {
  var style = document.createElement("style");
  style.type = "text/css";
  try{
    // firefox、safari、chrome和Opera
    style.appendChild(document.createTextNode(cssText));
  }catch(ex) {
    // IE早期的浏览器，需要使用style元素的stylesheet属性的cssText属性
    style.styleSheet.cssText = cssText;
  }
  document.getElementsByTagName("head")[0].appendChild(style);
}

// 测试
var css = "body{color:blue;}";
loadStyleString(css);
</script>
```

## 判断IE版本的HTML语句详解

我们常常会在网页的HTML里面看到形如 `[if lte IE 9]……[endif]` 的代码，表示的是限定某些浏览器版本才能执行的语句，那么这些判断语句的规则是什么呢？请看下文：

```html
<!--[if !IE]><!--> 除IE外都可识别 <!--<![endif]-->
<!--[if IE]> 所有的IE可识别 <![endif]-->
<!--[if IE 6]> 仅IE6可识别 <![endif]-->
<!--[if lt IE 6]> IE6以及IE6以下版本可识别 <![endif]-->
<!--[if gte IE 6]> IE6以及IE6以上版本可识别 <![endif]-->
<!--[if IE 7]> 仅IE7可识别 <![endif]-->
<!--[if lt IE 7]> IE7以及IE7以下版本可识别 <![endif]-->
<!--[if gte IE 7]> IE7以及IE7以上版本可识别 <![endif]-->
<!--[if IE 8]> 仅IE8可识别 <![endif]-->
<!--[if IE 9]> 仅IE9可识别 <![endif]-->
```

| 项目 | 范例                     | 说明                                                         |
| ---- | ------------------------ | ------------------------------------------------------------ |
| !    | [if !IE]                 | The NOT operator. This is placed immediately in front of the feature, operator, or subexpression to reverse the Boolean meaning of the expression. |
| lt   | [if lt IE 5.5]           | The less-than operator. Returns true if the first argument is less than the second argument. |
| lte  | [if lte IE 6]            | The less-than or equal operator. Returns true if the first argument is less than or equal to the second argument. |
| gt   | [if gt IE 5]             | The greater-than operator. Returns true if the first argument is greater than the second argument. |
| gte  | [if gte IE 7]            | The greater-than or equal operator. Returns true if the first argument is greater than or equal to the second argument. |
| ( )  | [if !(IE 7)]             | Subexpression operators. Used in conjunction with boolean operators to create more complex expressions. |
| &    | [if (gt IE 5)&(lt IE 7)] | The AND operator. Returns true if all subexpressions evaluate to true. |
| \|   | [if (IE 6)\|(IE 7)]      | The OR operator. Returns true if any of the subexpressions evaluates to true. |

```html
<!--[if lt IE 9]>
  加载CSS1
<!--[else]>
  加载CSS2
<![endif]-->
```

这样有效是有效，但是用HTML VALIDATOR，报错。因为这个不符合XHTML 1.1的规范。如果把ELSE语句去掉，则正确。

```html
加载CSS2
<!--[if lt IE 9]>
  加载CSS1(可以把要重写的写在这里).
<![endif]-->
```

用法：可使用如下代码检测当前IE浏览器的版本（注意：在非IE浏览器中是看不到效果的）

```html
<!––[if IE]>
  <h1>您正在使用IE浏览器</h1>
  <!––[if IE 5]>
    <h2>版本 5</h2>
  <![endif]––>
  <!––[if IE 5.0]>
    <h2>版本 5.0</h2>
  <![endif]––>
  <!––[if IE 5.5]>
    <h2>版本 5.5</h2>
  <![endif]––>
  <!––[if IE 6]>
    <h2>版本 6</h2>
  <![endif]––>
  <!––[if IE 7]>
    <h2>版本 7</h2>
  <![endif]––>
<![endif]––>
```

那如果当前的浏览器是IE，但版本比IE5还低，该怎么办呢，可以使用`<!–[if ls IE 5]>`，当然，根据条件注释只能在IE5+的环境之下，所以`<!–[if ls IE 5]>`根本不会被执行。

- lte：就是Less than or equal to的简写，也就是小于或等于的意思。
- lt：就是Less than的简写，也就是小于的意思。
- gte：就是Greater than or equal to的简写，也就是大于或等于的意思。
- gt：就是Greater than的简写，也就是大于的意思。
- !：就是不等于的意思，跟javascript里的不等于判断符相同

## 让IE6/IE7/IE8支持CSS3属性的8种方法介绍

我们都知道，IE浏览器暂不支持CSS3的一些属性。国外的工程师们，不安于此现状，他们总是尽量使用一些手段使IE浏览器也能支持CSS3属性，我觉得这些都是很有意义，很有价值的工作，可以推动整个技术领域的进步的。到目前为止，有不少可以让IE支持部分CSS3属性的工具。例如：

1. Dean Edwards的IE7.js (以及 IE8.js, IE9.js)

   这个玩意估计是试图让IE支持CSS3属性的鼻祖，还算蛮强大，就是性能开销较大，要解析很多文件脚本，给DOM添加大量的元素以及ClassName。

2. Aaron Gustafson的 eCSStender

   此方法支持@font-face, CSS3 选择器, 以及 CSS3 Backgrounds 和 Borders。

3. Drew Diller的 DD_roundies

   这是一个基于IE VML实现一些CSS3效果的。

4. Remiz Rahnas的border-radius.htc

   此方法使用htc文件，配合VML实现，缺点在于不能自动适应目标元素的位置和大小，所以不能适用于动态脚本环境。

5. Nick Fetchak的 ie-css3.htc

   关于此方法，我在前面的“让IE6/IE7/IE8浏览器支持CSS3属性”这篇文章中已经做过介绍。我是建议您看看这篇文章，倒不是ie-css3.htc这个玩意多么好，而是文中对htc文件以及VML预言做了些介绍，对于您了解IE下实现类似CSS3效果原理有所了解。

6. Keith Clark的ie-css3.js

   这是个与IE7.js类似的项目，其选择器可借助其他JavaScript库，所以其本身较小。

7. zoltandulac的cssSandpaper

   这是一个使用IE滤镜实现一些CSS3属性的方法。

8. css3pie的css3 PIE.htc

   支持：border-radius圆角 、 box-shadow 盒阴影 、 gradient渐变 、 multiple background images多背景 。

下面对第8种方法的做一下简单介绍：

- 官方网站：[http://css3pie.com/](http://css3pie.com/)

使用方法：

- 第一步：下载css3 PIE.htc 文件

- 第二步：将PIE.htc文件上传到你的网站目录中，上传到目录哪里都可以，只要你记住这个目录。

- 第三步：创建html文件，写一段css3代码，并引入PIE.htc，如下面这段：

  ```css
  #id {
       border: 1px solid #999;
       -webkit-border-radius: 10px;
       -moz-border-radius: 10px;
       border-radius: 10px;
       behavior: url(path/to/PIE.htc);
  }
  ```

>注意：.htc 文件路径是相对于html文件的路径，而不是相对于css文件。已知的一些问题：此方法并不是万能的，也有一些局限性和需要注意的地方。

1. z-index相关问题

   IE下这些CSS3效果实现是借助于VML，由VML绘制圆角或是投影效果的容器元素，然后这个容器元素作为目标元素的后兄弟节点插入，如果目标元素position:absolute 或是 position:relative，则这个css3-container元素将会设置与之一样的z-index值，在DOM tree中，同级的元素总是后面的覆盖前面的，所以这样就实现了覆盖，又避免了可能有其他元素正好插入其中。

   所以，问题来了，如果目前元素的position属性为static，也就是默认属性，则z-index属性是没有用的，无覆盖可言，所以此时IE浏览器下CSS3的渲染是不会成功的。要解决也很简单，设置目标元素position:relative或是设置祖先元素position:relative并赋予一个z-index值（不可为-1）。

2. 相当路径的问题

   IE浏览器的behavior 属性是相对于HTML文档而言的，与CSS其他的属性不一样，不是相对于CSS文档而言的。这使得使用pie.htc文件不怎么方便。如果绝对路径于根目录，则CSS文件不方便移动；如果相对路径与HTML文档，则pie.htc文件在不同HTML页面见的重用性大大降低。同时，诸如border-image后面的URL属性路径也不好处理。

3. 缩写的问题

   使用PIE实现IE下的CSS3渲染（其他方法也是一样），只能使用缩写的形式，例如圆角效果，我们可以设置border-top-left-radius表示左上圆角，但是PIE确实不支持这种写法的，只能是老老实实的缩写。

4. 提供正确的Content-Type

   要想让IE浏览器支持htc文件，需要一个有着"text/x-component" 字样的content-type 头部，否则，会忽视behavior。绝大数web服务器提供了正确的content-type，但是还有一部分则有问题。

   如果您发现在您的机子上PIE方法无效，也就是htc文件这里指pie.htc文件无效，检查您的服务器配置，可能其需要更新到最新的content-type。例如对于Apache，您可以在.htaccess文件中做如下处理：

   ```txt
   AddType text/x-component .htc
   ```

   但是，由于某种原因，您无法修改服务器配置（例如公用主机，或是空间服务商提供的服务器），您可以用一个PHP文件来间接调用htc文件。我只要给你看下这个PHP文件的代码您就知道什么意思了，如下：

   ```php
   <?php
     header( 'Content-type: text/x-component' );
     include( 'pie.htc' );
   ?>
   ```

   通过PHP文件来增加一个含有"text/x-component"字样的Content-type头，同时调用pie.htc文件。关于上面所示的php文件，您可以直接新建一个php文件，把上面的两行代码复制进去。如果您使用上述php文件，您需要将pie.php和pie.htc放在同一个文件夹目录下，同时CSS中的behavior写法应该是：`behavior: url(pie.php);`

>以上为一些常见的主要的问题，当然，在复杂的页面情况下，还会有其他意想不到的情况，这里，祝您好运了！

### window和document

The JavaScript Window object is the highest level JavaScript object which corresponds to the web browser window.

最外层的JavaScript对象其对应于web浏览器窗口

The document object is the container for all HTML HEAD and BODY objects associated within the HTML tags of an HTML document. This could correspond to the top-most window, or an iframe within the window.

文档对象是一个HTML文档的HTML标签中相关联的所有HTML头部和身体对象的容器。这可以对应于最上面的窗口，或在窗口内的iframe

After a quick test there really is no difference between the two. However, as others have said, window.onclick did not work when tested in IE8. So apparently the bottom line is that document.onclick is the preferred choice.

window.onclick 不能在IE8下工作，在低版本中 document.onclick 为首选

## object

### wbbrowser

今天用到了wbbrowser控件做页面打印，感觉非常强大。索性收集了html object标签的一些知识，整理于此供需要时查阅。

首先放出这个强大web页面打印[例子](../codes/5.1.1_print.html)。接下来我将收集到的html object控件标签罗列在此，具体应用的例子后续有时间补上。

### 地理位置

通过获取地理位置信息在地图上显示当前位置

### 历史记录管理

使用pushState()方法进行历史记录管理

### 跨域消息传递

Twitter搜索gadget，由postMessage()来控制

通过postMessage()来使用Twitter搜索gadget

### WebWorker

## 流式编程

>有时候也可以成为函数式编程。它的主要目的是在数据拉取的过程中渲染页面，即边处理数据边渲染页面。

类似概念：

- 流式应用：Rxjs
- 流式列表
- 流式处理：大数据、实时计算
- 文件处理、字节流、加密、网络

### 流式应用

![x](D:/WorkingDir/Office/Resource/流式应用.png)

RxJS本身一直试图将数据、dom等前端元素看做流处理。它的思想其实就是流式编程思想的一种。如果你使用过RxJS，你会非常快速的理解流式编程的核心理念。

但是RxJS更多的是将操作，包括http请求、dom操作等看做流的形式，在普通请求、操作的基础上封装出了一个流的上层对象。它只能算做流式编程思想的其中一部分。流式编程更加的靠前，它包含了页面结构设计、请求顺序等一些列的东西。

### 瀑布流

![x](D:/WorkingDir/Office/Resource/瀑布流.png)

开发前端的同学或多或少都会遇到瀑布流页面，哪怕没开发过也见过、研究过。

瀑布流完全是将页面（一部分）看过了一个流式页面，如果页面向下流动，页面能够自然达到的顺序就是瀑布流希望/想要达到的效果。

流式编程思想更多的是提出页面整体上的流式，而不仅仅是页面的某一部分。假如你做的瀑布流页面是完全靠`position`绝对定位实现的。很抱歉，这样的页面仅仅是实现了瀑布流，但它不属于流式编程。流式编程提倡使用正常的文档流去开发。让页面渲染能够一泻而下，通畅而不阻塞。不需要重新绘制dom树才是流式编程在页面开发上的核心要点。

### 实时计算

![x](D:/WorkingDir/Office/Resource/实时计算.png)

这里拿出实时计算就是为了让开发者能够从不同的方面去理解流式编程的思想。

不管是页面还是请求、甚至是各种操作等，将它们看做一个流，顺着网络请求的顺序，页面渲染逻辑的顺序向一点去前进。这个点就是流式编程。所有的东西都通过流式编程思想去处理，将它们混杂在一起，然后处理成一个一个单独块。这个块包含当时情况下最应该做的操作（dom、http、click等），然后打包出现在页面上。这个就是流式编程的核心思想。

### 流处理

![x](D:/WorkingDir/Office/Resource/流处理.png)

这里使用了流去举例是因为流的读写操作从概念上是非常贴合流式编程思想的。

从文件上开一个通道去获取数据，然后拿到的同时就做相应的处理，同时在处理完就将它们放出来。这个过程也就是流式编程思想在构思页面结构的时候想要做的。

### 页面结构

原始页面是嵌套的，但是去掉嵌套来看，整个页面是一个从上到下的渲染过程。在渲染的过程中如果触发页面重绘，或者是出现脱离文档流的样式，整个页面的性能就会下降。由此可见，前端结构是需要尽量流式的展示的。

从这个点出发就是流式编程中的dom结构流式编程。

![x](./Resource/liushi.png)

从页面结构设计上考虑，首屏渲染的时间把握其实就是在考验开发者的流式编程思想。让页面尽可能早的呈现第一屏的dom结构，同时尽量早的加载完成第一屏的图片等资源文件。其他会对页面渲染阻塞都要往后排。

如果使用流式编程思想重新设计页面结构，单从结构上来说，一个首屏的渲染了不起20ms就到顶了，再加上各种资源加载，这些综合下来首页的加载速度一般可以提到500ms以内。这个时间才是首页渲染应该有的时间。如果是手机上，不考虑网络差的情况甚至可以做到300ms内打开页面。

![x](./Resource/WX20190430-182707@2x.png)

从图中可以看到，一部分请求在蓝色线左边，也就是页面必须使用到的。后面的4个请求是页面加载之后用到的，这几个请求是可以后加载的。其中1个是接口，然后几个是渲染页面用到的js文件。他们的顺序就是先渲染页面框架，然后再填充下面的内容。

真正的让页面飞起来，从页面结构上开始考虑。

### 接口请求

![x](D:/WorkingDir/Office/Resource/接口请求.png)

打开页面甚至在页面什么也没有展示的时候，接口就会请求数据。从上面的截图可以看到一个页面首次打开可以请求多少接口，甚至截图中的接口请求个数都不是非常多的那种。

有的页面请求3、5个，有的请求10多个。从整体上看，大多数接口是一个顺序请求的过程。它受到页面结构的影响，过快的请求反而渲染的不是所需要的地方。

页面的请求顺序就可以看做是一个流式的过程。将需要同步渲染的接口放在一起，等待结果返回之后再展示页面。剩下的几个不需要优先渲染的往后推，通过事件触发等方式在页面渲染之后再继续执行。

>tips:有些接口可以同时异步执行，使用并行请求，将页面渲染分离，可以加速页面的呈现。tips:多次请求需要多次握手，使用http2.0可以加速这个时间。合并接口可以直接去掉多余时间。

### 优化顺序

通过上面的分析，我们可以对流式编程有一个大概的印象，一些想法思路可以总结下来：

1. 按照页面渲染顺序做开发。没必要呈现的后渲染，可以加速页面展示。避免在页面加载过程中不断重绘。
2. 多余接口后请求，优先渲染第一屏。接口请求往往意味着后面有一些逻辑需要执行，将不需要第一时间请求的接口往后放可以节省很多加载时间，就像分页加载一样加载页面，页面可以更快打开。
3. 从结构上优化。先加载的先请求，先呈现的先计算，后加载的排队来，后呈现的叠加计算。这里的排队可以类比分页加载来思考怎么实现。叠加计算更多的是在当前状态上更新新的页面。

### 单接口情况

![x](D:/WorkingDir/Office/Resource/单接口情况.png)

单接口的时候会遇到数据量大，结构复杂。页面结构也会相应的增长复杂度。面对这种一次性接收大量数据的情况下，最优先考虑是优化数据结构。将大的复杂的结构分化成合适的小的结构，这样分解之后再使用会减少很多开发过程中的麻烦。把问题前置，预先处理复杂的数据，后面用到的时候才会更合适。同时，如果数据结构还有变化，也能够及时的调整应对。

应对这种情况，我们可以从几个方面入口去优化。

1. 加速接口返回速度。这个往往比较容易。

   ![x](./Resource/WX20190430-184828@2x.png)

2. 分析页面结构，将页面分成不同侧重点的部分。比如商品详情这个页面，可以分成商品简略信息和详情2个部分。其中简略信息包含几个头图、价格、卖点等信息。详情包含规格、复杂的介绍内容。（如果有需要，价格也可以分开，将价格单独分成一个接口）

3. 数据适配。我们已经将页面分成了2个部分，这里就可以单独把第一个部分放在一个对象中做渲染。这里使用vue、react等框架会得到非常及时的渲染结果，省下了大量的dom操作时间。剩下的部分放在滑动事件中，滑动页面的时候再渲染。

   ![x](./Resource/WX20190430-185303@2x.png)

4. 异步加载。这里继续使用商品详情的例子。当用户点击或者下滑的时候需要展示商品的各种规格、宣传图等。我们可以先渲染容器，保证页面结构的统一化。然后再根据页面当前位置逐步加载需要显示的图片等资源。这里同时也会涉及到超长列表的优化。其实非常简单，就是保持容器不变，内部渲染内容在超出屏幕之后删除，保证页面上的dom数量不至于太多。

上面的几点初步展示了怎么样优化一个大数据块的页面。正在遇到这个问题的同学可以根据这个思路去思考解决方案了。

### 多接口

多接口的情况往往是需要并行的和需要并发的接口齐上阵，一不注意就造成接口阻塞。

![x](./Resource/WX20190430-185531@2x.png)

1. 首先分析出页面具有哪些不同的部分。这些不同的部分的结构要隔离开，方便做不同的逻辑处理。这里推荐组件化形式处理，可以更方便的隔离不同的逻辑结构。

   ![x](./Resource/WX20190430-185845@2x.png)

2. 接口处理。后端基于某些（不靠谱）考虑会出几种不同的接口。这个时候前端更多的是区分接口的优先级和功能域。相同功能依赖的接口同步等待。不同的功能域之间梳理加载顺序。如果发现功能域不是优先展示的，可以放在异步或者触发式功能域中。

3. 先返回的数据先渲染，后返回的数据后渲染。多种渲染使用组件分离。

>这里提到了一个功能域，这其实是一个领域的概念。一个功能域包含特定的页面结构、依赖的接口。这里可以看做一个组件，内部包含了页面结构接口请求。

### 实时+触发

这个场景更多的出现在交互比较频繁的地方。比如一个按钮可以无限次的点击，滚动的时候有一个出现隐藏的动画/结构等。

![x](./Resource/WX20190430-190818@2x.png)

1. 如果一个操作多次触发，为了保持反馈/动画的稳定性，这里是一定要做控制的。典型的解决方式就是节流函数控制。或者也可以考虑从展示逻辑上处理，实现更简单。上滑的时候出现滑动小动画，如果不懂上滑其实只需要做一次动画即可。只有上一次动画做完才会执行下一个动画。这其实也是最简单的流式思想。

   ![x](./Resource/WX20190430-190420@2x.png)

2. 如果一个页面可能会多次展示隐藏，同时内部的数据是异步获取的。这个场景下优先考虑缓存渲染结果，第一次的时候加载数据，后面在展示的时候其实一直在用一个缓存来渲染结果。从流程上看就简化为了data=>dom。

### 复杂页面

复杂的页面跟多的是上面几种的组合。只要能够识别到那些地方归属那种情况，再去优化就有一个清晰的目标了。

![x](D:/WorkingDir/Office/Resource/好东西流程.jpg)

1. 产品级分析。看到原型或者UI的时候基本就能够知道页面未来会长什么样子了。这个时候也就是一个复杂的页面最应该开始构思结构的时候。分析页面功能点，区分哪些是先展示，哪些是触发之后展示。然后设计页面结构，隔离不同展示区域。
2. 不同的结构使用不同的接口，接口之间也是分属不同的功能域。如果一个接口内容特别多，可以从逻辑上将一个接口分成好几个部门处理。尤其是要渲染很多内容的时候，分开渲染速度更快。
3. 有些结构完全可以设计到触发之后再加载。比如第二屏展示的内容，点击之后才能看到的地方等。

## 总结

流式编程将页面结构看做数据，多个数据并行展示看做一个整体。通过这样宏观的抽象整理，将页面变成了一个流动的对象。从根本上改变了开发的形态。

在实际开发中使用流式编程思想可以很容易的开发出高性能的页面。页面渲染更快，展示更合理。同时反过来加速了代码结构的进化，促进开发者思考和成长。

## DOM操作成本到底高在哪儿

作者：[palmerye](http://segmentfault.com/a/1190000014070240)

从我接触前端到现在，一直听到的一句话：操作DOM的成本很高，不要轻易去操作DOM。尤其是React、vue等MV*框架的出现，数据驱动视图的模式越发深入人心，jQuery时代提供的强大便利地操作DOM的API在前端工程里用的越来越少。刨根问底，这里说的成本，到底高在哪儿呢？

### 什么是DOM

**Document Object Model 文档对象模型：**

什么是DOM？可能很多人第一反应就是div、p、span等html标签（至少我是），但要知道，DOM是Model，是Object Model，对象模型，是为HTML(and XML)提供的API。HTML(Hyper Text Markup Language)是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。但在浏览器端，前端们可以用脚本语言(JavaScript)通过DOM去操作HTML内容。

那么问题来了，只有JavaScript才能调用DOM这个API吗？答案是NO。

Python也可以访问DOM。所以DOM不是提供给Javascript的API，也不是Javascript里的API。

>PS: 实质上还存在CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构，与DOM是两个独立的数据结构。

### 浏览器渲染过程

讨论DOM操作成本，肯定要先了解该成本的来源，那么就离不开浏览器渲染。

这里暂只讨论浏览器拿到HTML之后开始解析、渲染。

1. 解析HTML，构建DOM树（这里遇到外链，此时会发起请求）
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树(Layout/reflow)，负责各元素尺寸、位置的计算
5. 绘制render树(paint)，绘制页面像素信息
6. 浏览器会将各层的信息发送给GPU，GPU将各层合成(composite)，显示在屏幕上

### 1.构建DOM树

```html
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="style.css" rel="stylesheet">
  <title>Critical Path</title>
</head>
<body>
  <p>Hello <span>web performance</span> students!</p>
  <div><img src="awesome-photo.jpg"></div>
</body>
</html>
```

无论是DOM还是CSSOM，都是要经过 Bytes → characters → tokens → nodes → objectmodel 这个过程。

![x](./Resource/80.png)

DOM树构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

### 2.构建CSSOM树

上述也提到了CSSOM的构建过程，也是树的结构，在最终计算各个节点的样式时，浏览器都会先从该节点的普遍属性（比如body里设置的全局样式）开始，再去应用该节点的具体属性。还有要注意的是，每个浏览器都有自己默认的样式表，因此很多时候这棵CSSOM树只是对这张默认样式表的部分替换。

### 3.生成render树

DOM树和CSSOM树合并生成render树

![x](./Resource/81.png)

**简单描述这个过程：**

DOM树从根节点开始遍历可见节点，这里之所以强调了“可见”，是因为如果遇到设置了类似 `display:none;` 的不可见节点，在 render 过程中是会被跳过的（但 `visibility:hidden;` `opacity:0` 这种仍旧占据空间的节点不会被跳过render），保存各个节点的样式信息及其余节点的从属关系。

### 4.Layout 布局

有了各个节点的样式信息和属性，但不知道各个节点的确切位置和大小，所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置。

### 5.Paint 绘制

万事俱备，最后只要将确定好位置大小的各节点，通过GPU渲染到屏幕的实际像素。

Tips:

- 在上述渲染过程中，前3点可能要多次执行，比如js脚本去操作dom、更改css样式时，浏览器又要重新构建DOM、CSSOM树，重新render，重新layout、paint；
- Layout在Paint之前，因此每次Layout重新布局（reflow 回流）后都要重新触发Paint渲染，这时又要去消耗GPU；
- Paint不一定会触发Layout，比如改个颜色改个背景；（repaint 重绘）
- 图片下载完也会重新触发Layout和Paint；

![x](./Resource/82.png)

### 何时触发reflow和repaint

- reflow（回流）：根据Render Tree布局（几何属性），意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；
- repaint（重绘）：意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；
- reflow回流的成本开销要高于repaint重绘，一个节点的回流往往会导致子节点以及同级节点的回流；

GoogleChromeLabs 里面有一个csstriggers，列出了各个CSS属性对浏览器执行Layout、Paint、Composite的影响。

### 引起reflow回流

现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。

1. 页面第一次渲染（初始化）
2. DOM树变化（如：增删节点）
3. Render树变化（如：padding改变）
4. 浏览器窗口resize
5. 获取元素的某些属性：

浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括offsetLeft、offsetTop、offsetWidth、offsetHeight、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、调用了getComputedStyle()或者IE的currentStyle

### 引起repaint重绘

1. reflow回流必定引起repaint重绘，重绘可以单独触发
2. 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）

### 优化reflow、repaint触发次数

- 避免逐个修改节点样式，尽量一次性修改
- 使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染
- 可以将需要多次修改的DOM元素设置 display:none，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘）
- 避免多次读取某些属性（见上）
- 将复杂的节点元素脱离文档流，降低回流成本

为什么一再强调将css放在头部，将js文件放在尾部？

### DOMContentLoaded 和 load

- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片...
- load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成

### CSS 资源阻塞渲染

构建Render树需要DOM和CSSOM，所以HTML和CSS都会阻塞渲染。所以需要让CSS尽早加载（如：放在头部），以缩短首次渲染的时间。

### JS 资源

阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML。

这和之前文章提到的浏览器线程有关，浏览器中js引擎线程和渲染线程是互斥的，详见《从setTimeout-setInterval看JS线程》

普通的脚本会阻塞浏览器解析，加上defer或async属性，脚本就变成异步，可等到解析完毕再执行。

- async异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前后
- defer延迟执行，相对于放在body最后（理论上在DOMContentLoaded事件前）

举个栗子：

```html
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="style.css" rel="stylesheet">
</head>
<body>
  <p>Hello <span>web performance</span> students!</p>
  <div><img src="awesome-photo.jpg"></div>
  <script src="app.js"></script>
</body>
</html>
```

![x](./Resource/83.png)

- 浏览器拿到HTML后，从上到下顺序解析文档
- 此时遇到css、js外链，则同时发起请求
- 开始构建DOM树
- 这里要特别注意，由于有CSS资源，CSSOM还未构建前，会阻塞js（如果有的话）
- 无论JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒 JavaScript解析器，就会进行暂停 blocked 浏览器解析HTML，并等到 CSSOM 构建完毕，才执行js脚本
- 渲染首屏（DOMContentLoaded 触发，其实不一定是首屏，可能在js脚本执行前DOM树和CSSOM已经构建完render树，已经paint）

### 首屏优化Tips

说了这么多，其实可以总结几点浏览器首屏渲染优化的方向：

- 减少资源请求数量（内联亦或是延迟动态加载）
- 使CSS样式表尽早加载，减少@import的使用，因为需要解析完样式表中所有import的资源才会算CSS资源下载完
- 异步js：阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，导致首次渲染的时间延迟
- so on...

知道操作DOM成本多高了吗？其实写了这么多，感觉偏题了，大量的资料参考的是chrome开发者文档。

操作DOM具体的成本，说到底是造成浏览器回流reflow和重绘reflow，从而消耗GPU资源。

参考文献：

- [谷歌开发者文档](https://developers.google.com/web/fundamentals/performance/critical-rendering-path)

## 常用功能

```txt
网页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth （包括边线的宽）
网页可见区域高： document.body.offsetHeight （包括边线的宽）
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
屏幕可用工作区宽度：window.screen.availWidth;

scrollHeight: 获取对象的滚动高度。  
scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离
scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离
scrollWidth:获取对象的滚动宽度
offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度
offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置
offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置  
event.clientX 相对文档的水平座标
event.clientY 相对文档的垂直座标

event.offsetX 相对容器的水平坐标
event.offsetY 相对容器的垂直坐标  
document.documentElement.scrollTop 垂直方向滚动的值
event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量
要获取当前页面的滚动条纵坐标位置，用：
document.documentElement.scrollTop;
而不是：
document.body.scrollTop;
documentElement 对应的是 html 标签，而 body 对应的是 body 标签

事件源对象
event.srcElement.tagName
event.srcElement.type

捕获释放
event.srcElement.setCapture();  
event.srcElement.releaseCapture();  

事件按键
event.keyCode
event.shiftKey
event.altKey
event.ctrlKey

事件返回值
event.returnValue

鼠标位置
event.x
event.y

窗体活动元素
document.activeElement

绑定事件
document.captureEvents(Event.KEYDOWN);

访问窗体元素
document.all("txt").focus();
document.all("txt").select();

窗体命令
document.execCommand

窗体COOKIE
document.cookie

菜单事件
document.oncontextmenu

创建元素
document.createElement("SPAN");  

根据鼠标获得元素：
document.elementFromPoint(event.x,event.y).tagName=="TD"
document.elementFromPoint(event.x,event.y).appendChild(ms)  

窗体图片
document.images[索引]

窗体事件绑定
document.onmousedown=scrollwindow;

元素
document.窗体.elements[索引]

对象绑定事件
document.all.xxx.detachEvent('onclick',a);

插件数目
navigator.plugins

取变量类型
typeof($js_libpath) == "undefined"

下拉框
下拉框.options[索引]
下拉框.options.length

查找对象
document.getElementsByName("r1");
document.getElementById(id);

定时
timer=setInterval('scrollwindow()',delay);
clearInterval(timer);

UNCODE编码
escape() ,unescape

父对象
obj.parentElement(dhtml)
obj.parentNode(dom)

交换表的行
TableID.moveRow(2,1)

替换CSS
document.all.csss.href = "a.css";

并排显示
display:inline

隐藏焦点
hidefocus=true

根据宽度换行
style="word-break:break-all"

自动刷新
<meta HTTP-EQUIV="refresh" C>

简单邮件
<a href="mailto:aaa@bbb.com?subject=ccc&body=xxxyyy">  

快速转到位置
obj.scrollIntoView(true)

锚
<a name="first">
<a href="#first">anchors</a>

网页传递参数
location.search();

可编辑
obj.contenteditable=true

执行菜单命令
obj.execCommand

双字节字符
/[^\x00-\xff]/

汉字
/[\u4e00-\u9fa5]/

让英文字符串超出表格宽度自动换行
word-wrap: break-word; word-break: break-all;

透明背景
<IFRAME src="1.htm" width=300 height=180 allowtransparency></iframe>

获得style内容
obj.style.cssText

HTML标签
document.documentElement.innerHTML

第一个style标签
document.styleSheets[0]

style标签里的第一个样式
document.styleSheets[0].rules[0]

防止点击空链接时，页面往往重置到页首端。
<a href="javascript unction()">word</a>

上一网页源
asp:
request.servervariables("HTTP_REFERER")
javascript:
document.referrer

释放内存
CollectGarbage();

禁止右键
document.oncontextmenu = function() { return false;}

禁止保存
<noscript><iframe src="*.htm"></iframe></noscript>

禁止选取
<body oncontextmenu="return false" ondragstart="return false" onselectstart ="return false" onselect="document.selection.empty()" oncopy="document.selection.empty()" onbeforecopy="return false"onmouseup="document.selection.empty()">

禁止粘贴
<input type=text>

地址栏图标
<link rel="Shortcut Icon" href="favicon.ico">
favicon.ico 名字最好不变16*16的16色,放虚拟目录根目录下

收藏栏图标
<link rel="Bookmark" href="favicon.ico">

查看源码
<input type=button value=查看网页源代码>

关闭输入法
<input style="ime-mode isabled">

自动全选
<input type=text name=text1 value="123">

ENTER键可以让光标移到下一个输入框
<input >

文本框的默认值
<input type=text value="123">

title换行
obj.title = "123 sdfs"

获得时间所代表的微秒
var n1 = new Date("2004-10-10".replace(/-/g, "\/")).getTime()

窗口是否关闭
win.closed

checkbox扁平
<input type=checkbox style="position: absolute; clip:rect(5px 15px 15px 5px)"><br>

获取选中内容
document.selection.createRange().duplicate().text

自动完成功能

<input  type=text  autocomplete=on>打开该功能  
<input  type=text  autocomplete=off>关闭该功能
窗口最大化
<body >

无关闭按钮IE
window.open("aa.htm", "meizz", "fullscreen=7");

统一编码/解码
alert(decodeURIComponent(encodeURIComponent("http://你好.com?as= hehe")))
encodeURIComponent对":"、"/"、";" 和 "?"也编码
```

### 阻止冒泡和默认行为

```js
function stopBubble(e) {
  // 如果提供了事件对象，则这是一个非IE浏览器
  if (e && e.stopPropagation)
    //因此它支持W3C的stopPropagation()方法
    e.stopPropagation();
  else
    //否则，我们需要使用IE的方式来取消事件冒泡
    window.event.cancelBubble = true;
}

// 阻止浏览器的默认行为
function stopDefault( e ) {
  //阻止默认浏览器动作(W3C)
    if (e && e.preventDefault)
      e.preventDefault();
      // IE中阻止函数器默认动作的方式
    else
      window.event.returnValue = false;
    return false;
}
```



# 框架

1. [requirejs](#requirejs)
2. [Knockout](#Knockout)



## requirejs

参考：https://www.runoob.com/w3cnote/requirejs-tutorial-1.html

下载：[requirejs.org](http://requirejs.org/)

基本功能：模块化加载

index.html:

```html
<!DOCTYPE html>
<html>
    <head>
        <script type="text/javascript" src="require.js"></script>
        <script type="text/javascript">
            require(["a"]);
        </script>
    </head>
    <body>
      <span>body</span>
    </body>
</html>
```

a.js:

```js
define(function(){
    function fun1(){
      alert("it works");
    }
    fun1();
})
```

优点：

1. 防止js加载阻塞页面渲染
2. 使用程序调用的方式加载js，防出现如下丑陋的场景

```html
<script type="text/javascript" src="a.js"></script>
<script type="text/javascript" src="b.js"></script>
<script type="text/javascript" src="c.js"></script>
...
```



## Knockout

***Knockout.js是什么？***

Knockout是一个轻量级的UI类库，通过应用MVVM模式使JavaScript前端UI简单化。

MVVM是Model-View-ViewModel的简写。它本质上就是MVC的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图UI和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。

### 下载与安装

下载Knockout的最新版本，在正式开发和产品使用中，推荐使用默认的压缩版本（knockout.x.x.js）

下载地址：`http://knockoutjs.com/downloads/index.html`

对于调试使用，推荐使用完整的未压缩版本(knockout-x.x.debug.js)，压缩版和未压缩版功能相同，但是未压缩版本具有全变量名和注释，也没有隐藏内部的API，使得源代码更具可读性。

***插件***

Knockout也有丰富的插件可以使用，例如：

你可以使用集成JQueryUI功能的插件来实现autoComplete功能：

```html
<input type="text" data-bind="autocomplete: autocompleteConfig"/>
```

而没必要每次都要声明下面这样的代码：

```js
$( "#inputId" ).autocomplete({
source: availableTags
});
```

或者如果你想用表单验证功能，你可以使用验证插件:

```js
var myObj = ko.observable('').extend({ max: 99 });
```

或者

```js
<input type="text" data-bind="value: myProp" max="99"/>
```

而不是每次在点击提交按钮的时候或者离开焦点的时候都去检查。

结论：

使用Knockout将极大减少JavaScript的开发量，是需要使用简单的绑定语法就可以很快速地应用到你的站点上。

### 入门

Knockout有如下4大重要概念：

- 声明式绑定 (Declarative Bindings)：使用简明易读的语法很容易地将模型(model)数据关联到DOM元素上。
- UI界面自动刷新 (Automatic UI Refresh)：当您的模型状态(model state)改变时，您的UI界面将自动更新。
- 依赖跟踪 (Dependency Tracking)：为转变和联合数据，在你的模型数据之间隐式建立关系。
- 模板 (Templating)：为您的模型数据快速编写复杂的可嵌套的UI。

Knockout是一个以数据模型（data model）为基础的能够帮助你创建富文本，响应显示和编辑用户界面的JavaScript类库。任何时候如果你的UI需要自动更新（比如：更新依赖于用户的行为或者外部数据源的改变），KO能够很简单的帮你实现并且很容易维护。

重要特性:

- 优雅的依赖追踪- 不管任何时候你的数据模型更新，都会自动更新相应的内容。
- 声明式绑定- 浅显易懂的方式将你的用户界面指定部分关联到你的数据模型上。
- 灵活全面的模板- 使用嵌套模板可以构建复杂的动态界面。
- 轻易可扩展- 几行代码就可以实现自定义行为作为新的声明式绑定。

额外的好处：

- 纯JavaScript类库 – 兼容任何服务器端和客户端技术
- 可添加到Web程序最上部 – 不需要大的架构改变
- 简洁的 – Gzip之前大约25kb
- 兼容任何主流浏览器 (IE 6+、Firefox 2+、Chrome、Safari、其它)
- Comprehensive suite of specifications （采用行为驱动开发） - 意味着在新的浏览器和平台上可以很容易通过验证。

开发人员如果用过Silverlight或者WPF可能会知道KO是MVVM模式的一个例子。如果熟悉 Ruby on Rails 或其它MVC技术可能会发现它是一个带有声明式语法的MVC实时form。换句话说，你可以把KO当成通过编辑JSON数据来制作UI用户界面的一种方式… 不管它为你做什么

OK, 如何使用它？

简单来说：声明你的数据作为一个JavaScript 模型对象（model object），然后将DOM 元素或者模板（templates）绑定到它上面.

让我们来看一个例子

想想在一个页面上，航空旅客可以为他们的旅行升级高级食物套餐，当他们选择一个套餐的时候，页面立即显示套餐的描述和价格。首先，声明可用的套餐:

```js
var availableMeals = [
 { mealName: 'Standard', description: 'Dry crusts of bread', extraCost: 0 },
 { mealName: 'Premium', description: 'Fresh bread with cheese', extraCost: 9.95 },
 { mealName: 'Deluxe', description: 'Caviar and vintage Dr Pepper', extraCost: 18.50 }
];
```

如果想让这3个选项显示到页面上，我们可以绑定一个下拉菜单（例如：`<select>`元素）到这个数据上。例如：

```html
<h3>Meal upgrades</h3>
<p>Make your flight more bearable by selecting a meal to match your social and economic status.</p>
Chosen meal: <select data-bind="options: availableMeals,
                                optionsText: 'mealName'"></select>
```

启用Knockout并使你的绑定生效，在availableMeals变量声明之后添加如下代码：

```js
var viewModel = {
  /* we'll populate this in a moment */
};
ko.applyBindings(viewModel); // Makes Knockout get to work
// 注意：ko.applyBindings需要在上述HTML之后应用才有效
```

响应选择

下一步，声明一个简单的data model来描述旅客已经选择的套餐，添加一个属性到当前的view model上：

```js
var viewModel = {
  chosenMeal: ko.observable(availableMeals[0])
};
```

ko.observable是什么？它是KO里的一个基础概念。UI可以监控（observe）它的值并且回应它的变化。这里我们设置chosenMeal是UI可以监控已经选择的套餐，并初始化它，使用availableMeal里的第一个值作为它的默认值（例如：Standard）。

让我们将chosenMeal 关联到下拉菜单上，仅仅是更新`<select>`的data-bind属性，告诉它让`<select>`元素的值读取/写入chosenMeal这个模型属性：

```html
Chosen meal: <select data-bind="options: availableMeals,
                                    optionsText: 'mealName',
                                    value: chosenMeal"></select>
```

理论上说，我们现在可以读/写chosenMeal 属性了，但是我们不知道它的作用。让我们来显示已选择套餐的描述和价格：

```html
<p>
  You've chosen:
  <b data-bind="text: chosenMeal().description"></b>
  (price: <span data-bind='text: chosenMeal().extraCost'></span>)
</p>
```

于是，套餐信息和价格，将根据用户选择不同的套餐项而自动更新

更多关于observables和dependency tracking的使用

最后一件事：如果能将价格格式化成带有货币符号的就好了，声明一个JavaScript函数就可以实现了…

```js
function formatPrice(price) {
  return price == 0 ? "Free" : "$" + price.toFixed(2);
}
```

… 然后更新绑定信息使用这个函数 …

`(price: <span data-bind='text: formatPrice(chosenMeal().extraCost)'></span>)`

… 界面显示结果将变得好看多了

Price的格式化展示了，你可以在你的绑定里写任何JavaScript代码，KO仍然能探测到你的绑定依赖代码。这就展示了当你的model改变时，KO如何只进行局部更新而不用重新render整个页面 – 仅仅是有依赖值改变的那部分。

链式的observables也是支持的（例如：总价依赖于价格和数量）。当链改变的时候，依赖的下游部分将会重新执行，同时所有相关的UI将自动更新。不需要在各个observables之间声明关联关系，KO框架会在运行时自动执行的。

你可以从 observables 和 observable arrays 获取更多信息。上面的例子非常简单，没有覆盖很多KO的功能。你可以获取更多的内嵌的绑定和模板绑定。

KO和jQuery (或Prototype等)是竞争关系还是能一起使用？

所有人都喜欢jQuery! 它是一个在页面里操作元素和事件的框架，非常出色并且易使用，在DOM操作上肯定使用jQuery，KO解决不同的问题。

如果页面要求复杂，仅仅使用jQuery需要花费更多的代码。 例如：一个表格里显示一个列表，然后统计列表的数量，Add按钮在数据行TR小于5调的时候启用，否则就禁用。jQuery 没有基本的数据模型的概念，所以需要获取数据的数量（从table/div或者专门定义的CSS class），如果需要在某些SPAN里显示数据的数量，当添加新数据的时候，你还要记得更新这个SPAN的text。当然，你还要判断当总数>=5条的时候禁用Add按钮。 然后，如果还要实现Delete功能的时候，你不得不指出哪一个DOM元素被点击以后需要改变。

Knockout的实现有何不同？

使用KO非常简单。将你的数据描绘成一个JavaScript数组对象myItems，然后使用模板（template）转化这个数组到表格里（或者一组DIV）。不管什么时候数组改变，UI界面也会响应改变（不用指出如何插入新行`<tr>`或在哪里插入），剩余的工作就是同步了。例如：你可以声明绑定如下一个SPAN显示数据数量（可以放在页面的任何地方，不一定非要在template里）：

```html
There are <span data-bind="text: myItems().count"></span> items
```

就是这些！你不需要写代码去更新它，它的更新依赖于数组myItems的改变。同样，Add按钮的启用和禁用依赖于数组myItems的长度，如下：

```html
<button data-bind="enable: myItems().count < 5">Add</button>
```

之后，如果你要实现Delete功能，不必指出如何操作UI元素，只需要修改数据模型就可以了。

总结：KO没有和jQuery或类似的DOM 操作API对抗竞争。KO提供了一个关联数据模型和用户界面的高级功能。KO本身不依赖jQuery，但是你可以一起同时使用jQuery， 生动平缓的UI改变需要真正使用jQuery。

开启模板绑定

除非你想使用模板绑定功能（您很有可能使用它，因为非常有用），那你需要再引用两个JavaScript文件。 KO1.3版的默认模板引擎是依赖jQuery 的jquery.tmpl.js（最新版2.0版已经不依赖jquery tmp了）。所以你需要下载下面的2个文件并在引用KO之前引用：

- jQuery 1.4.2 或更高版本
- jquery-tmpl.js — 此版本 可以很容易使用，或者你访问官方网站 查找最新版本。

正确的引用顺序：

```html
<script type='text/javascript' src='jquery-1.4.2.min.js'></script>
<script type='text/javascript' src='jquery-tmpl.js'></script>
<script type='text/javascript' src='knockout-1.2.1.js'></script>
```

（当然，您要根据你的文件路径累更新上面的文件路径和文件名。）

监控属性(Observables)

关于Knockout的3个重要概念（Observables,DependentObservables,ObservableArray），暂定翻译为（监控属性、依赖监控属性和监控数组）。

1、创建带有监控属性的view model

Observables

Knockout是在下面三个核心功能上建立起来的：

1. 监控属性（Observables）和依赖跟踪（Dependency tracking）
2. 声明式绑定（Declarative bindings）
3. 模板（Templating）

在本节中，我们将学习3个核心里面的第一个。但在这之前，先让我们学习一下MVVM设计模式和View Model的概念。

MVVM and View Models

Model-View-View Model (MVVM)是一种创建用户界面的设计模式。通过它只要将UI界面分成以下3个部分，就可以使复杂的界面变得简单：

1、Model，用于存储你应用程序数据，这些数据表示你业务领域的对象和数据操作（例如：银行可以进行资金转账），并且独立于任何界面。当使用KO的时候，通常是使用Ajax向服务器请求数据来读写这个数据模型。用于存储你应用程序数据，这些数据表示你业务领域的对象和数据操作（例如：银行可以进行资金转账），并且独立于任何界面。当使用KO的时候，通常是使用Ajax向服务器请求数据来读写这个数据模型。

2、View Model，纯粹用于描述数据内容和页面操作的数据模型。例如，如果你想实现一个列表编辑器，你的ViewModel（数据模型）就是项目清单对象和你所暴露出来的添加和删除列表项的方法。 注意：这不是UI本身，它不具有任何按钮和显示样式的概念。这不是持久化的数据模型—它仅是用户当前使用的未保存的数据。当使用KO时，你的View Model（数据模型）是纯粹的不包含HTML知识的JavaScript对象，保持View Model（数据模型）抽象在使用时可以保持简单，因此你可以更简单的操作管理更复杂的行为。

3、View，代表View Model状态的一个可见、互动的UI界面。它主要用于显示View Model的数据信息、发送用户命令（例如，当用户点击按钮）以及在View Model发生变化时保持自动更新。

使用KO时，你的View层主要就是简单的将HTML文档声明式的绑定到View Model，将它们关联起来。另外，你也可以利用模版从View Model获取数据动态生成HTML。

使用KO创建一个View Model，仅仅只需要声明一个JavaScript对象，例如：

```js
var myViewModel = {
  personName: 'Colin',
  personAge: 15
};
```

你可以创建一个简单的视图声明式绑定到这个View Model上，例如，下面的代码显示personName的值：

```html
The name is <span data-bind="text: personName"></span>
```

激活Knockout

data-bind属性尽快好用但它不是HTML的原生属性（它严格遵从HTML5语法，虽然HTML4验证器提示有不可识别的属性但依然可用）。由于浏览器不识别它是什么意思，所以你需要激活Knockout 来让他起作用。

激活Knockout，需要添加如下的 `<script>` 代码块：

ko.applyBindings(myViewModel);

你可以将这个代码块放在HTML底部，或者放在jQuery的$函数或者ready 函数里

你可能奇怪ko.applyBindings使用的是什么样的参数：

第一个参数是你想激活KO时用于声明式绑定的View Model对象；

第二个参数（可选），你可以使用第二个参数来设置要使用data-bind属性的HTML元素或容器。例如：

```js
ko.applyBindings(myViewModel, document.getElementById('someElementId'))
```

它限制了只有ID为someElementId的元素才能激活使用KO功能，当你在一个页面中声明了多个View Model来绑定不同的界面区域时，这样限制是很有好处的。

Observables

现在已经知道如何创建一个简单的view model并且通过binding显示它的属性了。但是KO一个重要的功能是当你的view model改变的时候能自动更新你的界面。当你的view model部分改变的时候KO是如何知道的呢？答案是：你需要将你的model属性声明成observable的, 因为它是非常特殊的JavaScript objects，能够通知订阅者它的改变以及自动探测到相关的依赖。

例如：重写上述例子中的View Model为以下代码：

```js
var myViewModel = {
  personName: ko.observable('Colin'),
  personAge: ko.observable('15')
};
```

你根本不需要对View进行更改，所有的data-bind语法依然正常工作。所不同的是，现在它能够自动检测变化，并通知它自动更新界面View。

Reading and writing observables

并不是所有的浏览器都支持JavaScript的getters and setters (比如IE)，所以，为了兼容，ko.observable监控的对象都是方法。

1、读取当前监控的属性值，只需要直接调用observable（不需要参数），在这个例子当中，调用myViewModel.personName()将会返回'Colin'，调用myViewModel.personAge() 将会返回'15'

2、写一个新值到监控属性上，调用observable方法，将要写的值作为一个参数传入即可。例如，调用myViewModel.personName('Mary') 将会把名称改变成 'Mary'。

3、一次性改变Model对象监控的多个属性值，你可以使用链式方法。例如：myViewModel.personName('Mary').personAge(50) 将会把名称改变成'Mary'将年龄设置为50

监控属性最重要的一点就是可以随时监控，也就是说，其他代码可以告诉它哪些是需要通知发生变化的。这就是为什么KO会有如此多的内置绑定语法。所以，当你在页面中编写data-bind="text: personName"，text 会绑定注册到自身，当personName发生变化时，它能够立即得到通知。

当你通过调用 myViewModel.personName('Mary') 将名称的值改变成为'Mary'时，text绑定会自动更新新值到其对应的DOM对象元素上，这就是为什么改变数据模型能够自动刷新View页面。

监控属性的显示订阅

通常情况下，你不需要手工订阅，如果你想要注册自己的订阅来通知监控属性的变化，你可以使用subscribe 方法。例如：

```js
myViewModel.personName.subscribe(function (newValue) {
  alert("The person's new name is " + newValue);
});
```

subscribe 方法在KO内部很多地方都有用到。你也可以终止自己的订阅：首先获取到这个订阅，然后调用dispose 方法即可。例如：

```js
var subscription = myViewModel.personName.subscribe(function (newValue) {
  alert("The person's new name is " + newValue);
});
// ...then later...
subscription.dispose(); // I no longer want notifications
```

大多数时间，你不需要这么做，因为内置的绑定和模版系统功能在管理订阅上已经做了很多工作，可以直接使用它们。

2、使用依赖监控属性(Dependent Observables)

如果你已经有了监控属性firstName和lastName，你想显示全称怎么办？ 这就需要用到依赖监控属性了 – 这些函数是一个或多个监控属性， 如果他们的依赖对象改变，他们会自动跟着改变。

例如，下面的view model,

```js
var viewModel = {
  firstName: ko.observable('Bob'),
  lastName: ko.observable('Smith')
};
```

… 你可以添加一个依赖监控属性来返回姓名全称：

```js
viewModel.fullName = ko.dependentObservable(function () {
  return this.firstName() + " " + this.lastName();
}, viewModel);
```

并且绑定到UI的元素上，例如：

```html
The name is <span data-bind="text: fullName"></span>
```

… 不管firstName还是lastName改变，全称fullName都会自动更新（不管谁改变，执行函数都会调用一次，不管改变成什么，他的值都会更新到UI或者其他依赖监控属性上）。

管理'this'

你可能疑惑ko.dependentObservable的第二个参数是做什么用的（上面的例子中我传的是viewModel）, 它是声明执行依赖监控属性的this用的。 没有它，你不能引用到this.firstName() 和this.lastName()。 老练的JavaScript 开发人员不觉得this怎么样，但是如果你不熟悉JavaScript，那就对它就会很陌生。(C#和Java不需要为set一个值为设置this，但是JavaScript 需要，因为默认情况下他们的函数自身不是任何对象的一部分)。

不幸的是，JavaScript对象没有任何办法能引用他们自身，所以你需要通过myViewModelObject.myDependentObservable = ... 的形式添加依赖监控属性到view model对象上。你不能直接在view model里声明他们，换句话说，你不能写成下面这样：

```js
var viewModel = {
    myDependentObservable: ko.dependentObservable(function() {
        ...
    }, /* can't refer to viewModel from here, so this doesn't work */)
}
```

… 相反你必须写成如下这样：

```js
var viewModel = {
    // Add other properties here as you wish
};

viewModel.myDependentObservable = ko.dependentObservable(function() {
    ...
}, viewModel); // This is OK
```

只要你知道期望什么，它确实不是个问题。

依赖链

理所当然，如果你想你可以创建一个依赖监控属性的链。例如：

- 监控属性items表述一组列表项

- 监控属性selectedIndexes保存着被用户选上的列表项的索引

- 依赖监控属性selectedItems 返回的是selectedIndexes 对应的列表项数组

- 另一个依赖监控属性返回的true或false依赖于 selectedItems 的各个列表项是否包含一些属性（例如，是否新的或者还未保存的）。一些UI element（像按钮的启用/禁用）的状态取决于这个值）。

  然后，items或者selectedIndexes 的改变将会影响到所有依赖监控属性的链，所有绑定这些属性的UI元素都会自动更新。多么整齐与优雅！

可写的依赖监控属性

可写依赖监控属性真的是太advanced了，而且大部分情况下都用不到。

正如所学到的，依赖监控属性是通过计算其它的监控属性而得到的。感觉是依赖监控属性正常情况下应该是只读的。那么，有可能让依赖监控属性支持可写么？你只需要声明自己的callback函数然后利用写入的值再处理一下相应的逻辑即可。

你可以像使用普通的监控属性一样使用依赖监控属性 – 数据双向绑定到DOM元素上，并且通过自定义的逻辑拦截所有的读和写操作。这是非常牛逼的特性并且可以在大范围内使用。

例1：分解用户的输入

返回到经典的"first name + last name = full name" 例子上，你可以让事情调回来看: 让依赖监控属性fullName可写，让用户直接输入姓名全称，然后输入的值将被解析并映射写入到基本的监控属性firstName和lastName上：

```js
var viewModel = {
    firstName: ko.observable("Planet"),
    lastName: ko.observable("Earth")
};

viewModel.fullName = ko.dependentObservable({
    read: function () {
        return this.firstName() + " " + this.lastName();
    },
    write: function (value) {
        var lastSpacePos = value.lastIndexOf(" ");
        if (lastSpacePos > 0) { // Ignore values with no space character
            this.firstName(value.substring(0, lastSpacePos)); // Update "firstName"
            this.lastName(value.substring(lastSpacePos + 1)); // Update "lastName"
        }
    },
    owner: viewModel
});
```

这个例子里，写操作的callback接受写入的值，把值分离出来，分别写入到"firstName"和"lastName"上。 你可以像普通情况一样将这个view model绑定到DOM元素上，如下：

```html
<p>First name: <span data-bind="text: firstName"></span></p>
<p>Last name: <span data-bind="text: lastName"></span></p>
<h2>Hello, <input data-bind="value: fullName"/>!</h2>
```

这是一个Hello World 例子的反例子，姓和名都不可编辑，相反姓和名组成的姓名全称却是可编辑的。
上面的view model演示的是通过一个简单的参数来初始化依赖监控属性。你可以给下面的属性传入任何JavaScript对象：

- read — 必选，一个用来执行取得依赖监控属性当前值的函数。
- write — 可选，如果声明将使你的依赖监控属性可写，别的代码如果这个可写功能写入新值，通过自定义逻辑将值再写入各个基础的监控属性上。
- owner — 可选，如果声明，它就是KO调用read或write的callback时用到的this。查看“管理this”获取更新信息。

例2：Value转换器

有时候你可能需要显示一些不同格式的数据，从基础的数据转化成显示格式。比如，你存储价格为float类型，但是允许用户编辑的字段需要支持货币单位和小数点。你可以用可写的依赖监控属性来实现，然后解析传入的数据到基本 float类型里：

```js
viewModel.formattedPrice = ko.dependentObservable({

    read: function () {
        return "$" + this.price().toFixed(2);
    },

    write: function (value) {
        // Strip out unwanted characters, parse as float, then write the raw data back to the underlying "price" observable
        value = parseFloat(value.replace(/[^\.\d]/g, ""));
        this.price(isNaN(value) ? 0 : value); // Write to underlying storage
    },
    owner: viewModel
});
```

然后我们绑定formattedPrice到text box上:

```html
<p>Enter bid price: <input data-bind="value: formattedPrice"/></p>
```

所以，不管用户什么时候输入新价格，输入什么格式，text box里会自动更新为带有2位小数点和货币符号的数值。这样用户可以看到你的程序有多聪明，来告诉用户只能输入2位小数，否则的话自动删除多余的位数，当然也不能输入负数，因为write的callback函数会自动删除负号。

例3：过滤并验证用户输入

例1展示的是写操作过滤的功能，如果你写的值不符合条件的话将不会被写入，忽略所有不包括空格的值。

再多走一步，你可以声明一个监控属性isValid 来表示最后一次写入是否合法，然后根据真假值显示相应的提示信息。稍后仔细介绍，先参考如下代码：

```js
var viewModel = {
    acceptedNumericValue: ko.observable(123),
    lastInputWasValid: ko.observable(true)
};

viewModel.attemptedValue = ko.dependentObservable({
    read: viewModel.acceptedNumericValue,
    write: function (value) {
        if (isNaN(value))
            this.lastInputWasValid(false);
        else {
            this.lastInputWasValid(true);
            this.acceptedNumericValue(value); // Write to underlying storage
        }
    },
    owner: viewModel
});
```

… 按照如下格式声明绑定元素：

```html
<p>Enter a numeric value: <input data-bind="value: attemptedValue"/></p>
<div data-bind="visible: !lastInputWasValid()">That's not a number!</div>
```

现在，acceptedNumericValue 将只接受数字，其它任何输入的值都会触发显示验证信息，而会更新acceptedNumericValue。

备注：上面的例子显得杀伤力太强了，更简单的方式是在`<input>`上使用jQuery Validation和number class。Knockout可以和jQuery Validation一起很好的使用，参考例子：grid editor 。当然，上面的例子依然展示了一个如何使用自定义逻辑进行过滤和验证数据，如果验证很复杂而jQuery Validation很难使用的话，你就可以用它。

依赖跟踪如何工作的

为什么依赖监控属性能够自动跟踪并且自动更新UI…

事实上，非常简单，甚至说可爱。跟踪的逻辑是这样的：

1. 当你声明一个依赖监控属性的时候，KO会立即调用执行函数并且获取初始化值。
2. 当你的执行函数运行的时候，KO会把所有需要依赖的依赖属性（或者监控依赖属性）都记录到一个Log列表里。
3. 执行函数结束以后，KO会向所有Log里需要依赖到的对象进行订阅。订阅的callback函数是重新运行你的执行函数。然后回头重新执行上面的第一步操作（并且注销不再使用的订阅）。
4. 最后KO会通知上游所有订阅它的订阅者，告诉它们我已经设置了新值。

所有说，KO不仅仅是在第一次执行函数执行时候探测你的依赖项，每次它都会探测。举例来说，你的依赖属性可以是动态的：依赖属性A代表你是否依赖于依赖属性B或者C，这时候只有当A或者你当前的选择B或者C改变的时候执行函数才重新执行。你不需要再声明其它的依赖：运行时会自动探测到的。

另外一个技巧是：一个模板输出的绑定是依赖监控属性的简单实现，如果模板读取一个监控属性的值，那模板绑定就会自动变成依赖监控属性依赖于那个监控属性，监控属性一旦改变，模板绑定的依赖监控属性就会自动执行。嵌套的模板也是自动的：如果模板X render模板 Y，并且Y需要显示监控属性Z的值，当Z改变的时候，由于只有Y依赖它，所以只有Y这部分进行了重新绘制（render）。

3、使用observable数组

如果你要探测和响应一个对象的变化，你应该用observables。如果你需要探测和响应一个集合对象的变化，你应该用observableArray 。在很多场景下，它都非常有用，比如你要在UI上需要显示/编辑的一个列表数据集合，然后对集合进行添加和删除。

```js
var myObservableArray = ko.observableArray();    // Initially an empty array
myObservableArray.push('Some value');            // Adds the value and notifies observers
```

关键点：监控数组跟踪的是数组里的对象，而不是这些对象自身的状态。

简单说，将一对象放在observableArray 里不会使这个对象本身的属性变化可监控的。当然你自己也可以声明这个对象的属性为observable的，但它就成了一个依赖监控对象了。一个observableArray 仅仅监控他拥有的对象，并在这些对象添加或者删除的时候发出通知。

预加载一个监控数组observableArray

如果你想让你的监控数组在开始的时候就有一些初始值，那么在声明的时候，你可以在构造器里加入这些初始对象。例如：

```js
// This observable array initially contains three objects
var anotherObservableArray = ko.observableArray([
    { name: "Bungle", type: "Bear" },
    { name: "George", type: "Hippo" },
    { name: "Zippy", type: "Unknown" }
]);
```

从observableArray里读取信息

一个observableArray其实就是一个observable的监控对象，只不过他的值是一个数组（observableArray还加了很多其他特性，稍后介绍）。所以你可以像获取普通的observable的值一样，只需要调用无参函数就可以获取自身的值了。 例如，你可以像下面这样获取它的值：

```js
alert('The length of the array is ' + myObservableArray().length);
alert('The first element is ' + myObservableArray()[0]);
```

理论上你可以使用任何原生的JavaScript数组函数来操作这些数组，但是KO提供了更好的功能等价函数，他们非常有用是因为：

1. 兼容所有浏览器。（例如indexOf不能在IE8和早期版本上使用，但KO自己的indexOf 可以在所有浏览器上使用）
2. 在数组操作函数方面（例如push和splice），KO自己的方式可以自动触发依赖跟踪，并且通知所有的订阅者它的变化，然后让UI界面也相应的自动更新。
3. 语法更方便，调用KO的push方法，只需要这样写：myObservableArray.push(...)。 比如原生数组的myObservableArray().push(...)好用多了。

下面讲解的均是observableArray的读取和写入的相关函数。

indexOf

indexOf 函数返回的是第一个等于你参数数组项的索引。例如：myObservableArray.indexOf('Blah')将返回以0为第一个索引的第一个等于Blah的数组项的索引。如果没有找到相等的，将返回-1。

slice

slice函数是observableArray相对于JavaScript原生函数slice的等价函数（返回给定的从开始索引到结束索引之间所有的对象集合）。 调用myObservableArray.slice(...)等价于调用JavaScript原生函数（例如：myObservableArray().slice(...)）。

操作observableArray

observableArray 展现的是数组对象相似的函数并通知订阅者的功能。

pop, push, shift, unshift, reverse, sort, splice

所有这些函数都是和JavaScript数组原生函数等价的，唯一不同的数组改变可以通知订阅者：

```js
myObservableArray.push('Some new value') 在数组末尾添加一个新项
myObservableArray.pop() 删除数组最后一个项并返回该项
myObservableArray.unshift('Some new value') 在数组头部添加一个项
myObservableArray.shift() 删除数组头部第一项并返回该项
myObservableArray.reverse() 翻转整个数组的顺序
myObservableArray.sort() 给数组排序
```

默认情况下，是按照字符排序（如果是字符）或者数字排序（如果是数字）。

你可以排序传入一个排序函数进行排序，该排序函数需要接受2个参数（代表该数组里需要比较的项），如果第一个项小于第二个项，返回-1，大于则返回1，等于返回0。例如：用lastname给person排序，你可以这样写：

```js
myObservableArray.sort (function (left, right) {return left.lastName == right.lastName? 0: (left.lastName < right.lastName? -1: 1) })
myObservableArray.splice() 删除指定开始索引和指定数目的数组对象元素。例如myObservableArray.splice(1, 3) 从索引1开始删除3个元素（第2,3,4个元素）然后将这些元素作为一个数组对象返回。
```

更多observableArray 函数的信息，请参考等价的JavaScript数组标准函数。

remove和removeAll

observableArray 添加了一些JavaScript数组默认没有但非常有用的函数：

```js
myObservableArray.remove(someItem) //删除所有等于someItem的元素并将被删除元素作为一个数组返回
myObservableArray.remove(function(item) { return item.age < 18 }) //删除所有age属性小于18的元素并将被删除元素作为一个数组返回
myObservableArray.removeAll(['Chad', 132, undefined]) //删除所有等于'Chad', 123, or undefined的元素并将被删除元素作为一个数组返回
```

destroy和destroyAll（注：通常只和和Ruby on Rails开发者有关)

destroy和destroyAll函数是为Ruby on Rails开发者方便使用为开发的：

```js
myObservableArray.destroy(someItem) //找出所有等于someItem的元素并给他们添加一个属性_destroy，并赋值为true
myObservableArray.destroy(function(someItem) { return someItem.age < 18 }) //找出所有age属性小于18的元素并给他们添加一个属性_destroy，并赋值为true
myObservableArray.destroyAll(['Chad', 132, undefined]) //找出所有等于'Chad', 123, 或undefined 的元素并给他们添加一个属性_destroy，并赋值为true
```

那么，_destroy是做什么用的？正如我提到的，这只是为Rails 开发者准备的。在Rails 开发过程中，如果你传入一个JSON对象，Rails 框架会自动转换成ActiveRecord对象并且保存到数据库。Rails 框架知道哪些对象以及在数据库中存在，哪些需要添加或更新， 标记_destroy为true就是告诉框架删除这条记录。

注意的是：在KO render一个foreach模板的时候，会自动隐藏带有_destroy属性并且值为true的元素。所以如果你的"delete"按钮调用destroy(someItem) 方法的话，UI界面上的相对应的元素将自动隐藏，然后等你提交这个JSON对象到Rails上的时候，这个元素项将从数据库删除（同时其它的元素项将正常的插入或者更新）。

## 参考

`http://www.aizhengli.com/knockoutjs/52/knockout-viewmodels-observables.html`
`http://www.cnblogs.com/TomXu/archive/2011/11/21/2257154.html`



# 总结

1. 常用功能
   - [call和apply](#call和apply)
   - [编码和解码](#编码和解码)
   - [base64转file](#base64转file)
   - [pdf处理](#pdf处理)
   - [canvas](#canvas)
   - [异步](#异步)
   - [原生js实现新语法](#原生js实现新语法)
2. 常用错误
3. [前端架构](#前端架构)
4. [参考](#参考)



## 常用功能



### call和apply

情形：

我们知道，`Array.prototype.slice.call(arguments)` 能将具有 length 属性的对象转成数组，除了 IE 下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换）。如：

```js
var a = { length: 2, 0: 'first', 1: 'second' };
Array.prototype.slice.call(a); // ["first", "second"]
  
var a = { length: 2 };
Array.prototype.slice.call(a); // [undefined, undefined]
```

分析：

首先，slice有两个用法，一个是`String.slice`，一个是`Array.slice`，第一个返回的是字符串，第二个返回的是数组，这里我们看第2个。

```js
Array.prototype.slice.call(arguments) 
// 能够将arguments转成数组，那么就是arguments.toArray().slice();
// 到这里，是不是就可以说Array.prototype.slice.call(arguments)的过程就是先将传入进来的第一个参数转为数组，再调用slice？
```

再看call的用法，如下例子

```js
var a = function(){
  console.log(this);  // 'littledu'
  console.log(typeof this);  //  Object
  console.log(this instanceof String);  // true
}
a.call('littledu');
```

可以看出，call了后，就把当前函数推入所传参数的作用域中去了，不知道这样说对不对，但反正this就指向了所传进去的对象。

到这里，基本就差不多了，我们可以大胆猜一下slice的内部实现，如下

```js
Array.prototype.slice = function(start, end) {
  var result = new Array();
  start = start || 0;
  end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键
  for(var i = start; i < end; i++){
    result.push(this[i]);
  }
  return result;
}
```

最后，附个转成数组的通用函数

```js
var toArray = function(s){
  try{
    return Array.prototype.slice.call(s);
  } catch(e){
    var arr = [];
    for(var i = 0,len = s.length; i < len; i++){
      //arr.push(s[i]);
      arr[i] = s[i];  //据说这样比push快
    }
    return arr;
  }
}
```

call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在 `定义时上下文` 和 `运行时上下文` 以及 `上下文是可以改变的` 这样的概念。

二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：

```js
var func1 = function(arg1, arg2) {};
```

就可以通过 `func1.call(this, arg1, arg2);` 或者 `func1.apply(this, [arg1, arg2]);` 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象（JavaScript 中一切皆对象），call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。

JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call；而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。

要先明白存在call和apply的原因，才能记得牢一点：

在javascript OOP中，我们经常会这样定义：

```js
function cat(){
}
cat.prototype={
  food:"fish",
  say: function(){
    alert("I love "+this.food);
  }
}
var blackCat = new cat;
blackCat.say();
```

但是如果我们有一个对象`whiteDog = {food:"bone"}`，我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 blackCat 的 say 方法：`blackCat.say.call(whiteDog);`

所以，可以看出call和apply是为了动态改变 `this` 而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。

用的比较多的，通过 `document.getElementsByTagName` 选择的 dom 节点是一种类似 array 的 array。它不能应用 Array 下的 `push`, `pop` 等方法。我们可以通过：

```js
var domNodes = Array.prototype.slice.call(document.getElementsByTagName("*"));

```

这样domNodes就可以应用Array下的所有方法了。

如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj

Global: 全局属性和函数可用于所有内建的 JavaScript 对象。

你需要明白 IIFE 的原理，我简单说一下：

```js
// 这是定义，Declaration；定义只是让解释器知道其存在，但是不会运行。
function foo() {...}
// 这是语句，Statement；解释器遇到语句是会运行它的。
foo();
```

IIFE 并非必须，那么为什么要 IIFE？

1. 传统的方法啰嗦，定义和执行分开写；
2. 传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window）

于是，开发者们想找一个可以解决以上问题的写法。那么像下面这么写行不行呢？

```js
function foo(...){}();
```

当然是不能，但是为什么呢？因为 `function foo(...){}` 这个部分只是一个声明，对于解释器来说，就好像你写了一个字符串 "function foo(...){}"，它需要使用解析函数，比如 eval() 来执行它才可以。所以把 () 直接放在声明后面是不会执行，这是错误的语法。

如何把它变得正确？说起来也简单，只要把 `声明` 变成 `表达式(Expression)` 就可以了。

实际上转变表达式的办法还是很多的，最常见的办法是把函数声明用一对 () 包裹起来，于是就变成了：

```js
(function foo() {...})();
```

这就等价于：

```js
var foo = function () {...}; // 这就不是定义，而是表达式了。
foo();
```

但是之前我们说不行的那个写法，其实也可以直接用括号包起来，这也是一种等价的表达式：

```js
(function foo(){...}());
```

所以你问有没有区别？很简单：木有～另外，刚才说过转变表达式的方式很多，的确还有很多别的写法，比如：

```js
!function foo() {...}();
```

或者

```js
+function foo() {...}();
```

这些都可以。我个人挺偏爱用 void 来转变表达式，因为此关键字不会有返回值。不过这一点真的没有什么要紧的……

```js
void function () {
  // 这里是真正需要的代码
}();
```

OK，所谓不去污染全局命名空间，是因为 IIFE 创建了一个新的`函数作用域`，你真正的业务代码被封装在其中，自然就不会触碰到全局对象了。如果你需要全局对象，那就 pass 给 IIFE：

```js
void function (global) {
  // 在这里，global 就是全局对象了
}(this) // 在浏览器里，this 就是 window 对象
```





### 编码和解码

encodeURI、encodeURIComponent、decodeURI、decodeURIComponent

1、用来编码和解码URI的

统一资源标识符，或叫做 URI，是用来标识互联网上的资源（例如，网页或文件）和怎样访问这些资源的传输协议（例如，HTTP 或 FTP）的字符串。除了encodeURI、encodeURIComponent、decodeURI、decodeURIComponent四个用来编码和解码 URI 的函数之外 ECMAScript 语言自身不提供任何使用 URL 的支持。

2、URI组成形式

一个 URI 是由组件分隔符分割的组件序列组成。其一般形式是：

Scheme : First / Second ; Third ? Fourth

其中的名字代表组件；":"  "/"  ";"  "?" 是当作分隔符的保留字符。

3、有何不同？

encodeURI 和 decodeURI 函数操作的是完整的 URI；这俩函数假定 URI 中的任何保留字符都有特殊意义，所有不会编码它们。

encodeURIComponent 和 decodeURIComponent 函数操作的是组成 URI 的个别组件；这俩函数假定任何保留字符都代表普通文本，所以必须编码它们，所以它们（保留字符）出现在一个完整 URI 的组件里面时不会被解释成保留字符了。

4、四个函数的不同：

一个URI可能包含以下5种类型的字符

1) 保留字符： ;/?:@&=+$,
2) 非转义字符：字母、数字、URI标记符 [-_.!~*'()]
3) '#'
4) 其它：
5) 被转义字符：16进制字符，"%xx"

encodeURI: 4)

encodeURIComponent: 1), 3), 4)

### content="IE=edge,chrome=1"详解

`<meta http-equiv = "X-UA-Compatible" content = "IE=edge,chrome=1" />`

这个是IE8的专用标记，用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式(比如人见人烦的IE6)，以此来解决部分兼容问题，例如模拟IE7的具体方式如下：

`<meta http-equiv = "X-UA-Compatible" content = "IE=EmulateIE7" />`

但令我好奇的是，此处这个标记后面竟然出现了chrome这样的值，难道IE也可以模拟chrome了？

迅速搜索了一下，才明白原来不是微软增强了IE，而是谷歌做了个外挂：Google Chrome Frame(谷歌内嵌浏览器框架GCF)。这个插件可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器，谷歌这个墙角挖的真给力！

而上文提到的那个meta标记，则是在是安装了GCF后，用来指定页面使用chrome内核来渲染。

GCF下载地址：`http://code.google.com/intl/zh-CN/chrome/chromeframe/`

安装完成后，如果你想对某个页面使用GCF进行渲染，只需要在该页面的地址前加上 gcf： 即可，例如：`gcf:http://cooleep.com`

但是如果想要在开发时指定页面默认首先使用GCF进行渲染，如果未安装GCF再使用IE内核进行渲染，该如何进行呢？

就是使用这个标记。

标记用法：

阅读了下chrome的开发文档(`http://www.chromium.org/developers/how-tos/chrome-frame-getting-started`，需翻墙)，下面来简单讲解一下这个标记的语法。

1.最基本的用法：在页面的头部加入

`<meta http-equiv = "X-UA-Compatible" content = "chrome=1">`

用以声明当前页面用chrome内核来渲染。

复杂一些的就是本文一开始看到的那中用法：

`<meta http-equiv = "X-UA-Compatible" content = "IE=edge,chrome=1" />`

这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果为安装GCF，则使用最高版本的IE内核进行渲染。

2.通过修改HTTP头文件的方法来实现让指定的页面使用GCF内核进行渲染：

在HTTP的头文件中加入以下信息：X-UA-Compatible: chrome=1

在Apache服务器中，确保 mod_headers 和 mod_setenvif文件可用，然后在httpd.conf中加入以下配置信息：

```conf
<IfModule mod_setenvif.c>
<IfModule mod_headers.c>

BrowserMatch chromeframe gcf
Header append X-UA-Compatible "chrome=1" env=gcf
```

在IIS7或者更高版本的服务器中，只需要修改web.config文件，添加如下信息即可即可:

```config
<configuration>
  <system.webServer>
    <httpProtocol>
      <customHeaders>
        <add name = "X-UA-Compatible" value = "chrome=1" />
      </customHeaders>
    </httpProtocol>
  </system.webServer>
</configuration>
```

### 中文乱码问题

归纳以下几点：

1. html文件是有编码格式的，这个在特定的编辑器中才能看出来，并进行设置。
2. html文件中头部的"content-type"中设置的"charset"是告诉浏览器打开该文件的编码方式。
3. 一般1、2点中的编码方式应该一致，不一致可能出现乱码。
4. 如果浏览器中显示乱码，但是页面源文件不是乱码，可以通过修改浏览器的编码方式看到正确的中文，如果在源文件中设置了正确的"charset"，就不需要修改浏览器的编码方式了。

### 对象获取

**[object Object]怎么获取？**

```js
var temp = "";
for(var i in obj) { //用javascript的for/in循环遍历对象的属性
  if(i.indexOf("Repeater1")>=0) {
    temp+=i+":"+obj[i]+"\n";
  }
}
alert(temp);
```

js中想根据动态key得到某对象中相对应的value的方法有二：
一、var key = "name1";var value = obj[key];
二、var key = "name1";var value = eval("obj."+key);

### 节点的兄弟，父级，子级元素

先说一下JS的获取方法，其要比JQUERY的方法麻烦很多，后面以JQUERY的方法作对比。

JS的方法会比JQUERY麻烦很多，主要则是因为FF浏览器，FF浏览器会把你的换行也当最DOM元素

```html
<div id="test">
  <div></div>
  <div></div>
</div>
```

原生的JS获取ID为test的元素下的子元素。可以用：

```js
var a = docuemnt.getElementById("test").getElementsByTagName("div"); // 这样是没有问题的
```

此时a.length=2；

但是如果我们换另一种方法

```js
var b = document.getElementById("test").childNodes;  
```

此时b.length 在IE浏览器中没问题，其依旧等于2，但是在FF浏览器中则会使4，是因为FF把换行也当做一个元素了。所以，在此，我们就要做处理了，需遍历这些元素，把元素类型为空格而且是文本都删除。

```js
function del_ff(elem) {
  var elem_child = elem.childNodes;
  for(var i=0; i<elem_child.length; i++) {
    if(elem_child[i].nodeName == "#text" && !/\s/.test(elem_child.nodeValue)){
      elem.removeChild(elem_child)
    }
  }
}
```

上述函数遍历子元素，当元素里面有节点类型是文本并且文本类型节点的节点值是空的。就把他删除。

nodeNames可以得到一个节点的节点类型，/\s/是非空字符在JS里的正则表达式。前面加！,则表示是空字符

test() 方法用于检测一个字符串是否匹配某个模式.语法是：RegExpObject.test(string)

如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。

nodeValue表示得到这个节点里的值。

removeChild则是删除元素的子元素。

之后，在调用子，父，兄，这些属性之前，调用上面的函数把空格清理一下就可以了

```html
<div id="test">
  <div></div>
  <div></div>
</div>
<script>
  function dom() {
    var s= document.getElementById("test");
    del_ff(s); // 清理空格
    var chils= s.childNodes; // 得到s的全部子节点
    var par=s.parentNode; // 得到s的父节点
    var ns=s.nextSbiling; // 获得s的下一个兄弟节点
    var ps=s.previousSbiling; // 得到s的上一个兄弟节点
    var fc=s.firstChild; // 获得s的第一个子节点
    var lc=s.lastChile; // 获得s的最后一个子节点
  }
</script>
```

下面介绍JQUERY的父，子，兄弟节点查找方法

- jQuery.parent(expr)  找父亲节点，可以传入expr进行过滤，比如$("span").parent()或者$("span").parent(".class")
- jQuery.parents(expr),类似于jQuery.parent(expr),但是是查找所有祖先元素，不限于父元素
- jQuery.children(expr).返回所有子节点，这个方法只会返回直接的孩子节点，不会返回所有的子孙节点
- jQuery.contents(),返回下面的所有内容，包括节点和文本。这个方法和children()的区别就在于，包括空白文本，也会被作为一个jQuery对象返回，children()则只会返回节点
- jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点
- jQuery.prevAll()，返回所有之前的兄弟节点
- jQuery.next(),返回下一个兄弟节点，不是所有的兄弟节点
- jQuery.nextAll()，返回所有之后的兄弟节点
- jQuery.siblings(),返回兄弟姐妹节点，不分前后
- jQuery.find(expr),跟jQuery.filter(expr)完全不一样。jQuery.filter()是从初始的jQuery对象集合中筛选出一部分，而jQuery.find()的返回结果，不会有初始集合中的内容，比如$("p"),find("span"),是从<p>元素开始找<span>,等同于$("p span")

```html
<noscript>
  <iframe src="*.htm"></iframe>
</noscript>
```

前面应该还有一段js代码。noscript元素用来定义在脚本未被执行时的替代内容（文本）。此标签可被用于可识别`<script>`标签但无法支持其中的脚本的浏览器。此段代码意思为如果浏览器不支持script的代码，则会显示嵌入的那个页面的内容。

### opener、parent、top

opener即谁打开我的，比如A页面利用window.open弹出了B页面窗口，那么A页面所在窗口就是B页面的opener，在B页面通过opener对象可以访问A页面。

parent表示父窗口，比如一个A页面利用iframe或frame调用B页面，那么A页面所在窗口就是B页面的parent。

top是parent的特殊情况，表示顶层窗口。

在JS 中，window.opener只是对弹出窗口的母窗口的一个引用。比如：a.html中，通过点击按钮等方式window.open出一个新的窗口 b.html。那么在b.html中，就可以通过window.opener（省略写为opener）来引用a.html，包括a.html的 document等对象，操作a.html的内容。

假如这个引用失败，那么将返回null。所以在调用opener的对象前，要先判断对象是否为null，否则会出现“对象为空或者不存在”的JS错误。

### table设置问题

设置table的Width

设置td的Width

如果用百分比，td的宽度有时候会有问题，用绝对值，显示就正常了，当然，先满足table宽度，再根据td宽度值按比例分配

table边框问题，一般在设置边框宽度时光增加border=1显示出来的边界并不是我们希望的那样，因为在各个边框之间还存在着间距，可以如下设置

```html
<table cellpadding="0" cellspacing="0" border=1>
```

### table固定宽度

table-layout:fixed 属性的解说

如果想要一个table固定大小，里面的文字强制换行(尤其是在一长串英文文本，并且中间无空格分隔的情况下)，以达到使过长的文字不撑破表格的目的，一般是使用样式：table-layout:fixed。但是在Firefox下面，会有一些问题，参考 Gmail的一些做法，做了几个测试，得出一种解决办法。

例1：(IE浏览器)普通的情况，CODE:

```html
<table border=1 width=80>
  <tr>
    <td>abcdefghigklmnopqrstuvwxyz 1234567890</td>
  </tr>
</table>
```

效果：可以看到width=80并没有起作用，表格被字符撑开了。

例2：(IE浏览器)使用样式 `table-layout:fixed`，CODE:

```html
<style>
  .tbl {
    table-layout:fixed
  }
</style>
<table class=tbl border=1 width=80>
  <tr>
    <td>abcdefghigklmnopqrstuvwxyz 1234567890</td>
  </tr>
</table>
```

效果：width=80起作用了，但是表格换行了。

例3：(IE浏览器)使用样式table-layout:fixed与nowrap，CODE:

```html
<style>
  .tbl {
    table-layout:fixed
  }
</style>
<table class=tbl border=1 width=80>
  <tr>
    <td nowrap>abcdefghigklmnopqrstuvwxyz 1234567890</td>
  </tr>
</table>
```

效果：width=80起作用了，换行也被干掉了。

例4：(IE浏览器)在使用数值固定td大小情况下使用样式table-layout:fixed与nowrap，CODE:

```html
<style>
  .tbl {
    table-layout:fixed
  }
</style>
<table class=tbl border=1 width=80>
  <tr>
    <td width=20 nowrap>abcdefghigklmnopqrstuvwxyz 1234567890</td>
    <td nowrap>abcdefghigklmnopqrstuvwxyz 1234567890</td>
  </tr>
</table>
```

效果：不幸发生了，第一个td的nowrap不起作用了

例5：(IE浏览器)在使用百分比固定td大小情况下使用样式table-layout:fixed与nowrap，CODE:

```html
<style>
  .tbl {
    table-layout:fixed
  }
</style>
<table class=tbl border=1 width=80>
  <tr>
    <td width=25% nowrap>abcdefghigklmnopqrstuvwxyz 1234567890</td>
    <td nowrap>abcdefghigklmnopqrstuvwxyz 1234567890</td>
  </tr>
</table>
```

效果：改成百分比，终于搞定了

例6：(Firefox浏览器)在使用百分比固定td大小情况下使用样式table-layout:fixed与nowrap 效果：把例5放到firefox下面，又ft了

例7：(Firefox浏览器)在使用百分比固定td大小情况下使用样式table-layout:fixed与nowrap,并且使用div，CODE:

```html
<style>
  .tbl {
    table-layout:fixed
  }
  .td {
    overflow:hidden;
  }
</style>
<table class=tbl border=1 width=80>
  <tr>
    <td width=25% class=td nowrap>
      <div>abcdefghigklmnopqrstuvwxyz 1234567890</div>
    </td>
    <td class=td nowrap>
      <div>abcdefghigklmnopqrstuvwxyz 1234567890</div>
    </td>
  </tr>
</table>
```

效果：天下终于太平了

例8：(Firefox浏览器)在使用数值固定td大小情况下使用样式table-layout:fixed与nowrap,并且使用div，CODE:

```html
<style>
  .tbl {
    table-layout:fixed
  }
  .td {
    overflow:hidden;
  }
</style>
<table class=tbl border=1 width=80>
  <tr>
    <td width=20 class=td nowrap>
      <div>abcdefghigklmnopqrstuvwxyz 1234567890</div>
    </td>
    <td class=td nowrap>
      <div>abcdefghigklmnopqrstuvwxyz 1234567890</div>
    </td>
  </tr>
</table>
```

效果： nowrap又不起作用了

但是使用它在不同浏览器中又会出现问题，显示效果整齐了，确显示内容被覆盖了，这又怎样解决呢，我又开始了搜索，可以强制换行，却又导致有的单词被分家了连不起来，后来有在表单格式中加了一句word-wrap:break-word，详细内容如下：word-wrap是控制换行的。

使用break-word时，是将强制换行。中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。break-word是控制是否断词的。normal是默认情况，英文单词不被拆开。break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。keep-all，是指Chinese, Japanese, and Korean不断词。即只用此时，不用word-wrap，中文就不会换行了。（英文语句正常。）

ie下：使用word-wrap:break-word;所有的都正常。

ff下：如这2个都不用的话，中文不会出任何问题。英文语句也不会出问题。但是，长串英文会出问题。

为了解决长串英文，一般用word-wrap:break-word;word-break:break-all;。但是，此方式会导致普通的英文语句中的单词会被断开（ie下也是）。

目前主要的问题存在于长串英文和英文单词被断开。其实长串英文就是一个比较长的单词而已。

即英文单词应不应该被断开那？那问题很明显了，显然不应该被断开了。

对于长串英文，就是恶意的东西，自然不用去管了。但是，也要想些办法，不让它把容器撑大。

用：overflow:auto; ie下，长串会自动折行。ff下，长串会被遮盖。

所以，综上，最好的方式是word-wrap:break-word;overflow:hidden;而不是word-wrap:break-word;word-break:break-all;。

word-wrap:break-word;overflow:auto;在ie下没有任何问题。在ff下，长串会被遮住部分内容。加这句话   style="word-wrap:break-word;table-layout: fixed;"，上面的问题就解决了。希望对大家有意!!!!!

table-layout  版本：CSS2　兼容性：IE5+　继承性：无

语法：table-layout : auto | fixed

取值：

- auto: 默认值。默认的自动算法。布局将基于各单元格的内容。表格在每一单元格内所有内容读取计算之后才会显示出来
- fixed: 固定布局的算法。在这种算法中，表格和列的宽度取决于 col 对象的宽度总和，假如没有指定，则会取决于第一行每个单元格的宽度。假如表格没有指定宽度( width )属性，则表格被呈递的默认宽度为 100% 。

说明：

设置或检索表格的布局算法。

你可以通过此属性改善表格呈递性能。此属性导致IE以一次一行的方式呈递表格内容从而提供给信息用户更快的速度。此属性依据此下顺序使用其中一种方式布置表格栏宽度：

使用 col 或 colGroup 对象的宽度( width )属性信息。

使用表格第一行内的单元格的宽度( width )信息。

依据表格列数等分表格宽度。而不考虑表格内容的实际宽度。

假如单元格的内容超过了列宽度，内容将会被换行。假如无法换行，则内容会被裁切。假如此属性被设置为 fixed ，则 overflow 能够被用于控制处理溢出单元格( td )宽度的内容。假如表格行高度被指定了，那么换行的内容如果超出了指定表格行高度也会在纵向上被裁切。

设置此属性值为 fixed ，有助于提高表格性能。对于长表格效果尤其显著。

设置表格行高可以进一步提高呈递速度，浏览器不需要检测行内每一个单元格内容去确定行高就可以开始解析以及呈递。

此属性对于 currentStyle 对象而言是只读的。对于其他对象而言是可读写的。

对应的脚本特性为 tableLayout。

```html
<!--固定表格的宽度，超出部分用...代替-->
<style>
table {
  font-size:small;
  text-align:left;
  table-layout:fixed;
  margin: 0px;
  border-style: solid;
  border-color:Black;
  border-collapse: collapse;
  border-spacing: 0px;
}
td {
  border:solid 1pxblack;
  overflow:hidden;
  white-space:nowrap;
  text-overflow:ellipsis;
}
</style>
<colgroup>
  <colwidth="65px"/>
  <colwidth="141px"/>
  <colwidth="60px"/>
  <colwidth="101px"/>
  <colwidth="52px"/>
  <colwidth="70px"/>
  <colwidth="59px"/>
  <colwidth="56px"/>
  <colwidth="56px"/>
  <colwidth="56px"/>
  <colwidth="56px"/>
  <colwidth="56px"/>
  <colwidth="56px"/>
  <colwidth="56px"/>
  <colwidth="42px"/>
  <colwidth="60px"/>
  <colwidth="50px"/>
  <colwidth="40px"/>
  <colwidth="20px"/>
  <colwidth="20px"/>
  <colwidth="20px"/>
</colgroup>
```

### 隐藏显示div

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <title>Test</title>
    <script type="text/javascript">
        function selectCond(id) {
            if (id == "" || id == null) {
                if (document.all['tab'].style.display == "") {
                    document.all['tab'].style.display = "none";
                    return;
                }
                document.all['tab'].style.display = "";
            } else {
                if (document.all['tab' + id].style.display == "") {
                    document.all['tab' + id].style.display = "none";
                    return;
                }
                document.all['tab' + id].style.display = "";
            }
        }
    </script>
</head>
<body>
    <fieldset>
        <legend>
            <span onclick="selectCond();">
                <span>请点击</span>
            </span>
        </legend>
        <div id="tab" style="display: none">
            这就是隐藏的内容！o(∩_∩)o 哈哈
        </div>
    </fieldset>
</body>
</html>
```

### 让div自动适应内容的高度

我们看下面的代码：

```html
<div id="main">
  <div id="content"></div>
</div>
```

当Content内容多时，即使main设置了高度100%或auto。在不同浏览器下还是不能完好的自动伸展。内容的高度比较高了，但容器main的高度还是不能撑开。

我们可以通过三种方法 来解决这个问题。

1.增加一个清除浮动，让父容器知道高度。请注意，清除浮动的容器中有一个空格。

```html
<div id="main">
  <div id="content"></div>
  <div style="font:0px/0px sans-serif;clear:both;display:block">空格</div>
</div>
```

2.增加一个容器，在代码中存在，但在视觉中不可见。

```html
<div id="main">
  <div id="content"></div>
  <div style="height:1px;margin-top:-1px;clear:both;overflow:hidden;"></div>
</div>
```

3.增加一个BR并设置样式为clear:both。

```html
<div id="main">
  <div id="content"></div>
  <br style="clear:both;"/>
</div>
```







### base64转file

```js
// 1. 将base64转换为文件（IOS不兼容）
dataURLtoFile: function(dataurl, filename) { 
  var arr = dataurl.split(','),
	    mime = arr[0].match(/:(.*?);/)[1],
	    bstr = atob(arr[1]),
	    n = bstr.length,
	    u8arr = new Uint8Array(n);
  while (n--) {
	  u8arr[n] = bstr.charCodeAt(n);
	}
	return new File([u8arr], filename, { type: mime });
},
// 调用
var file = dataURLtoFile(base64Data, imgName);

// 2. 先将base64转换成blob，再将blob转换成file文件（此方法基本都兼容）
// 将base64转换为blob
dataURLtoBlob: function(dataurl) { 
  var arr = dataurl.split(','),
      mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]),
      n = bstr.length,
      u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
},
// 将blob转换为file
blobToFile: function(theBlob, fileName){
  theBlob.lastModifiedDate = new Date();
  theBlob.name = fileName;
  return theBlob;
},
// 调用
var blob = dataURLtoBlob(base64Data);
var file = blobToFile(blob, imgName);
```



### pdf处理

参考：

1. https://github.com/goSunadeod/vue-pdf.js-demo/blob/master/src/components/HelloWorld.vue
2. https://www.cnblogs.com/usebtf/p/10329977.html
3. https://www.jianshu.com/p/df5f9726cbbf
4. https://blog.csdn.net/prey1025/article/details/90029284



### canvas

参考：https://www.cnblogs.com/jarson-7426/p/6231767.html

```js
// 获取canvas容器
var can = document.getElementById('canvas');
// 创建一个画布
var ctx = can.getContext('2d');

// 绘制圆形
// 参数解释：x,y-圆心；start-起始角度；end-结束角度；color-绘制颜色；type-绘制类型（'fill'和'stroke'）。
var draw = function(x, y, r, start, end, color, type) {
    var unit = Math.PI / 180;
    ctx.beginPath();
    ctx.arc(x, y, r, start * unit, end * unit);
    ctx[type + 'Style'] = color;
    ctx.closePath();
    ctx[type]();
}

// 绘制三角形
// 参数解释：x1(2、3),y1(2、3)-三角形的三个点的坐标；color-绘制颜色；type-绘制类型（'fill'和'stroke'）。
var draw = function(x1, y1, x2, y2, x3, y3, color, type) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx[type + 'Style'] = color;
    ctx.closePath();
    ctx[type]();
}

// 绘制（圆角）矩形
// 参数解释：x,y-左上角点的坐标；width、height-宽高；radius-圆角；color-绘制颜色；type-绘制类型（'fill'和'stroke'）。
var draw = function(x, y, width, height, radius, color, type){
    ctx.beginPath();
    ctx.moveTo(x, y+radius);
    ctx.lineTo(x, y+height-radius);
    ctx.quadraticCurveTo(x, y+height, x+radius, y+height);
    ctx.lineTo(x+width-radius, y+height);
    ctx.quadraticCurveTo(x+width, y+height, x+width, y+height-radius);
    ctx.lineTo(x+width, y+radius);
    ctx.quadraticCurveTo(x+width, y, x+width-radius, y);
    ctx.lineTo(x+radius, y);
    ctx.quadraticCurveTo(x, y, x, y+radius);
    ctx[type + 'Style'] = color || params.color;
    ctx.closePath();
    ctx[type]();
}

/**
 * 绘制多边形
 * 参数说明：
 *   ctx: canvas画布
 *   conf: 配置项，提供以下一些配置
 *   x： 中心点横坐标
 *   y： 中心点纵坐标
 *   num: 多边形的边数
 *   r：多边形的半径长度
 *   width：多边形线的宽度
 *   strokeStyle：边线的颜色
 *   fillStyle：填充的颜色
 */
var drawPolygon = function(ctx, conf){
    var x = conf && conf.x || 0;  //中心点x坐标
    var y = conf && conf.y || 0;  //中心点y坐标
    var num = conf && conf.num || 3;   //图形边的个数
    var r = conf && conf.r || 100;   //图形的半径
    var width = conf && conf.width || 5;
    var strokeStyle = conf && conf.strokeStyle;
    var fillStyle = conf && conf.fillStyle;
    //开始路径
    ctx.beginPath();
    var startX = x + r * Math.cos(2*Math.PI*0/num);
    var startY = y + r * Math.sin(2*Math.PI*0/num);
    ctx.moveTo(startX, startY);
    for(var i = 1; i <= num; i++) {
        var newX = x + r * Math.cos(2*Math.PI*i/num);
        var newY = y + r * Math.sin(2*Math.PI*i/num);
        ctx.lineTo(newX, newY);
    }
    ctx.closePath();
    //路径闭合
    if(strokeStyle) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = width;
        ctx.lineJoin = 'round';
        ctx.stroke();
    }
    if(fillStyle) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
    }
}

// 图1的代码：
drawPolygon(ctx, {
    num: 6,
    r: 100,
    strokeStyle: 'blue',
    fillStyle: '#9da'
})
// 图2的代码：
drawPolygon(ctx, {
    num: 4,
    r: 150,
    strokeStyle: 'red',
    width: 4
})
// 图3的代码：
drawPolygon(ctx, {
    x: 800,
    y: 250,
    num: 10,
    fillStyle: '#000'
})
```

使用canvas绘制图形就是那几个函数：`beginPath`、`arc`、`moveTo`、`lineTo`、`closePath`、`fill`、`stroke`。当我们能够熟练掌握并运用自如的时候，就能够独当一面了。



### 异步

参考：https://blog.csdn.net/qq_36174666/article/details/106353457?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param

JavaScript是单线程执行的，无法同时执行多段代码。当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列。一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 “阻塞式执行”。

所以一次鼠标点击，或是计时器到达时间点，或是Ajax请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。

假如当前 JavaScript 线程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。

如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。

#### 1. 回调函数

```js
function f1 (callback) {
  console.log('f1');
  setTimeout(function () {
    // f1的任务代码
    callback();
  }, 1000);
}
function f2 () {
  console.log('f2');
}
```

回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合(Coupling)，流程会很混乱，而且每个任务只能指定一个回调函数。

**回调地狱**

在书写JavaScript的时候，我经常不得不去处理一些依赖于其它任务的任务！比如说我们想要得到一个图片，对其进行压缩，应用一个滤镜，然后保存它 。

我们最先需要做的事情是得到我们想要编辑的图片。getImage函数可以处理这个问题！一旦图片被成功加载，我们可以传递那个值到一个resizeImage函数。当图片已经被成功地重新调整大小时，我们想要在applyFilter函数中为图片应用一个滤镜。在图片被压缩和添加滤镜后，我们想要保存图片并且让用户知道所有的事情都正确地完成了！

最后，我们可能得到这样的结果:

```js
getImage('./image.png', (image, err) => {
  if (err) throw new Error(err)
  compressImage(image, (compressedImage, err) => {
    if (err) throw new Error(err)
    applyFilter(compressedImage, (filteredImage, err) => {
      if (err) throw new Error(err)
      saveImage(filteredImage, (res, err) => {
        if (err) throw new Error(err)
        console.log("Successfully saved image!")
      })
    })
  })
})
```

尽管它完成了事情，但是完成的并不是很好。我们最终得到了许多嵌套的回调函数，这些回调函数依赖于前一个回调函数。这通常被称为回调地狱，由于我们最终得到了大量嵌套的回调函数，这使我们的代码阅读起来特别困难。

幸运的是，我们有Promise来帮助我们摆脱困境

#### 2. 事件监听

```js
f1.on('done', f2);
function f1 () {
  setTimeout(function () {
    // f1的任务代码
    f1.trigger('done');
  }, 1000);
}
```

任务的执行不取决于代码的顺序，而取决于某个事件是否发生。还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。

`f1.trigger('done')`表示，执行完成后，立即触发done事件，从而开始执行f2。

这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”(Decoupling)，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。

#### 3. 发布/订阅

```js
jQuery.subscribe("done", f2);
function f1 () {
  setTimeout(function () {
    // f1的任务代码
    jQuery.publish("done");
  }, 1000);
}
jQuery.unsubscribe("done", f2); // f2完成后可以取消订阅
```

上一节的“事件”，完全可以理解成“信号”。

我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”(publish)一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”(publish-subscribe pattern），又称“观察者模式”(observer pattern)。

这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。

首先，f2向“信号中心”jQuery订阅"done"信号。

然后，改写f1，`jQuery.publish("done")` 的意思是，f1执行完成后，向“信号中心”jQuery发布 "done" 信号，从而引发f2的执行。

此外，f2完成执行后，也可以取消订阅(unsubscribe)。

这种方法的性质与“事件监听”类似，但是明显优于后者。因为我们可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

#### 4. Promises对象

```js
function f1 () {
  var dfd = $.Deferred();
  setTimeout(function () {
    // f1的任务代码
    dfd.resolve();
  }, 500);
  return dfd.promise;
}
f1().then(f2);
f1().then(f2).then(f3); // 指定多个回调函数
f1().then(f2).fail(f3); // 指定发生错误时的回调函数
```

Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。

f1要进行改写（这里使用的是jQuery的实现）。这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。

Promise是一个对象，它包含一个状态[[PromiseStatus]]和一个值[[PromiseValue]]。你永远不会与这个对象进行交互，你甚至不能访问[[PromiseStatus]]和[[PromiseValue]]这俩个属性！但是在使用Promise的时候，这两个属性值是非常重要的。

**PromiseStatus**

PromiseStatus的值，也就是Promise的状态，可以是以下三个值之一：

- ✅ fulfilled: promise已经被resolved。一切都很好，在promise内部没有错误发生。
- ❌rejected: promise已经被rejected。哎呦，某些事情出错了。
- ⏳pending: promise暂时还没有被解决也没有被拒绝，仍然处于pending状态

但是什么时候promise的状态是pending、fulfilled或rejected呢? 为什么这个状态很重要呢？

Promise构造器的回调函数接受两个参数，第一个参数的值经常被叫做resolve或res,它是一个函数， 在Promise应该解决(resolve)的时候会被调用。第二个参数的值经常被叫做reject或rej,它也是一个函数，在Promise出现一些错误应该被拒绝(reject)的时候被调用。

```js
new Promise((res, rej) => res("Yay!"))
new Promise((res, rej) => rej("Aww no!"))
```

> chrome Promise resolved的状态不是fulfilled，而是 resolved(上图是chrome下的截图)，实际上这是Chrome的一个bug,目前已经在Canary中修复了

**PromiseValue**

promise的值，即[[PromiseValue]]的值，是我们作为参数传递给resolve或reject方法的值

现在我们知道如何更好控制Promise对象。但是他被用来做什么呢？

我们用Promise重写上面的图片示例

```js
function getImage(file) {
  return new Promise((res, rej) => {
    try {
      const data = readFile(file)
      res(data) // 如果图片加载完成且一切正常，用加载完的图片解决(resolve)promise
    } catch(err) {
      rej(new Error(err)) // 果在加载文件时某个地方有一个错误，我们将会用发生的错误拒绝(reject)promise
    }
  })
}

getImage(file)
  .then(image => console.log(image))
  .then(compressedImage => applyFilter(compressedImage)) // 添加滤镜
  .then(filteredImage => saveImage(filteredImage))// 保存图片
  .catch(error => console.log(error))
  .finally(() => console.log("All done!"))
```

对于一个promise, 我们可以使用它上面的3个方法：

- .then(): 在一个promise被resolved后调用
- .catch(): 在一个promise被rejected后被调用
- .finally(): 不论promise是被resolved还是reject总是调用

**事件循环**

JavaScript是单线程(single-threaded): 同时只能做一个任务，在任务期间，任何其它事情发生都默认运行在浏览器的主线程上。幸运的是，浏览器给我们一些JavaScript引擎它自己没有提供的特性：WeB API。它包括DOM API、setTimeout、HTTP请求等内容。这能帮助我们创建一些异步、非阻塞的行为。

当我们调用一个函数的时候，它会被添加到一个叫做调用栈的东西中。调用栈不是浏览器特有的，而是JS引擎的一部分。它是栈意味着它是先进后出（想想一堆煎饼）。当函数返回一个值的时候，它会被弹出栈。

可视化效果请前往链接https://blog.csdn.net/qq_36174666/article/details/106347322

在事件循环内部，实际上有2种类型的队列：宏任务(macro)队列(或者只是叫做任务队列)和微任务队列。(宏)任务队列用于宏任务，微任务队列用于微任务。

那么什么是宏任务，什么是微任务呢？

| (Macro)task                           | Microtask                                          |
| ------------------------------------- | -------------------------------------------------- |
| setTimeout, setInterval, setImmediate | process.nextTick, Promise callback, queueMicrotask |

当一个Promise解决(resolve)并且调用它的then()、catch()或finally()方法的时候，这些方法里的回调函数被添加到微任务队列！这意味着then(),chatch()或finally()方法内的回调函数不是立即被执行，本质上是为我们的JavaScript代码添加了一些异步行为！

那么什么时候执行then(),catch(),或finally()内的回调呢？

事件循环给与任务的优先级：

1. 当前在调用栈(call stack)内的所有函数会被执行，当它们返回值的时候，会被从栈内弹出

2. 当调用栈是空的时，所有排队的微任务会一个接一个从微任务任务队列中弹出进入调用栈中，然后在调用栈中被执行！(微任务自己也能返回一个新的微任务，有效地创建无限的微任务循环 ) 

3. 如果调用栈和微任务队列都是空的，事件循环会检查宏任务队列里是否还有任务。如果宏任务中还有任务，会从宏任务队列中弹出进入调用栈，被执行后会从调用栈中弹出！

举个栗子：

Task1: 立即被添加到调用栈中的函数，比如在我们的代码中立即调用它。

Task2,Task3,Task4: 微任务，比如promise中then方法里的回调

Task5,Task6: 宏任务，比如setTimeout或者setImmediate里的回调

![x](D:\WorkingDir\Office\Resources\tbms0050.gif)

首先，Task1返回一个值并且从调用栈中弹出。然后，JavaScript引擎检查微任务队列中排队的任务。一旦微任务中所有的任务被放入调用栈并且最终被弹出，JavaScript引擎会检查宏任务队列中的任务，将他们弹入调用栈中并且在它们返回值的时候把它们弹出调用栈。

附上代码，可以自行测试

```js
console.log('Start!')
 
setTimeout(() => {
  console.log('Timeout!')
}, 0)
 
Promise.resolve('Promise!').then(res => console.log(res))
 
console.log('End!')

// 输出
// Start！
// End！
// Promise!
// Timeout!
```

#### 5. Async/Await

ES7引入了一个新的在JavaScript中添加异步行为的方式并且使promise用起来更加简单！随着async和await关键字的引入，我们能够创建一个隐式的返回一个promise的async函数。但是，我们该怎么做呢？

 之前，我们看到不管是通过输入new Promise(() => {}),Promise.resolve或Promise.reject，我们都可以显式的使用Promise对象创建promise。

我们现在能够创建隐式地返回一个对象的异步函数，而不是显式地使用Promise对象！这意味着我们不再需要写任何Promise对象了。

下面两段代码是等价的

```js
Promise.resolve('Hello!')
 
async function great(){
  return 'Hello!'
}
```

尽管async函数隐式的返回promise是一个非常棒的事实，但是在使用await关键字的时候才能看到async函数的真正力量

 当我们等待await后的值返回一个resolved的promise时，通过await关键字，我们可以暂停异步函数。如果我们想要得到这个resolved的promise的值，就像我们之前用then回调那样，我们可以为被await的promise的值赋值为变量！

 这个暂停（把异步变为同步）是什么意思呢？看看下面这段代码的输出顺序

```js
const one = () => Promise.resolve('One!')
 
async function myFunc(){
  const res = await one()
  console.log(res)
}
 
console.log('Before function!')
myFunc()
console.log('After function!')

// 输出
// Before function!
// After function!
// One!
```

因为遇到了await关键字，异步函数myFunc被暂停， **JavaScript引擎跳出异步函数，并且在异步函数被调用的执行上下文中继续执行代码（而不是阻塞）**：在这个例子中是全局执行上下文！

最终，没有更多的任务在全局执行上下文中运行！事件循环检查看看是否有任何的微任务在排队：是的，有！在解决了one的值以后，异步函数myFunc开始排队。myFunc被弹入调用栈中，在它之前中断的地方继续运行。

变量res最终获得了它的值，也就是one返回的promise被解决的值！我们用res的值（在这个例子中是字符串"One!"）调用console.log。"One!"被打印到控制台并且console.log从调用栈弹出。



### 原生js实现新语法

```js
// 类数组转为数组
// 参考：https://www.cnblogs.com/wskb/p/11088209.html
// 第一种：es5 call or apply
var array = Array.prototype.slice.call(arrayLike);
// 第二种：es6
var array = Array.from(arguemtns);

// forEach()方法
if(!Array.prototype.forEach) {
    Array.prototype.forEach = function(fn, context) {
        var context = arguments[1];
        if(typeof fn !== "function") {
            throw new TypeError(fn + "is not a function");
        }
        for(var i = 0; i < this.length; i++) {
            // forEach三个参数：item, index, Array
            fn.call(context, this[i], i, this);
        }
    };
}
```



## 前端架构

**1. 统帅全军**

首先你的人格不能分裂，别人的意见你要能听得进去，别人可能会觉得不合理或者什么意见，你要能虚心的接受，而且能从中去改变一些东西，这是你必须要做的，你的架构需要得到所有人的认可，如果没有你这个架构就失败了，有一句话叫做：不能为了架构而架构，而是为了适配业务适配人。举了一个 地图 项目的案例从开始的使用 PHP 到后来的为了团队选择了 NodeJS，所以说统帅全局需要的是综合素质的自我修养，要有软素质和硬能力

**2. 消息通讯**

在我们平时进行开发的时候，大家需要注意的是 消息通讯 的机制，比如说有一种设计模式叫做 [观察者--示例来自汤姆大叔](https://link.jianshu.com?t=https://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html)，可以监听到别人触发回来的这样一个事件，比如说： a b 两个人，a 做了一件事情，他把这件事情做好之后需要告诉 b，那个 b 要得到这个消息，你要能编写这种消息传递的组件然后来促进整个团队在开发的时候进行这样的融合；再举个例子：做地图的定位，定位成功了，那么需要定位的其他组件能监听到这个定位成功，你怎么去释放呢？用最简单的方法 jquery 里面的三个函数 [on](https://link.jianshu.com?t=http://www.runoob.com/jquery/event-on.html) 、[trigger](https://link.jianshu.com?t=http://www.w3school.com.cn/jquery/event_trigger.asp) 、[off](https://link.jianshu.com?t=http://www.runoob.com/jquery/event-off.html) 这三个函数就能组成一个非常经典的事件监听器，具体的可以查看上面的 观察者 链接

**3. 插件随组**

就是说将整个项目以插件化的形式来生成，比如说：index.html 里面的内容就可以是 render 的其他一些模块的内容，可以随意地去组合，也可以随意地去替换，这样可以将业务更好的扩展

**4. 本地可调**

有一个比较专业的名词叫做 mock data （模拟数据），以前的时候我们前端调试代码就要装一堆像 .NET 开发需要的 VS IIS 等等需要启动服务的东西，会特别的繁琐，现在 NodeJS 启个 server 就非常的方便了，用 webpack 、koa、express 等等都可以了，做前端需要做的是前端方面的容错机制、接口规范，这样可以有很好地用户体验

**5. 多端方案**

现在的一个方案如果说随着你业务的扩充，一定让你现在所织构的框架能够去容纳多端，就是你开发的组件是可以随意地发布到 Android 、 iOS 甚至是其他硬件（电视）端，所以当你选择这个技术框架的时候，你一定要为了这种多端去准备，现在有好多技术都可以支持跨端，比方说： NW ，它可以让我们的 JS 跨 PC 端，所以一定要为这个做好准备，假设有一天你的客户端突然需要一个同样的组件，这样就可以直接拿来用，不用再重新去写了，你要能把这些东西快速的发布成一个小的 SDK（软件开发工具包），这样是作为一个前端架构师的准备工作，把这个发布成一个小的 SDK 就需要有一定的编程基础了 比如说： Java 。

 如果上述的 5 条你都考虑到了，就算是一个比较优秀的工程师了

**6. 代码分模**

主要就是模块化，在早期的模块化有很多的处理方案，比如说：CJS（commonJS）、RequireJS （JavaScript 文件和模块的加载器）等等，那么现在的分模呢，已经到了 ES6、import、万物皆模块、webpack 这种的时代了，你要做的就是把这些东西分清，这些模块是怎么组合的，比如说：你一个 css、js、html 组成了一个模块，这样也是一个分模的方法；把所有的 js 组合到一块，也是一种分模的方法；但是一定要注意这些东西得有一个非常详细的模块划分，你需要画出一张图告诉你的老大 你的这些代码预计上线之后将来扩充所有模块该是什么样的，那么你的老大也会清晰的知道你的能力

**7. 雅虎军规**

这个是面试里必问的问题，所有的网站、所有的做这种前端构建的时候为的是什么呢 为的就是，其中一个是编译：让代码写的更爽，还有一个就是让这个产品别人用起来更爽，所以呢 雅虎军规的目的就是让代码上线之后更爽，说白了为了性能的，所有的雅虎军规都是为了性能而生的，比如说：把 html 中的 js 文件放到 body 里面怎么怎么的，这就是雅虎军规里第一条非常简单的，就是你要了解整个网页，整个雅虎军规有将近二三十条，那么你做这样一个前端工具的时候如果没有遵循到雅虎军规，比如说：你用 webpack 把所有的 js 文件都编译了，然后你会发现所有的 script 都把页面给堵住了，那你这个架构就没有人会去认可，因为上线之后性能非常差，所以在做这样的前端架构的时候一定要去考虑到雅虎军规，如果你没考虑到这个那么前面 6 条你做的基本上就是废掉的，所以这个是非常重要的

**8. 工业为先**

这个意思就是说：少去做你人肉的去操作，比如说：一般的 html 上线之前要压缩，那么有很多的压缩方式，你可以上百度去搜索 html 压缩 把 html 复制过去然后压缩，压缩好了在复制回来，这样一个就好了，但是这只是一个，如果是成百上千个肯定不可能再人肉去操作了，所以一定要有一些工程化的东西，为什么会有 Grunt、Gulp 这样的东西呢，实质上它们帮助我们做了这些工业的事，工业化的前端就是说，它像一条流水线一样，把我们这些东西塞进去然后产出一些东西，那么这就是工业为先，一定要注意前端的架构要保持这种工业为先的理念，如果说你没有很好地去利用到当前你手头的编译工具而是发现很多东西自己在手动的去做那么这个架构也是失败的

**9. 持续可扩**

我们都知道因为这个产品变化的节奏很快，那么一定要注意哪些东西要有这种长远的打算，不能说这个文件夹先这样吧、把这个文件夹先扔这吧怎么怎么样的，你一定要有长远的考虑，像是这个组件可以扩展、还有一些公用的文件全都提出去，早早地做打算才能让你这个架构越来越并发，否则就造成了在国内软件开发非常严重的问题--重构，你们会经常发现项目被重构了，为什么呢，就是因为之前的很多东西没有想好，没有做好这种持续可扩的准备，那么在持续可扩的技术之前呢，也要做一个非常重要的东西就是 技术选型，那么这个技术选型一定要具有一定的前沿性，就比如说：你现在的项目用 ES6，过两年可能浏览器就普遍了，现在我们用 babel 编译，将来呢就不需要 babel 编译，可以直接扔到线上了，这个就是持续可扩一个非常经典的例子

**10. 一键部署**

这个需要去了解运维，之前也了解过像 LVS（Linux虚拟服务器）、Keep-Alive 等等这些的东西，因为将来你要把你这个项目实际的放到线上去，运维工程师不了解前面的 9 条前端架构师干的活，他是负责把服务器做好，不让你的服务器崩掉，怎么在服务器上取这些服务需要靠你 一键部署，我们可以用 Yeoman 或者是其他的工具去做，比如说：你用一个 Grunt 定义一个 default tast（默认的任务），只要你执行一个 `grunt` 项目就编译完了，然后用一句 shell 脚本 把这个项目 SEP 到本地 再到远程服务器，远程服务器自动刷新系统给你一分，这样就完了，但是前提是你一定得按你当前这个目录把整个一个网站全部搞定，就是说运维他不懂你这个前端到底都干了些什么 ，所以说你给运维一个命令让他发布成功，这个项目就算是 OK 了

上面这 10 条只要你能理解透了，那基本的面试官就难不住你了

**11. 初入江湖**

在你刚成为一个前端工程师的时候，你需要做的事情就是：压缩

文件 MD5 就是给它加一个戳，我们平时会看到有人在 link 一个 a.css 的时候，后面会加一个 ? 什么的，比如说 a.2015 什么的，这个跟这个戳差不多，主要是为了不让这个 css 文件在本地有太多的缓存，这个是早期的用法，但是现在都做的是这种 MD5 的比较，给这个文件值后面加这么一堆，比方说：a.554.js 下次上面就变成了 a.5644.js ，这样上一个文件就不会被缓存调了，这些都是最基础的东西了

> [tinypng](https://link.jianshu.com/?t=https://tinypng.com/) 是一个压缩图片的网站。慢慢的你就会使用一些简单的框架实现像后台管理这样的简单项目

**12. 深不可测**

接下来你会发现有很多的东西还不是很够用，随着需求的增加你的代码变得越来越乱，因为深不可测的原因是你的产品和需求在不停的迭代，所以你会发现很多东西都比较的混乱无章

还有一个原因是，你原来在页面里面写单个的 html 会写无数的 ajax ，比如说：你可能写六个或七个为了业务的需求，这个时候如果在移动端就会造成 ajax 直接就断掉了，因为它并发的 ajax 是有限制的，在你请求这个 ajax 的时候，请求就把你干掉了，还有是网络不好的情况下，就死掉了，请求发了十几个也就不行了

然后就是单个 js ，就比如说： index.js 一直写越来越大 越来越大 这样也是一个问题

然后就是重复加载，比如说：你的每个页面都会引这个 a.js 就会造成这个问题

会发现项目中 到处都是 $.ajax function

domready 是一个非常重要的指标



## 参考

- [MDN](https://developer.mozilla.org/zh-CN/)
- [CocoaUI](http://www.cocoaui.com/) - 一个强大的 iOS UI 框架
- [梦想天空](https://www.cnblogs.com/lhb25/)

- [企业级实战前端工程师](https://marketing.csdn.net/p/d83bc75569e11362a91b0f0ff37237bb?utm_medium=distribute.pc_relevant_t0.479151&depth_1-utm_source=distribute.pc_relevant_t0.479151)

- https://segmentfault.com/a/1190000018249137


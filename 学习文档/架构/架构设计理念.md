# 架构设计理念

![x](D:\Owf\IT\Resources\st_cover.png)

1. 理论
   - [微服务架构设计](#微服务架构设计)
2. 实战
   - [微服务架构技术栈选型](#微服务架构技术栈选型)
3. 总结
4. 升华



## 理论



### 微服务架构设计

参考：

- [微服务架构设计](https://www.cnblogs.com/wintersun/p/6219259.html)



![x](D:\Owf\IT\Resources\st004.png)

#### 服务之间如何通信

一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。

RESTful 和 RPC 的比较也是一个很有意思的话题。

一般 REST 基于 HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了 HTTP 的 SDK 就能调用，所以相对使用的广一些。

RPC 也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。

而异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；还有就是后台服务一般要实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的 broker，如果公司内部没有技术积累，对 broker 分布式管理也是一个很大的挑战。

![x](D:\Owf\IT\Resources\st005.png)

![x](D:\Owf\IT\Resources\st006.png)

#### 微服务优点

- 每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。
- 微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。
- 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
- 微服务能使用不同的语言开发。
- 微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如 Jenkins, bamboo 。
- 一个团队的新成员能够更快投入生产。
- 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。
- 微服务允许你利用融合最新技术。
- 微服务只是业务逻辑的代码，不会和 HTML,CSS 或其他界面组件混合。
- 微服务能够即时被要求扩展。
- 微服务能部署中低端配置的服务器上。
- 易于和第三方集成。
- 每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。

#### 微服务架构的缺点

- 微服务架构可能带来过多的操作。
- 需要DevOps技巧 (http://en.wikipedia.org/wiki/DevOps).
- 可能双倍的努力。
- 分布式系统可能复杂难以管理。
- 因为分布部署，所以跟踪问题难。
- 当服务数量增加，管理复杂性增加。

#### 需要考虑的问题

- 单个微服务代码量小，易修改和维护。但是，系统复杂度的总量是不变的，每个服务代码少了，但服务的个数肯定就多了。就跟拼图游戏一样，切的越碎，越难拼出整幅图。一个系统被拆分成零碎的微服务，最后要集成为一个完整的系统，其复杂度肯定比大块的功能集成要高很多。

- 单个微服务数据独立，可独立部署和运行。虽然微服务本身是可以独立部署和运行的，但仍然避免不了业务上的你来我往，这就涉及到要对外通信，当微服务的数量达到一定量级的时候，如何提供一个高效的集群通信机制成为一个问题。

- 单个微服务拥有自己的进程，进程本身就可以动态的启停，为无缝升级的打好了基础，但谁来启动和停止进程，什么时机，选择在哪台设备上做这件事情才是无缝升级的关键。这个能力并不是微服务本身提供的，而是需要背后强大的版本管理和部署能力。

- 多个相同的微服务可以做负载均衡，提高性能和可靠性。正是因为相同微服务可以有多个不同实例，让服务按需动态伸缩成为可能，在高峰期可以启动更多的相同的微服务实例为更多用户服务，以此提高响应速度。同时这种机制也提供了高可靠性，在某个微服务故障后，其他相同的微服务可以接替其工作，对外表现为某个设备故障后业务不中断。同样的道理，微服务本身是不会去关心系统负载的，那么什么时候应该启动更多的微服务，多个微服务的流量应该如何调度和分发，这背后也有一套复杂的负载监控和均衡的系统在起作用。

- 微服务可以独立部署和对外提供服务，微服务的业务上线和下线是动态的，当一个新的微服务上线时，用户是如何访问到这种新的服务？这就需要有一个统一的入口，新的服务可以动态的注册到这个入口上，用户每次访问时可以从这个入口拿到系统所有服务的访问地址。这个统一的系统入口并不是微服务本身的一部分，所以这种能力需要系统单独提供。

- 还有一些企业级关注的系统问题，比如，安全策略如何集中管理？系统故障如何快速审计和跟踪到具体服务？整个系统状态如何监控？服务之间的依赖关系如何管理等等。这些问题都不是单个微服务考虑的范畴，而需要有一个系统性的考虑和设计，让每个微服务都能够按照系统性的要求和约束提供对应的安全性，可靠性，可维护性的能力。

![x](D:\Owf\IT\Resources\st007.png)

#### API为什么很重要

- 服务价值的精华体现 
- 可靠、可用、可读 
- 只有一次机会

![x](D:\Owf\IT\Resources\st008.png)

实现一个API网关作为所有客户端的唯一入口。API网关有两种方式来处理请求。有些请求被简单地代理/路由到合适的服务上，其他的请求被转给到一组服务。

![x](D:\Owf\IT\Resources\st009.png)

相比于提供普适的API，API网关根据不同的客户端开放不同的API。比如，[Netflix API](http://techblog.netflix.com/2012/07/embracing-differences-inside-netflix.html)网关运行着客户端特定的适配器代码，会向客户端提供最适合其需求的API。

API网关也可以实现安全性，比如验证客户端是否被授权进行某请求。

#### 设计要素

- Version 
- RequstID 
- Auth&Signature 
- RateLimit 
- Docs 
- ErrorCode&Message

![x](D:\Owf\IT\Resources\st010.png)

#### 微服务治理

- 按需伸缩：部署与监控运维成本 
- 独立部署：机器数量与部署成本 
- 业务独立：服务依赖、治理，版本管理、事务处理 
- 技术多样性：环境部署成本、约定成本
- 运行状态治理：监控、限流、SLA、LB、日志分析 
- 服务注册与发现 
- 部署：快速、复制、扩容 
- 单机开发 
- 调用：安全、容错、服务降级、调用延时

![x](D:\Owf\IT\Resources\st011.png)

![x](D:\Owf\IT\Resources\st012.png)

#### 服务容错

当企业微服务化以后，服务之间会有错综复杂的依赖关系，例如，一个前端请求一般会依赖于多个后端服务，技术上称为1 -> N扇出。

在实际生产环境中，服务往往不是百分百可靠，服务可能会出错或者产生延迟，如果一个应用不能对其依赖的故障进行容错和隔离，那么该应用本身就处在被拖垮的风险中。

在一个高流量的网站中，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源（线程，队列等）被耗尽，造成所谓的雪崩效应(Cascading Failure)，严重时可致整个网站瘫痪。

![x](D:\Owf\IT\Resources\st013.png)

**服务依赖**

![x](D:\Owf\IT\Resources\st014.png)

#### 服务框架

服务注册、发现、负载均衡和健康检查，假定采用进程内LB方案，那么服务自注册一般统一做在服务器端框架中，健康检查逻辑由具体业务服务定制，框架层提供调用健康检查逻辑的机制，服务发现和负载均衡则集成在服务客户端框架中。

监控日志，框架一方面要记录重要的框架层日志、metrics和调用链数据，还要将日志、metrics等接口暴露出来，让业务层能根据需要记录业务日志数据。在运行环境中，所有日志数据一般集中落地到企业后台日志系统，做进一步分析和处理。

REST/RPC和序列化，框架层要支持将业务逻辑以HTTP/REST或者RPC方式暴露出来，HTTP/REST是当前主流API暴露方式，在性能要求高的场合则可采用Binary/RPC方式。针对当前多样化的设备类型(浏览器、普通PC、无线设备等)，框架层要支持可定制的序列化机制，例如，对浏览器，框架支持输出Ajax友好的JSON消息格式，而对无线设备上的Native App，框架支持输出性能高的Binary消息格式。

配置，除了支持普通配置文件方式的配置，框架层还可集成动态运行时配置，能够在运行时针对不同环境动态调整服务的参数和配置。

限流和容错，框架集成限流容错组件，能够在运行时自动限流和容错，保护服务，如果进一步和动态配置相结合，还可以实现动态限流和熔断。

管理接口，框架集成管理接口，一方面可以在线查看框架和服务内部状态，同时还可以动态调整内部状态，对调试、监控和管理能提供快速反馈。Spring Boot微框架的Actuator模块就是一个强大的管理接口。

统一错误处理，对于框架层和服务的内部异常，如果框架层能够统一处理并记录日志，对服务监控和快速问题定位有很大帮助。

安全，安全和访问控制逻辑可以在框架层统一进行封装，可做成插件形式，具体业务服务根据需要加载相关安全插件。

文档自动生成，文档的书写和同步一直是一个痛点，框架层如果能支持文档的自动生成和同步，会给使用API的开发和测试人员带来极大便利。Swagger是一种流行Restful API的文档方案。

#### 微服务系统底座

一个完整的微服务系统，它的底座最少要包含以下功能：

- 日志和审计，主要是日志的汇总，分类和查询
- 监控和告警，主要是监控每个服务的状态，必要时产生告警
- 消息总线，轻量级的MQ或HTTP
- 注册发现
- 负载均衡
- 部署和升级
- 事件调度机制
- 资源管理，如：底层的虚拟机，物理机和网络管理

以下功能不是最小集的一部分，但也属于底座功能：

- 认证和鉴权
- 微服务统一代码框架，支持多种编程语言
- 统一服务构建和打包
- 统一服务测试
- 微服务CI/CD流水线
- 服务依赖关系管理
- 统一问题跟踪调试框架，俗称调用链
- 灰度发布
- 蓝绿部署

#### 容器(Docker)与微服务

- 容器够小：解决微服务对机器数量的诉求 
- 容器独立：解决多语言问题 
- 开发环境与生产环境相同：单机开发、提升效率 
- 容器效率高：省钱 
- 代码/image一体化：可复用管理系统
- 容器的横向与纵向扩容：可复制、可动态调节CPU与内存
- Image管理
- 系统安全管理 
- 授权管理 
- 系统成熟度 
- 社区成熟度

#### 开发方式影响

随着持续交付概念推广以及Docker容器普及，微服务将这两种理念和技术结合起来，形成新的 **微服务 + API + 平台** 的开发模式，提出了容器化微服务的持续交付概念。

下图传统Monolithic的DevOps开发队伍方式：

![x](D:\Owf\IT\Resources\st015.png)

这种整体型架构要求产品队伍横跨产品管理 Dev 开发 QA DBA 以及系统运营管理，而微服务架构引入以后，如下图：

![x](D:\Owf\IT\Resources\st016.png)

微服务促进了 DevOps 方式的重组，将一个大臃肿的整体产品开发队伍切分为根据不同微服务的划分的产品队伍，以及一个大的整体的平台队伍负责运营管理，两者之间通过 API 交互，做到了松耦合隔绝。

![x](D:\Owf\IT\Resources\st017.png)

![x](D:\Owf\IT\Resources\st018.png)

- 首先需要考虑构建 DevOps 能力，这是保证微服务架构在持续交付和应对复杂运维问题的动力之源；
- 其次保持服务持续演进，使之能够快速、低成本地被拆分和合并，以快速响应业务的变化；
- 同时要保持团队和架构对齐。微服务貌似是技术层面的变革，但它对团队结构和组织文化有很强的要求和影响。识别和构建匹配架构的团队是解决问题的另一大支柱。
- 最后，打造持续改进的自组织文化是实施微服务的关键基石。只有持续改进，持续学习和反馈，持续打造这样一个文化氛围和团队，微服务架构才能持续发展下去，保持新鲜的生命力，从而实现我们的初衷。

微服务的实施是有一定的先决条件：基础的运维能力（如监控、快速配置、快速部署）需提前构建，否则就会陷入如我们般被动的局面。推荐采用[基础设施及代码](http://martinfowler.com/bliki/InfrastructureAsCode.html)的实践，通过代码来描述计算和网络基础设施的方法，使得图案度i可以快速安全的搭建和处理由新的配置代替的服务器，服务器之间可以拥有更高的一致性，降低了在“我的环境工作，而你的环境不工作”的可能，也是为后续的发布策略和运维提供更好的支撑。

![x](D:\Owf\IT\Resources\st019.png)

由于Docker引入，不同的微服务可以使用不同的技术架构，比如Node.js Java Ruby Python等等，这些单个的服务都可以独立完成交付生命周期，如下：

![x](D:\Owf\IT\Resources\st020.png)

#### 微服务案例

Netflix的微服务架构如下，着重全球分发高可扩展性和可用性：

![x](D:\Owf\IT\Resources\st021.png)

Twitter的微服务架构，注重高效的可扩展的数据中心：

![x](D:\Owf\IT\Resources\st022.png)

希望对您系统架构，软件项目开发,运维管理，系统架构与研发管理体系, 信息安全, 企业信息化等有帮助。 其它您可能感兴趣的文章： 

[云计算参考架构几例](http://www.cnblogs.com/wintersun/p/4183516.html) 
[微服务与Docker介绍](http://www.cnblogs.com/wintersun/p/5136385.html) 
[互联网直播平台架构案例一](http://www.cnblogs.com/wintersun/p/5860437.html) 
[高可用架构案例一](http://www.cnblogs.com/wintersun/p/5837153.html) 
[某互联网公司广告平台技术架构](http://www.cnblogs.com/wintersun/p/5812731.html) 
[某大型电商云平台实践](http://www.cnblogs.com/wintersun/p/5023626.html) 
[云计算参考架构几例](http://www.cnblogs.com/wintersun/p/4183516.html) 
[移动应用App测试与质量管理一](http://www.cnblogs.com/wintersun/p/5636610.html) 
[全面的软件测试](http://www.cnblogs.com/wintersun/p/5325528.html) 
[著名ERP厂商的SSO单点登录解决方案介绍一](http://www.cnblogs.com/wintersun/p/5571483.html) 
[软件项目风险管理介绍](http://www.cnblogs.com/wintersun/p/5468004.html) 
[企业项目化管理介绍](http://www.cnblogs.com/wintersun/p/5427016.html) 
[智能企业与信息化之一](http://www.cnblogs.com/wintersun/p/5342615.html) 
[由企业家基本素质想到的](http://www.cnblogs.com/wintersun/p/3265306.html) 
[敏捷软件质量保证的方法与实践](http://www.cnblogs.com/wintersun/p/5297352.html) 
[构建高效的研发与自动化运维](http://www.cnblogs.com/wintersun/p/5059097.html) 
[IT运维监控解决方案介绍](http://www.cnblogs.com/wintersun/p/5093790.html) 
[IT持续集成之质量管理](http://www.cnblogs.com/wintersun/p/5271933.html) 
[人才公司环境与企业文化](http://www.cnblogs.com/wintersun/p/4852379.html) 
[企业绩效管理系统之平衡记分卡](http://www.cnblogs.com/wintersun/p/5079770.html) 
[企业文化、团队文化与知识共享](http://www.cnblogs.com/wintersun/p/3852001.html) 
[高效能的团队建设](http://www.cnblogs.com/wintersun/p/3523146.html) 
[餐饮连锁公司IT信息化解决方案一](http://www.cnblogs.com/wintersun/p/4020381.html)



## 实战



### 微服务架构技术栈选型

2014 年可以认为是微服务 1.0 的元年，当年有几个标志性事件，一是 Martin Fowler 在其博客上发表了”Microservices”一文，正式提出微服务架构风格；二是 Netflix 微服务架构经过多年大规模生产验证，最终抽象落地形成一整套开源的微服务基础组件，统称 NetflixOSS，Netflix 的成功经验开始被业界认可并推崇；三是 Pivotal 将 NetflixOSS 开源微服务组件集成到其 Spring 体系，推出 Spring Cloud 微服务开发技术栈。

一晃三年过去，微服务技术生态又发生了巨大变化，容器，PaaS，Cloud Native，gRPC，ServiceMesh，Serverless 等新技术新理念你方唱罢我登场，不知不觉我们又来到了微服务 2.0 时代。

基于近年在微服务基础架构方面的实战经验和平时的学习积累，我想总结并提出一些构建微服务 2.0 技术栈的选型思路，供各位在一线实战的架构师、工程师参考借鉴。对于一些暂时还没有成熟开源产品的微服务支撑模块，我也会给出一些定制自研的设计思路。

#### 选型准则

对于技术选型，我个人有很多标准，其中下面三项是最重要的：

1. 生产级

   我们选择的技术栈是要解决实际业务问题和上生产抗流量的（选择不慎可能造成生产级事故），而不是简单做个 POC 或者 Demo 展示，所以生产级（Production Ready），可运维（Ops Ready），可治理，成熟稳定的技术才是我们的首选；

2. 一线互联网公司落地产品

   我们会尽量采用在一线互联网公司落地并且开源的，且在社区内形成良好口碑的产品，它们已经在这些公司经过流量冲击，坑已经基本被填平，且被社区接受形成一个良好的社区生态（本文附录部分会给出所有推荐使用或参考的开源项目的 GitHub 链接）。

3. 开源社区活跃度

   GitHub 上的 stars 的数量是一个重要指标，同时会参考其代码和文档更新频率（尤其是近年），这些指标直接反应开源产品的社区活跃度或者说生命力。

另外，对于不同业务体量和团队规模的公司，技术选型标准往往是不同的，创业公司的技术选型和 BAT 级别公司的技术选型标准可能完全不同。本文主要针对日流量千万以上，研发团队规模不少于 50 人的公司，如果小于这个规模我建议认真评估是否真的需要采用微服务架构。

考虑到 Java 语言在国内的流行度和我个人的背景经验，本文主要针对采用 Java 技术栈的企业。本文也假定自建微服务基础架构，有些产品其实有对应的云服务可以直接使用，自建和采用云服务各有利弊，架构师需要根据场景上下文综合权衡。

#### 微服务基础架构关键点

下面脑图中芒果色标注的七个模块，我认为是构建微服务 2.0 技术栈的核心模块，本文后面的选型会分别基于这些模块展开。对于每个模块我也列出一些核心架构关注点，在选择具体产品时，需要尽可能覆盖到这些关注点。

![x](D:\Owf\IT\Resources\st023.png)

下图是我近期工作总结和参考的一个微服务技术体系，我想同时分享给一线架构师或者工程师参考，其中粉红色标注的模块是和微服务关系最密切的模块，大家在做技术选型时，可以同时对照这个体系。

![x](D:\Owf\IT\Resources\st024.png)

#### 服务框架选型

服务框架是一个比较成熟的领域，有太多可选项。Spring Boot/Cloud[附录 12.1] 由于 Spring 社区的影响力和 Netflix 的背书，目前可以认为是构建 Java 微服务的一个社区标准，Spring Boot 目前在 GitHub 上有超过 20k 星。

基于 Spring 的框架本质上可以认为是一种 RESTful 框架（不是 RPC 框架），序列化协议主要采用基于文本的 JSON，通讯协议一般基于 HTTP。RESTful 框架天然支持跨语言，任何语言只要有 HTTP 客户端都可以接入调用，但是客户端一般需要自己解析 payload。目前 Spring 框架也支持 Swagger 契约编程模型，能够基于契约生成各种语言的强类型客户端，极大方便不同语言栈的应用接入，但是因为 RESTful 框架和 Swagger 规范的弱契约特性，生成的各种语言客户端的互操作性还是有不少坑的。

Dubbo[附录 12.2] 是阿里多年构建生产级分布式微服务的技术结晶，服务治理能力非常丰富，在国内技术社区具有很大影响力，目前 github 上有超过 16k 星。Dubbo 本质上是一套基于 Java 的 RPC 框架，当当 Dubbox 扩展了 Dubbo 支持 RESTful 接口暴露能力。

Dubbo 主要面向 Java 技术栈，跨语言支持不足是它的一个弱项，另外因为治理能力太丰富，以至于这个框架比较重，完全用好这个框架的门槛比较高，但是如果你的企业基本上投资在 Java 技术栈上，选 Dubbo 可以让你在服务框架一块站在较高的起点上，不管是性能还是企业级的服务治理能力，Dubbo 都做的很出色。新浪微博开源的 Motan（GitHub 4k stars）也不错，功能和 Dubbo 类似，可以认为是一个轻量裁剪版的 Dubbo。

gRPC[附录 12.3] 是谷歌近年新推的一套 RPC 框架，基于 protobuf 的强契约编程模型，能自动生成各种语言客户端，且保证互操作。支持 HTTP2 是 gRPC 的一大亮点，通讯层性能比 HTTP 有很大改进。Protobuf 是在社区具有悠久历史和良好口碑的高性能序列化协议，加上 Google 公司的背书和社区影响力，目前 gRPC 也比较火，GitHub 上有超过 13.4k 星。

目前看 gRPC 更适合内部服务相互调用场景，对外暴露 RESTful 接口可以实现，但是比较麻烦（需要 gRPC Gateway 配合），所以对于对外暴露 API 场景可能还需要引入第二套 RESTful 框架作为补充。总体上 gRPC 这个东西还比较新，社区对于 HTTP2 带来的好处还未形成一致认同，建议谨慎投入，可以做一些试点。

#### 运行时支撑服务选型

运行时支撑服务主要包括服务注册中心，服务路由网关和集中式配置中心三个产品。

服务注册中心，如果采用 Spring Cloud 体系，则选择 Eureka[附录 12.4] 是最佳搭配，Eureka 在 Netflix 经过大规模生产验证，支持跨数据中心，客户端配合 Ribbon 可以实现灵活的客户端软负载，Eureka 目前在 GitHub 上有超过 4.7k 星；Consul[附录 12.5] 也是不错选择，天然支持跨数据中心，还支持 KV 模型存储和灵活健康检查能力，目前在 GitHub 上有超过 11k 星。

服务网关也是一个比较成熟的领域，有很多可选项。如果采用 Spring Cloud 体系，则选择 Zuul[附录 12.6] 是最佳搭配，Zuul 在 Netflix 经过大规模生产验证，支持灵活的动态过滤器脚本机制，异步性能不足（基于 Netty 的异步 Zuul 迟迟未能推出正式版）。Zuul 网关目前在 github 上有超过 3.7k 星。基于 Nginx/OpenResty 的 API 网关 Kong[附录 12.7] 目前在 github 上比较火，有超过 14.1k 星。因为采用 Nginx 内核，Kong 的异步性能较强，另外基于 lua 的插件机制比较灵活，社区插件也比较丰富，从安全到限流熔断都有，还有不少开源的管理界面，能够集中管理 Kong 集群。

配置中心，Spring Cloud 自带 Spring Cloud Config[附录 12.8]（GitHub 0.75k stars），个人认为算不上生产级，很多治理能力缺失，小规模场景可以试用。个人比较推荐携程的 Apollo[附录 12.9] 配置中心，在携程经过生产级验证，具备高可用，配置实时生效（推拉结合），配置审计和版本化，多环境多集群支持等生产级特性，建议中大规模需要对配置集中进行治理的企业采用。Apollo 目前在 github 上有超过 3.4k 星。

#### 服务监控选型

主要包括日志监控，调用链监控，Metrics 监控，健康检查和告警通知等产品。

ELK 目前可以认为是日志监控的标配，功能完善开箱即用，ElasticSearch[附录 12.10] 目前在 GitHub 上有超过 28.4k 星。Elastalert[附录 12.11] (GitHub 4k stars) 是 Yelp 开源的针对 ELK 的告警通知模块。

调用链监控目前社区主流是点评 CAT[附录 12.12]（GitHub 4.3k stars），Twitter 之前开源现在由 OpenZipkin 社区维护的 Zipkin[附录 12.13]（GitHub 7.5k stars）和 Naver 开源的 Pinpoint[附录 12.14]（GitHub 5.3k stars）。个人比较推荐点评开源的 CAT，在点评和国内多家互联网公司有落地案例，生产级特性和治理能力较完善，另外 CAT 自带告警模块。下面是我之前对三款产品的评估表，供参考。

![x](D:\Owf\IT\Resources\st025.png)

Metrics 监控主要依赖于时间序列数据库 (TSDB)，目前较成熟的产品是 StumbleUpon 公司开源的基于 HBase 的 OpenTSDB[附录 12.15]（基于 Cassandra 的 KariosDB[附录 12.16] 也是一个选择，GitHub 1.1k stars，它基本上是 OpenTSDB 针对 Cassandra 的一个改造版），OpenTSDB 具有分布式能力可以横向扩展，但是相对较重，适用于中大规模企业，OpenTSDB 目前在 GitHub 上有近 2.9k 星。

OpenTSDB 本身不提供告警模块，Argus[附录 12.17]（GitHub 0.29k 星）是 Salesforce 开源的基于 OpenTSDB 的统一监控告警平台，支持丰富的告警函数和灵活的告警配置，可以作为 OpenTSDB 的告警补充。近年也出现一些轻量级的 TSDB，如 InfluxDB[附录 12.18]（GitHub 12.4k stars）和 Prometheus[附录 12.19]（GitHub 14.3k stars），这些产品函数报表能力丰富，自带告警模块，但是分布式能力不足，适用于中小规模企业。Grafana[附录 12.20]（GitHub 19.9k stars）是 Metrics 报表展示的社区标配。

社区还有一些通用的健康检查和告警产品，例如 Sensu[附录 12.21]（GitHub 2.7k stars），能够对各种服务（例如 Spring Boot 暴露的健康检查端点，时间序列数据库中的 metrics，ELK 中的错误日志等）定制灵活的健康检查 (check)，然后用户可以针对 check 结果设置灵活的告警通知策略。Sensu 在 Yelp 等公司有落地案例。其它类似产品还有 Esty 开源的 411[附录 12.22]（GitHub 0.74k 星）和 Zalando 的 ZMon[附录 12.23] (GitHub 0.15k 星)，它们是分别在 Esty 和 Zalando 落地的产品，但是定制 check 和告警配置的使用门槛比较高，社区不热，建议有定制自研能力的团队试用。ZMon 后台采用 KairosDB 存储，如果企业已经采用 KariosDB 作为时间序列数据库，则可以考虑 ZMon 作为告警通知模块。

#### 服务容错选型

针对 Java 技术栈，Netflix 的 Hystrix[附录 12.24]（github 12.4k stars）把熔断、隔离、限流和降级等能力封装成组件，任何依赖调用（数据库，服务，缓存）都可以封装在 Hystrix Command 之内，封装后自动具备容错能力。Hystrix 起源于 Netflix 的弹性工程项目，经过 Netflix 大规模生产验证，目前是容错组件的社区标准，GitHub 上有超 12k 星。其它语言栈也有类似 Hystrix 的简化版本组件。

Hystrix 一般需要在应用端或者框架内埋点，有一定的使用门槛。对于采用集中式反向代理（边界和内部）做服务路由的公司，则可以集中在反向代理上做熔断限流，例如采用 Nginx[附录 12.25]（GitHub 5.1k stars）或者 Kong[附录 12.7]（GitHub 11.4k stars）这类反向代理，它们都插件支持灵活的限流容错配置。Zuul 网关也可以集成 Hystrix 实现网关层集中式限流容错。集中式反向代理需要有一定的研发和运维能力，但是可以对限流容错进行集中治理，可以简化客户端。

#### 后台服务选型

后台服务主要包括消息系统，分布式缓存，分布式数据访问层和任务调度系统。后台服务是一个相对比较成熟的领域，很多开源产品基本可以开箱即用。

消息系统，对于日志等可靠性要求不高的场景，则 Apache 顶级项目 Kafka[附录 12.26]（GitHub 7.2k stars）是社区标配。对于可靠性要求较高的业务场景，Kafka 其实也是可以胜任，但企业需要根据具体场景，对  Kafka 的监控和治理能力进行适当定制完善，Allegro 公司开源的 hermes[附录 12.27]（GitHub 0.3k stars）是一个可参考项目，它在 Kafka 基础上封装了适合业务场景的企业级治理能力。阿里开源的 RocketMQ[附录 12.28]（GitHub 3.5k 星）也是一个不错选择，具备更多适用于业务场景的特性，目前也是 Apache 顶级项目。RabbitMQ[附录 12.29]（GitHub 3.6k 星）是老牌经典的 MQ，队列特性和文档都很丰富，性能和分布式能力稍弱，中小规模场景可选。

对于缓存治理，如果倾向于采用客户端直连模式（个人认为缓存直连更简单轻量），则 SohuTv 开源的 cachecloud[附录 12.30]（GitHub 2.5k stars）是一款不错的 Redis 缓存治理平台，提供诸如监控统计，一键开启，自动故障转移，在线伸缩，自动化运维等生产级治理能力，另外其文档也比较丰富。如果倾向采用中间层 Proxy 模式，则 Twitter 开源的 twemproxy[附录 12.31]（GitHub 7.5k stars）和 CodisLab 开源的 codis[附录 12.32]（GitHub 6.9k stars）是社区比较热的选项。

对于分布式数据访问层，如果采用 Java 技术栈，则当当开源的 shardingjdbc[附录 12.33]（GitHub 3.5k stars）是一个不错的选项，分库分表逻辑做在客户端 jdbc driver 中，客户端直连数据库比较简单轻量，建议中小规模场景采用。如果倾向采用数据库访问中间层 proxy 模式，则从阿里 Cobar 演化出来的社区开源分库分表中间件 MyCAT[附录 12.34]（GitHub 3.6k stars）是一个不错选择 。proxy 模式运维成本较高，建议中大规模场景，有一定框架自研和运维能力的团队采用。

任务调度系统，个人推荐徐雪里开源的 xxl-job[附录 12.35]（GitHub 3.4k stars），部署简单轻量，大部分场景够用。当当开源的 elastic-job[附录 12.36]（GitHub 3.2k stars）也是一个不错选择，相比 xxl-job 功能更强一些也更复杂。

#### 服务安全选型

对于微服务安全认证授权机制一块，目前业界虽然有 OAuth 和 OpenID connect 等标准协议，但是各家具体实现的做法都不太一样，企业一般有很多特殊的定制需求，整个社区还没有形成通用生产级开箱即用的产品。有一些开源授权服务器产品，比较知名的如 Apereo CAS[附录 12.37]（GitHub 3.6k stars），JBoss 开源的 keycloak[附录 12.38]（GitHub 1.9 stars），spring cloud security[附录 12.39] 等，大都是 opinionated（一家观点和做法）的产品，同时因支持太多协议造成产品复杂，也缺乏足够灵活性。

个人建议基于 OAuth 和 OpenID connect 标准，在参考一些开源产品的基础上（例如 Mitre 开源的 OpenID-Connect-Java-Spring-Server[附录 12.40]，GitHub 0.62k stars），定制自研轻量级授权服务器。Wso2 提出了一种微服务安全的参考方案 [附录 12.45]，建议参考，该方案的关键步骤如下：

![x](D:\Owf\IT\Resources\st026.png)

 

1. 使用支持 OAuth 2.0 和 OpenID Connect 标准协议的授权服务器（个人建议定制自研）；
2. 使用 API 网关作为单一访问入口，统一实现安全治理；
3. 客户在访问微服务之前，先通过授权服务器登录获取 access token，然后将 access token 和请求一起发送到网关；
4. 网关获取 access token，通过授权服务器校验 token，同时做 token 转换获取 JWT token。
5. 网关将 JWT Token 和请求一起转发到后台微服务；
6. JWT 中可以存储用户会话信息，该信息可以传递给后台的微服务，也可以在微服务之间传递，用作认证授权等用途；
7. 每个微服务包含 JWT 客户端，能够解密 JWT 并获取其中的用户会话信息。

整个方案中，access token 是一种 by reference token，不包含用户信息可以直接暴露在公网上；JWT token 是一种 by value token，可以包含用户信息但不暴露在公网上。

#### 服务部署平台选型

容器已经被社区接受为交付微服务的一种理想手段，可以实现不可变（immutable）发布模式。一个轻量级的基于容器的服务部署平台主要包括容器资源调度，发布系统，镜像治理，资源治理和 IAM 等模块。

- **集群资源调度系统**

  屏蔽容器细节，将整个集群抽象成容器资源池，支持按需申请和释放容器资源，物理机发生故障时能够实现自动故障迁移 (fail over)。

  目前 Google 开源的 Kubernetes[附录 12.41]，在 Google 背书和社区的强力推动下，基本已经形成市场领导者地位，GitHub 上有 31.8k 星，社区的活跃度已经远远超过了 mesos[附录 12.42]（GitHub 3.5k stars）和 swarm 等竞争产品，所以容器资源调度建议首选 K8s。当然如果你的团队有足够定制自研能力，想深度把控底层调度算法，也可以基于 Mesos 做定制自研。

- **镜像治理**

  基于 Docker Registry，封装一些轻量级的治理功能。VMware 开源的 harbor[附录 12.43] (GitHub 3.5k stars) 是目前社区比较成熟的企业级产品，在 Docker Registry 基础上扩展了权限控制，审计，镜像同步，管理界面等治理能力，可以考虑采用。

- **资源治理**

  类似于 CMDB 思路，在容器云环境中，企业仍然需要对应用 app，组织 org，容器配额和数量等相关信息进行轻量级的治理。目前这块还没有生产级的开源产品，一般企业需要根据自己的场景定制自研。

- **发布平台**

  面向用户的发布管理控制台，支持发布流程编排。它和其它子系统对接交互，实现基本的应用发布能力，也实现如蓝绿，金丝雀和灰度等高级发布机制。

  目前这块生产级的开源产品很少，Netflix 开源的 spinnaker[附录 12.44]（github 4.2k stars）是一个，但是这个产品比较复杂重量（因为它既要支持适配对接各种 CI 系统，同时还要适配对接各种公有云和容器云，使得整个系统异常复杂），一般企业建议根据自己的场景定制自研轻量级的解决方案。

- **IAM**

  identity & access management 的简称，对发布平台各个组件进行身份认证和安全访问控制。

  社区有不少开源的 IAM 产品，比较知名的有 Apereo CAS（GitHub 3.6k stars），JBoss 开源的 keycloak（GitHub 1.9 stars）等。但是这些产品一般都比较复杂重量，很多企业考虑到内部各种系统灵活对接的需求，都会考虑定制自研轻量级的解决方案。

考虑到服务部署平台目前还没有端到端生产级解决方案，企业一般需要定制集成，下面给出一个可以参考的具备轻量级治理能力的发布体系：

![x](D:\Owf\IT\Resources\st027.png)

简化发布流程如下：

1. 应用通过 CI 集成后生成镜像，用户将镜像推到镜像治理中心；
2. 用户在资产治理中心申请发布，填报应用，发布和配额相关信息，然后等待审批通过；
3. 发布审批通过，开发人员通过发布控制台发布应用；
4. 发布系统通过查询资产治理中心获取发布规格信息；
5. 发布系统向容器云发出启动容器实例指令；
6. 容器云从镜像治理中心拉取镜像并启动容器；
7. 容器内服务启动后自注册到服务注册中心，并保持定期心跳；
8. 用户通过发布系统调用服务注册中心调拨流量，实现蓝绿，金丝雀或灰度发布等机制；
9. 网关和内部微服务客户端定期同步服务注册中心上的服务路由表，将流量按负载均衡策略分发到新的服务实例上。

另外，持续交付流水线（CD Pipeline）也是微服务发布重要环节，这块主要和研发流程相关，一般需要企业定制，下面是一个可供参考的流水线模型，在镜像治理中心上封装一些轻量级的治理流程，例如只有通过测试环境测试的镜像才能升级发布到 UAT 环境，只有通过 UAT 环境测试的镜像才能升级发布到生产环境，通过在流水线上设置一些质量门，保障应用高质量交付到生产。

![x](D:\Owf\IT\Resources\st028.png)

#### 写在最后

注意，本文限于篇幅，对测试和 CI 等环节没有涉及，但它们同样是构建微服务架构的重要环节，也有众多成熟的开源产品可选。

技术选型虽然重要，但还只是微服务建设的一小部分工作，选型后的产品要在企业内部真正落地，形成完整的微服务技术栈体系，则后续还有大量集成、定制、治理、运维和推广等工作。

本文仅限个人经验视角，选型思路仅供参考借鉴。每个企业的具体上下文（业务场景，团队组织，技术架构等）各不相同，每个架构师的背景经验也各不相同，大家要结合实际自己做出选型，没有最好的技术栈，只有相对较合适的技术栈。***另外，好的技术选型是相互借鉴甚至 PK 出来的，欢迎大家讨论，给出自己的微服务 2.0技术栈选型意见***。

#### 附录链接

[Spring Boot](https://github.com/spring-projects/spring-boot) 

[Alibaba Dubbo](https://github.com/alibaba/dubbo) 

[Google gRPC](https://github.com/grpc/grpc) 

[NetflixOSS Eureka](https://github.com/Netflix/eureka) 

[Hashicorp Consul](https://github.com/hashicorp/consul) 

[NetflixOSS Zuul](https://github.com/Netflix/zuul) 

[Kong](https://github.com/Kong/kong) 

[Spring Cloud Config](https://github.com/spring-cloud/spring-cloud-config) 

[CTrip Apollo](https://github.com/ctripcorp/apollo) 

[ElasticSearch](https://github.com/elastic/elasticsearch) 

[Yelp Elastalert](https://github.com/Yelp/elastalert) 

[Dianping CAT](https://github.com/dianping/cat) 

[Zipkin](https://github.com/openzipkin/zipkin) 

[Naver Pinpoint](https://github.com/naver/pinpoint) 

[OpenTSDB](https://github.com/OpenTSDB/opentsdb) 

[KairosDB](https://github.com/kairosdb/kairosdb) 

[Argus](https://github.com/salesforce/Argus) 

[InfluxDB](https://github.com/influxdata/influxdb) 

[Prometheus](https://github.com/prometheus/prometheus) 

[Grafana](https://github.com/grafana/grafana) 

[Sensu](https://github.com/sensu/sensu) 

[Esty 411](https://github.com/etsy/411) 

[Zalando ZMon](https://github.com/zalando/zmon) 

[NetflixOSS Hystrix](https://github.com/Netflix/Hystrix) 

[Nginx](https://github.com/nginx/nginx) 

[Apache Kafka](https://github.com/apache/kafka) 

[Allegro Hermes](https://github.com/allegro/hermes) 

[Apache Rocketmq](https://github.com/apache/rocketmq) 

[Rabbitmq](https://github.com/rabbitmq/rabbitmq-server) 

[Sohutv CacheCloud](https://github.com/sohutv/cachecloud) 

[Twitter twemproxy](https://github.com/twitter/twemproxy) 

[CodisLab codis](https://github.com/CodisLabs/codis) 

[Dangdang Sharding-jdbc](https://github.com/shardingjdbc/sharding-jdbc) 

[MyCAT](https://github.com/MyCATApache/Mycat-Server) 

[Xxl-job](https://github.com/xuxueli/xxl-job) 

[Dangdang elastic-job](https://github.com/elasticjob/elastic-job-lite) 

[Apereo CAS](https://github.com/apereo/cas) 

[JBoss keycloak](https://github.com/keycloak/keycloak) 

[Spring cloud security](https://github.com/spring-cloud/spring-cloud-security) 

[OpenID-Connect-Java-Spring-Server](https://github.com/mitreid-connect/OpenID-Connect-Java-Spring-Server) 

[Google Kubernetes](https://github.com/kubernetes/kubernetes) 

[Apache Mesos](https://github.com/apache/mesos) 

[Vmware Harbor](https://github.com/vmware/harbor) 

[Netflix Spinnaker](https://github.com/spinnaker/spinnaker) 

[Microservices in Practice – Key Architecture Concepts of an MSA](https://wso2.com/whitepapers/microservices-in-practice-key-architectural-concepts-of-an-msa/) 







# ***\*松耦合系统架构浅析\****

## 导读：系统架构分解及松耦合综述

  说起“架构”一词，想必绝大多数有过项目经验的开发人员都不陌生，很多人也将“架构师”作为自己职业发展的一个方向。可“架构”这个词虽然很多中英文书籍都已经对它下了相对比较准确的定义，但是仍然避免不了它在人们心中一直是一种言之较虚的存在。

  无论说它是“组件以及组件之间的关系”又或是“一切不能轻易改变的与系统相关的重要的决策、方案、规则和要素”，都很难具象的告诉人们哪些东西应该包含到架构文档中去。至于像“4+1”视图之类的理论，如果严格按照这种形式来组织架构，就会发现有可能遗漏一些关键决策。当然，出现这种情况，完全可以通过增加更多的视图来解决。不过，有些决策却不是可以通过视图能够直观展示的。

  如果说架构是一组决策、方案、规则和要素的集合以不同视图向不同干系人的一种展现，那么我们有理由暂时抛开这些理论定义的约束，去问一下我们在架构阶段需要得到哪些信息？需要将哪些内容固化下来，指导以后的设计及开发？

  从这个角度上看就会发现，架构也是分层次的。这也或许是为什么架构师也会有很多名称的原因。

  国内部分企业将架构上升为一种方法论的角度，试图通过一套方法来合理的演进架构。不得不说，只有从方法论层面来审视架构设计，才能更宏观的明确它在企业中的位置以及它应该如何正确的发展。

  笔者早期了解过 TOGAF、Zachman Framework 等企业架构框架（了解不深，不敢妄谈），暂且不提在企业内部实施这种框架的成本以及所带来的价值，作为系统的承建者，它们却也给我们提供了一种高层的思考及分解架构的方式。

### ***\*系统架构的分解\****

  我们若要描述软件系统的一切重要的决策、方案、规则和要素，仔细分析会发现，它们是多个方面的，这也与 TOGAF 的描述相符。

  首先，是业务层面的内容，我们可以称为“业务架构”。可能很多人会问，“业务”不是属于“软件需求规格”该描述的事情吗？与架构有什么关系？

  如果我们开发的是一个独立的小规模的软件系统，通过一份“软件需求规格说明书”足以将其需求描述清楚，并作为系统研发的依据。但如果我们所要描述的是整个企业的业务支撑，此时显然不是通过一套系统来解决的，它可能包含数十个独立的系统，它们需要通过定义清晰的接口相互访问，以支持企业业务的正常运作。

  此时，需要结合企业的愿景，以高度抽象的方式（不需要关注具体的功能细节描述，此部分应由软件需求规格说明书描述）描述各个系统的核心业务模型、端到端的业务流程，以及它们之间的业务边界、交互过程。 另外，对于业务非常复杂的系统，我们需要对其进行按照不同层级进行业务域/功能、过程进行分解，以供不同的干系人参考。通过这种分解，就会明确在整个系统中，有哪些角色、每个角色需要操作管理哪些系统/模块/功能组件、与哪些角色进行交互、交互过程是如何进行的。

  这项业务域/功能、过程的分解结果与软件需求规格说明书相互配合，以准确的描述软件的业务需求。通过这种不同层级分解的方式，需求人员才会明确各系统、子系统、组件的业务范围、交互过程，从而基于此进一步细化各个功能点需求。

  我们之所以将其称为“业务架构”，是因为它描述的是业务层面的重要决策、业务组件以及组件间的端到端的业务流程，这些组件是以不同抽象层次展现的。它们不会描述系统有几个页面、每个页面有哪些输入、哪些操作，但这些却需要明确包含到需求规格说明书中，以指导设计、开发、测试。

  其次，是数据层面的内容，我们可以称之为“数据架构”。从本质上说，应用系统是不同的角色通过不同的功能对数据进行查看和操作的过程，应用系统是数据的记录和流转。对于数据部分，同样有很多关键的决策需要记录，当然这些决策不是指你在数据库建几张表、每张表有哪些列、每一列是什么类型。

  数据架构中的内容更多侧重于对核心数据模型、共享数据，以及数据生命周期的描述。通过数据架构，我们可以明确系统各数据域包含的核心模型、数据域边界、共享数据、数据生命周期等。

  再次，是应用层面的内容，我们可以将其视为对“业务架构”和“数据架构”向 IT 架构实现层面的转化，这也是与开发最为密切的一部分。通过对“业务架构”中业务域、业务组件、业务模型、业务过程的拆分、合并，从而形成应用架构层面的系统、子系统、模块以及对象。通过对“数据架构”中的数据域、核心模型、共享数据的转化，形成应用架构层面的数据库表设计、共享数据接口设计等。

  应用架构还包括集成架构和技术架构。前者包括与第三方系统的集成方式，如共享数据存储、SOA、RESTful、消息中间件等；后者包括基础技术平台的选型。

  最后，是基础设施层面的内容，包括我们的系统最终的部署环境：物理机还是云平台、主备还是大规模分布式集群，部署的操作系统：Linux 还是 Windows，还包括数据库环境的搭建、网络环境拓扑等等。有人称之为“技术架构”，但是为了避免与应用架构中的技术部分混淆，我们暂且称之为“基础设施架构”。

  综上可以发现，我们认为构建系统的核心决策是多方面的，既包含业务、数据，又包含应用和基础设施。而每一部分，我们又都可以采用一种分层的方式对其进行有效的分解，以便逐步细化，使其边界清晰，以做到高内聚、低耦合。

  因此，***\*我们说的松耦合的系统架构，更多的是一种对系统全方位的分析、分解的过程\****（抱歉，此时方才点出主题）。但在进入正题之前，还请允许我再多言几句这个常见的词汇。

### ***\*松耦合\****

​	想必绝大多数 IT 从业者（这个范围已经足够广了）都对这个词耳熟能详，甚至都会觉得完全没必要再对它进行任何阐述。

  但是不得不说，不同岗位对于松耦合的认识是不同的。对于开发人员，如果修改一个接口的时候，不影响其它接口，修改一个数据结构的时候不会影响其他无关的功能，那么我们就说他的代码是松耦合的。对于设计人员，如果变动一个模块的设计不会影响另一个模块，模块间的接口保持相对稳定，那么我们也会说他设计的模块是松耦合的。

  这些都是我们常见的松耦合的例子，但显然不是全部。可以想象一下，每次重新构建系统的时候，开发环境中是否有多余的不用的技术组件/框架，仅仅是因为它被包含到了你们的技术平台当中？每次部署/升级系统时，是否每次都是替换全部的发布包？

  如果是，那就说明至少在这几个方面，你的平台、系统不是松耦合的。当然，之所以出现这样的问题，是由多种因素综合导致的，这也是为什么我们开篇先把架构的各个方面都罗列一遍的原因。

  比如系统无法做到细粒度部署，首先可能是技术平台不支持、可能是应用组件业务层面耦合过重、也可能是部署架构的原因。只有通盘考虑各个环节，每个环节都按照既定的架构目标去设计，才能最终实现架构的真正意义上的松耦合。

### ***\*内容综述\****

  此系列文章主要从以上讲到的架构的各方面的内容入手，来探讨各种松耦合的方案、方法及途径。

· 首先是业务/数据分层分解。

· 其次是应用架构中的技术平台（后文称为“技术架构”）。

· 再次是应用架构中的功能架构（后文称为“开发架构”）。

· 最后是部署架构部分。

  除了业务/数据部分外，其他都不同程度的涉及对技术的选型、方案等的分析与讨论。

### ***\*总结\****

  本文作为开篇，主要简单讲述了系统架构的各个方面以及交代后续文章的内容。从下一篇开始，我们开始介绍对业务/数据的分层分解。

## 第01课：业务架构和数据架构松耦合

### ***\*概述\****

  任何系统尤其是事务性系统（与分析性系统对应），从本质上来说都可以将其分解为三个主要的部分：参与者、对象、操作。系统功能可以进一步理解为：参与人对某个或者某几个对象的一系列操作。

  参与者可以是真实的人，也可以是一个第三方系统或者自动化终端。对象指的就是领域对象。操作就是系统功能处理过程。

  下面以我们最熟悉的购物场景为例进行分析，会发现通过明确这三个组成部分，有助于我们更快、更准确、更清晰的理解需求：

l 参与者：买家、卖家。

l 领域对象：商品、支付信息、订单。

l 操作：购买及结算、发货。

  买家查看商品、添加到购物车、确定购买、生成订单并结算。卖家收到订单后，确认并进行发货。

  那有人可能会说，这不就是用例吗？也对也不对。用例（指用例图）多是对参与者、用例以及它们之间的关系的描述，其中用例对应了系统的功能，它包含了对象和业务过程两部分，是一种综合性描述。

  虽然通过用例图很容易知道参与人是如何协作并操作系统功能的，但这种方式并不能使我们很好的发现领域对象以及业务过程的边界，尤其我们的业务过程是横跨多个子系统、系统的情况。还有用例图只是一种概要性描述，并未详细描述业务过程，更多的情况是，我们需要结合用例图、BPMN 等从不同角度来进行描述。

  而且本文更多是侧重于如何来分析一个系统的需求，而不是需求的最终描述形式。也就是说我们讲的更多是一个方法论，而不是这个方法论的输出结果。

  尤其是对于复杂的业务系统集，弄清有哪些参与者、每个参与者可以操作哪几个系统的哪几个功能，需要与哪几个参与者协作完成。所有这些问题都有助于我们划分系统的业务边界和数据边界，构建松耦合的系统。

### ***\*业务过程框架\****

  如果你稍微了解电信行业的业务系统，那么就会对 eTOM 不陌生。简而言之，它是一套业务过程框架(Business Process Framework)，是一种参考框架或者分类模型，通过这方法论将服务提供商所涉及的所有业务活动进行分类。

  通过这种分类方式，可以有效的实现服务提供商业务过程的治理，使得任何粒度的变更都会体现到业务过程框架中来。

  我们在变更业务过程时，尤其是对于跨系统、子系统的业务过程变更。有时候很难理清它涉及的变更点，也很难直观的评估这些变更对业务过程的影响，这主要是因为我们常常在一个固定的粒度考虑业务变更。如果这个粒度过粗，那么有可能使得变更点不够具体、很难指导开发，如果这个粒度过细，那么又会导致变更点遗漏。除此之外，还会容易导致业务过程的边界不够清晰，使得各个系统或者模块产生耦合。

  一种合理的业务过程管理方式就是按层级进行分解，而这也是 eTOM 所采用的方式。通过借鉴 eTOM 这种业务过程框架，可以使我们在业务架构上实现松耦合，有助于对业务过程进行有效管理。

  在 eTOM 中，业务过程被按照不同层级进行了分解，主要体现为以下几个级别：

l Level 0——业务活动：识别和建模业务目标、价值流和环境约束，确定产品线作为最终交付的业务目标。在这一级别可以明确各产品线之间的边界。

l Level 1——过程组：设计产品结构、产品交付和支持流程链、企业级数据模型、组织结构，识别业务知识，这是所交付业务的功能结构。定义不同的视图来描述业务过程是如何结构化交付 Level 0 中的业务活动的，过程组织形式必须是从功能角度端到端的。

l Level 2——核心过程：识别行业标准参考模型；开发通用流程、过程层次结构；识别和建模业务数据定义、系统结构；定义业务角色。该级别主要是可识别的端到端业务过程的子过程。

l Level 3——业务流程：设计详细流程、分配业务角色、确定支持系统及数据流。将业务数据模型映射到系统数据模型，考虑失败路径、队列和瓶颈，该级别主要定义 Level2 中过程的具体流程。

l Level 4——操作流程：开发详细的子流程设计，定义操作角色，将过程链接到书面过程，确定详细的系统、设备和资源使用情况，该级别主要是对 Level3 的进一步细化。

l Level 5——详细的流程：通过工作流系统、电子商务解决方案和系统开发自动的交付流程。链接过程和数据模型到系统和软件开发环境，该级别主要是对 Level4 的进一步细化。

  也许你对 eTOM 这种划分感觉有点不知所以然。没关系，接下来通过一个例子进行说明，你或许会理解这套方法论在业务系统构建过程中的价值。

### ***\*业务过程分解示例\****

  本节试图通过一个示例来演示业务过程的逐步分解，当然本节对于业务过程的理解（尤其是高层分解）并不与 eTOM 一致，这也是仁者见仁智者见智的事情，关键是如何将这套方法论用到我们的实际工作中，去改进我们的业务过程管理，而不是生搬硬套。

#### ***\*业务活动\****

  如果你不是孤立的分析一个系统，而是全局考虑企业整体的业务活动，就会发现，企业的业务和数据是分区域而且最终形成一个闭环。

  业务数据基本上按照下面的一个示意图进行流动，以确保企业活动的正常运行：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps10.jpg)

  基础：如果你是一家销售类企业，那么在业务活动开始之前，需要有一些基础数据进行驱动。这些数据包括产品及价格、销售策略、供应商和合作伙伴等等，这些都应该认为是基础数据，它们是先于业务活动开始而存在的。

  运营：当基础数据具备之后，在这些基础数据的驱动之下，业务活动便可以开始运行。如产品销售形成的订单、支付记录、配送以及后期的服务，这是业务活动的核心。

  分析：基于对运营过程产生的数据进行各维度分析，并将分析结果应用于“基础”和“运营”的调整与优化，从而形成数据上的闭环。

  企业：前面三者形成了业务数据的闭环，而“企业”则作为一个横切面贯穿三者。它主要用于企业对各环节的监控、管理，如人员管理、绩效管理、财务管理、经营指标监控等。

  有了这四者，企业业务活动才能正常运行，但是这只是一个通用概念，我们再将其具像一下——电商类运营系统（受业务知识所限，不确保业务域的完整性，如有遗漏，实在抱歉）。

  在这四个环节的基础上，我们可以将系统的业务目标进行一个初步拆分：

  我们初步将整个的业务活动拆分为五部分：

l 产品及客户的管理：包括产品定义、产品销售、客户注册及管理、客户购买及支付等等。

l 库存：在整个产品销售过程中涉及的物品的管理，一部分属于销售过程，如销售出库及退还，一部分不属于销售过程，如进货、盘库。

l 服务：对产品销售各环节的服务跟踪及保障，如投诉处理等。

l 商家及合作伙伴：如商城入驻商家的管理、分成等。

l 企业：企业内部的管理，如销售人员、财务管理等。

  从我们对这五部分的介绍会发现，你可以根据这个分解划分产品线（可以再拆分或者合并，但最好与你的业务过程视图相符）。

#### ***\*过程组\****

  通过“业务活动”的分解，我们会自然而然对于它的每一部分再进行细分，如下图所示：

![x](D:\Owf\IT\Resources\st001.png)

  这里需要注意横向拆分和纵向拆分的区别：

  横向拆分表示功能相关的过程，纵向拆分表示端到端的业务流程。

  也就是通过横向拆分，将业务过程按照功能耦合程度聚合成不同的组。通过纵向拆分，则是对功能组内的端到端业务过程进行的拆解。

  以“产品、客户”为例，从横向看，它包括了产品策略及定义、客户注册、购买、计费等整个交易链条的功能。从纵向看，这个交易链条被拆分成了几部分：首先是产品策略的定义，其次是产品生命周期管理，然后是运营准备（客户注册、支付账户设置等等），再就是运营实现（购买、生成订单），最后是计费（支付、生成账单等等）。

#### ***\*核心过程\****

  显而易见，通过“过程组”两个维度的划分，我们很容易在此基础上做进一步的细化，明确核心功能。由于本部分非常复杂，不再整张视图显示，我们只拿“产品、客户”部分作为示例（假设这两部分我们作为一个系统，当然你可以进一步拆分为产品和客户两个系统）。

  通过“过程组”的横向和纵向分析，我们可以推导出下面的图（部分示意）：

  这部分我们可以视为系统模块视图，你也可以将这部分与上一部分结合，提供一个总体的业务架构图。注意每一部分所在的纵向拆分区域。

#### ***\*业务流程\****

  该步主要是针对第二步，细化业务流程。以上一步中的“订单管理”为例：

  

  通过图可以发现，它将订单管理做了进一步的拆解，这个层面我们可以将其视为每个模块提供的服务。

  还需要注意，通过从产品、模块到业务服务的分解，我们需要逐步识别参与人及其在每个系统中的角色。如产品管理，企业运营人员是否可以操作？合作伙伴是否可以操作？它们分别是通过哪个系统进行操作？这会影响最终的系统实现方案：是在产品系统中提供多种角色限制还是将产品作为服务提供给合作伙伴系统。

  在这一级别，我们已经可以以业务过程的形式描述一些核心功能，如订单处理：

![x](D:\Owf\IT\Resources\st002.png)

 

  注意它们在每个系统中的分解（不同背景色），这会影响业务边界的确定以及各系统服务的发布。

  当你的业务系统需要对企业外部组织提供服务时，这个流程也可以用于映射你的业务过程编排工作。

#### ***\*操作流程及详细流程\****

  你还可以针对业务流程中的每一个节点再进一步分解（这也是必须的，作为服务实现的依据）。

  如上一步的“订单创建”，我们需要详细描述创建的步骤，需要记录哪些关键数据，做哪些完整性校验等等，此处不再赘述。

  通过这种逐层分解，我们很容易明确每个产品、产品中每个模块、模块中每个服务的边界，以及它们是如何协作的。通过这种协作，我们支撑了系统哪些业务过程。

  只有这样，我们才会知道业务过程有没有缺失，能不能有效支撑企业业务的开展。当业务过程变更时，我们也会更有效的将其分解为各个产品、模块以及服务的变更，以风险和影响范围可控的方式。

### ***\*数据架构松耦合\****

  说实话，数据架构松耦合这个词听起来还是有些抽象，如果换句话说数据拆分，估计就具像的多。但是我们说数据拆分只是数据架构松耦合的一部分内容，而且是偏应用架构层面更多一些。

  数据架构的松耦合需要包含两个方面，一个是数据模型的松耦合，体现在业务过程各个环节流转数据的解耦，一个是数据拆分策略，这体现在对共享数据的处理方式。

  前者决定于业务模型的分析能力，后者决定于技术架构及部署架构的复杂度以及是否满足用户需求。

#### ***\*数据模型松耦合\****

  数据架构中，数据模型的分析与建立与业务架构设计是同时进行的，如果在业务架构完成之后，孤立的进行数据架构设计，那么就很难达到预期。

  当我们进行数据架构设计时，也需要与业务架构一样，进行逐层分解，这样有助于让我们发现数据域的边界，而数据域的边界则是我们需要解决耦合的地方。

  考虑一下业务过程的分解，我们就会很容易得出在产品、模块级别数据模型的边界，并且完成对核心模型的逐步细化。例如：

l 在“业务活动”阶段，我们得出的核心模型是产品、客户、库存、供应商/合作伙伴、服务等。

l 在“过程组”阶段进一步细化，如客户又细化为：客户基本信息、账户、订单、账单。

l 在“核心过程”阶段，客户订单又细分为：订单基本信息、订单项、订单操作记录、支付记录等等。

  通过这种方式，我们可以形成能够导出为数据结构设计的输出结果。重要的是这些业务模型的边界很清楚，不会导致管理混乱。

#### ***\*数据拆分\****

  数据拆分这部分相对比较难描述，在这一阶段理论上不应该规定具体的技术方案细节，如采用文件还是采用共享数据库，是否考虑对数据库做垂直拆分或水平拆分，采用什么样的主键策略。这些应该放到应用架构去考虑。

  该部分的侧重点还是要与业务过程结合。需要确定哪些数据需要共享，共享的边界是什么：产品间、产品内、模块内。实际上绝大多数考虑的应该是产品间的数据共享问题，因为基本上产品内的数据是共享的，除非你倾向于更细粒度的组织你的系统。

  除了共享数据，还要考虑数据冗余（这是另一种形式的共享），如供应商订单是否需要冗余客户信息，如何冗余，当客户信息发生变更后如何处理，这会影响到后续的接口设计，需要提前明确下来。

  通过合理的共享、冗余以及更新策略，确保数据模型之间的独立性，实现系统之间的拆分，以便从数据上实现松耦合。

### ***\*小结\****

  本节简单讨论了一下业务架构和数据架构的分层处理。通过对业务架构的逐层分解，可以明确业务过程边界，以可控的方式管理及演进业务过程，实现业务架构的松耦合。在业务过程分解的过程中，可以同步对数据架构进行分解，明确数据边界，实现数据架构的解耦。

 

## 第02课：技术架构松耦合

### ***\*概述\****

  技术架构（此处我们单指作为应用系统基础的技术平台）对于研发维护多个软件产品的企业并不陌生。它试图解决企业内部技术复用、提升研发效率、规范研发质量的问题。

  对于技术复用层面，除非是架构类型相差很大的软件产品（如企业信息管理系统与大数据分析系统），否则绝大多数公司更倾向于使用已有的技术框架来开发新的产品。这可以大大降低初期的技术成本。对于已经熟悉的框架，也不存在过多的学习成本（API 层面）和适应成本（规范层面），有助于开发人员快速投入开发工作。

  由于开发人员已经非常熟悉当前的技术框架，再加上针对相似的产品有丰富的面向业务的封装组件，这些组件通常易用、业务切合紧密，已经经过许多项目检验，非常健壮，这会大大提升开发人员的工作效率。

  此外，一个成熟的技术框架，一定在代码规范层面定义了良好的约束，使得代码更易维护。使用已有框架的好处就是，这些好的约束可以继承过来，开发人员已经熟悉了这些约束，不会有任何不适。

  以上都是一个通用的技术框架的好处，而且从中我们不难发现一个技术框架所包含的内容。

l 对于各种选型框架的集成。如 Spring MVC 与 Apache Shiro、MyBatis、Thymeleaf、Activiti 等的集成。

l 针对各种选型框架，提供相关的业务封装组件。如常见 CRUD 的封装、JSP 标签或者 JS 组件的封装、图表的封装。

l 提供软件开发规范及约束。如各层 API 的命名、配置文件的命名、参数命名等。

  这些都是比较常见的一个技术框架所包含的内容。但是在构建技术框架时，我们会面临与构建一个业务系统同样的问题，而这些问题却并不总是按照业务系统的构建思想来看待它。

  比如模块化，笔者接触到许多公司，对于技术框架还是以一种比较原始的方式来进行管理，即便他们对待业务系统时，习惯性的考虑如何划分子系统和模块。

  本文中，笔者尝试结合业务系统以及部分成熟框架的模块化方案，来探讨一下与松耦合技术框架相关的内容。

### ***\*技术架构起步\****

  当开始搭建一个通用的技术架构时，它最常见的结构可能如下图所示：

  这是一个集成了很多第三方框架的技术平台，它可能已经满足了很多业务系统的开发需求。

  但是作为一个公司内部的通用平台，显然它需要做的不止这些。因为我们除了要在技术框架集成层面做到复用，以避免每个项目重复这部分工作外，还要尽可能的提升开发效率。而提升开发效率通常有两种途径：

l 封装各种组件，减少功能开发中的重复性工作。如 JSP 标签库、JS 组件库、通用数据访问组件等。

l 提供手脚架，自动生成部分代码。最常见的是针对 ORM 自动生成持久层代码，当然也可以针对几种常见的页面布局，提供自动生成代码的机制，甚至对于诸如对象增删改查这种常见的管理功能，生成从前端到后端的全部代码。

  对于技术重复性工作，可以通过手脚架来解决，而对于功能重复性工作，则应通过封装各种组件来处理，以提升代码的可复用以及可维护性（但是需要保持封装组件的可扩展性，以便应对定制化需求）。

  ***\*注解：\****所谓“技术重复性”，指的是那些技术实现上相同或相似，但是具体数据不同的工作场景。如为不同的两张数据表生成 ORM 映射。所谓“功能重复性”，则是指在功能实现上相似的工作场景。如尽管是展现数据不同的两张表格，但都要设置分页条数、表头样式、单元格编辑器等。

  因此，进一步完善的一个技术框架如下图所示：

![x](D:\Owf\IT\Resources\st003.png)



 

  在 Ruby On Rails 刚诞生那几年，在 Java 平台，也出现过几个手脚架项目，如 AppFuse（2016 年已停止维护）、Spring ROO 等。作为 Web 应用快速开发框架，它们的特点是，集成了基本的 Web 应用所需的技术（当然要比上图中的少很多），提供了从前端 JSP 至后端 ORM 的自动化生成。换句话说，不需要编写一行代码，即可实现对某个对象的管理功能。它们基本符合一个 Web 开发框架（或者成为平台）的定义，但是考虑到其适用人群，它们都是尽可能只做通用性的集成。但是作为企业开发平台，却往往包含对一些特殊框架的集成处理。

  除此之外，对于带有手脚架的开发框架，还要考虑如何将手脚架代码与通用组件分离，避免手脚架代码与所开发项目代码耦合，因为它们只是辅助开发的组件，并不需要包含到发布包中。

  这样的一个带有手脚架的开发框架，可能在一段时间内会满足大多数项目的快速开发，如果你幸运的没有遇到以下问题。

### ***\*随之而来的问题\****

  对于企业开发平台，最初，它可能只包含仅有的几个基础功能，如容器、数据访问、事务、安全认证、MVC 以及模板引擎。但是随着业务系统功能需求的增加或者其所支撑的业务系统数量的增加，这个技术框架会越来越复杂，集成各种各样的技术组件。

  如某个业务系统需要支持消息处理，那么便在框架中引入了 Apache ActiveMQ。如系统新增了批处理的需求，便又增加了 Spring Batch 的支持。如某个系统需要存储大量图片，那么我们就要考虑分布式文件系统，如 HDFS、Fastdfs。

  随着技术集成的日积月累，最终的样子（也许还会更复杂）会像上图中所示，它成了一个大而全的平台。也就是说从技术需求角度考虑，它是相对完善的。但是它却面临一个严重的问题——如何松耦合。

  它对于公司内所用到的技术无所不包，这个庞然大物不但厚重而且不稳定，稍不留神就会出现不可预料的缺陷。比如，也许一个业务系统并未使用工作流，但是却因为缺少了某个工作流的配置（也许是个非常简单的配置，但是每个系统却都要配置一下，无论需不需要），而导致启动失败。

  这种匪夷所思的问题对于业务系统开发人员来说是极度崩溃的，他们无法处理这些莫名其妙的问题，只能再反馈给平台的维护者。这就与测试人员发现一个需求的变更竟然导致一个毫不相关的功能出现致命缺陷一样，简直让人无法理解。

  还有就是各种依赖冲突问题，会发现由于 Spring 依赖的日志框架与 Hibernate 的版本不同，导致项目无法启动或者日志输出异常。

  也许有人觉得这种情况不可想象，基础框架怎么可能会糟糕成这个样子，可现实就是还有很多公司仍采用这种原始的方式进行基础框架搭建。可能是团队技术能力的问题，也可能是公司研发投入成本不足。

  不仅如此，我们还会面临另一个问题。也许不同的项目在少数几个组件的选型要求上会有所区别。如对缓存的选择，是 EhCache 还是 Memcached，具体到应用场景，有时候我们确实很难一刀切的规定只能用其中某一种。如果强制规定，要么是人为的增加了简单应用的复杂度，要么是降低了复杂应用的质量。这个时候，更好的方式可能是两种方案都集成，但是由项目具体选择使用哪一种。

### ***\*如何解决\****

  很明显，针对上面描述的问题。首先，多余的框架不应包含到项目中来。也就是说，如果我的项目没有批处理的需求，那么就不应该有 Spring Batch 的相关包，更不应该有与它相关的配置。其次，要支持在同类型（当然是有限的几种）框架中选择一个最适合当前项目的可选项。

  可以先来看第二个问题，这个相对比较简单。我们不妨看一下 Spring，Spring 最早集中于提供 IoC 的解决方案，因此对于一些成熟的第三方框架，它会提供相关的集成方案，以便直接在实际项目中使用。

  而且 Spring 对于同类型的框架，提供了风格一致的集成 API。也就是说，基本上不需要了解各种第三方框架的 API，而是通过一套类似的 Spring API 来使用这些框架。如针对数据访问层提供的模板类，无论是 Hibernate、JDBC 还是 Redis，它们的 API 都非常相似，易学易用。而且 Spring ORM 同时提供了对 Hibernate（多个版本并存）、Jdo、JPA 的支持，Spring Data 更进一步提供了对多种数据存储平台的支持，如 RDBMS、NoSQL 等。除了模板类外，Spring 对于功能相同、实现不同的各种组件还提供了一致的工厂类，如各种远程访问工厂。在实际项目中，我们可以任意选择其中的一种实现，而且使用配置极其相似，即便将来需要替换，成本也不会很高。

  对于每种框架的集成代码，Spring 的处理方式也不相同，我们可以视情况而定。如 Spring ORM 中，所有框架的集成都放到了一个包中，这样无论你是否使用 Hibernate，项目中都会包含这些类。而 Spring Data 的处理方式则更清晰一些，它对于每种集成方案拆分为一个包，你只引用需要的 JAR 包即可。因为集成代码相对第三方框架的代码毕竟数量要少得多，所以并不是主要问题。如果你的集成代码只有几个类，完全没必要单独发布为一个包，而如果你的集成代码相对数量比较多，则可以考虑按集成框架进行拆分（当然，数量并不是是否拆分的唯一因素）。

  所以，对于这个问题，一个关键点是，对于同类框架如何提供风格一致的 API，以便业务系统开发人员易于学习使用、减少迁移/变更成本。

  对于第一个问题，解决起来则要复杂一些。在 Spring Boot 等出现之前，更多的解决方式则是对平台按照集成的各种框架进行模块化拆分。

  我们继续拿 Spring 作为例子（毫不夸张的说，Spring 可以作为 Java 平台的一款教科书式的框架），它以 IoC 作为载体，将整个框架划分为多个模块，如 MVC、ORM、JMS、JMX 等等。你可以选择只将其中的某几个模块添加到你的项目中。同时，还需要添加这几个模块的依赖包。如果采用 Maven 或者 Gradle 等进行项目依赖管理，这个过程会简单的多。例如 Maven2，它支持传递性依赖，这样我们项目在引用这个模块时，就不必再关心它依赖哪些第三方包了，否则这将是一件比较折磨人的事情，因为你不可能总是记得清楚编译阶段依赖哪些包，运行阶段依赖哪些包，除非你已经在项目环境中开发了一个简单的功能并运行成功。

  模块化拆分加上传递性依赖，可以初步的实现技术框架中各组件的松耦合管理。当然，这种松耦合是指使用上的，而框架发布还是需要统一进行，否则容易导致依赖的第三方框架版本冲突的问题。

  通过这种方式进行管理的技术框架架构如下图所示（技术集成我们只是列举了很少一部分作为示例，以下图例同）：

   ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps11.jpg)

  当然，我们说，这只是框架演进的开始，下面继续。

### ***\*借鉴 Spring Boot 的思想\****

  通过诸如 Maven 等管理工具，我们可以方便的对技术框架进行模块化管理及使用，但是这种组织形式还是以单个 JAR 包为主，但有时候粒度相对大一些反而更方便。

  为什么这么说呢？因为项目中使用时基本上不是以单个模块进行添加的。比如，技术框架以“Spring MVC+模板引擎”的方式提供 Web 开发支持。此时，对于 Spring MVC 的集成和对于模板的集成需要拆分为两个模块，因为我们可能提供多种可选的引擎。而在实际项目开发中，则更希望指定一种组合式的依赖，而不是分别指定 Spring MVC 和模板引擎。

  很多用过 Spring Boot 的人，都说它是“傻瓜式”的。这是因为它屏蔽了绝大部分的集成细节，通过优秀的依赖管理，使得模块化添加非常自然便捷，不必担心依赖冲突等问题，更不必逐项添加你所依赖的 Spring 模块。

  只需要在项目的 pom.xml（以 Maven 为例）文件中添加各种 starter 即可（如 spring-boot-starter-web）。如果使用 springsource 提供的 STS 作为开发工具，那么可以直接使用该 IDE 创建 Spring Boot 项目。

![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps12.jpg) 

  上图是通过 STS 创建一个 Spring Boot 项目时的可选的 starter，可以说它涵盖了非常广泛的、各种用途的第三方框架的集成。

  在 Spring Boot 中，这些 starter 也是一个 Jar 包，它包含了一个 pom.xml 文件，声明了其所依赖的 Spring 模块、第三方框架及其版本。下图是 spring-boot-starter-thymeleaf 包含的 pom.xml，它依赖 spring-boot-starter 和 spring-boot-starter-web 两个 starter 和 thymeleaf 包。

![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps13.jpg) 

  使用时只需要简单选择自己希望使用的 starter 即可，完全不需要关心它的依赖问题。也就是说，通过这种方式，我们可以灵活组装自己的基础技术框架。

  而且在特定的 Spring Boot 版本内，第三方框架的版本肯定是统一的，不必担心存在版本冲突的问题。

  按照这种思路可以在自己的技术框架中，将完成特定功能的一组模块定义为一个单独的 starter（没有想到更好的名称，暂时也使用这个称谓），这样只需要在项目的 pom.xml 文件中添加该 starter 依赖，而不需要添加任何模块或者第三方框架的依赖。如下图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps14.jpg)

  由图可知，我们的技术框架分为以下三层。

l 第一层：以第三方框架为基础；

l 第二层：对于各种集成方案进行模块化；

l 第三层：同时进一步将模块进行依赖整合，便于项目引用。

  我们的集成代码完全集中在第二层，而第三层仅仅是出于依赖管理的需要。

  我们的 starter 可以结合架构类型等来划分，如 Web 应用、SOA 应用、批处理应用等等。而 Web 应用则包含了我们要使用的 MVC 框架、模板引擎、持久化框架等。如果支持对模板引擎或者持久化框架的选型，那么可以针对 Web 应用提供多个 starter，如 thymeleaf-jpa-starter、freemarker-mybatis-starter。

  在这种情况下，我们的技术框架完全由 Maven 进行管理（可以搭建 Maven 私服），不必提供一个全集的技术框架发布包。新建项目时，按照包含的应用类型添加对应的 starter 即可。

### ***\*静态文件的管理\****

  对于技术架构部分，我们前面谈到的几乎都是如何有效的对第三方框架和集成代码（服务端）进行管理，而对于企业级开发框架，还忽视了一点，就是对于静态文件的管理，如第三方 JS 库、公司封装的 JS 库、CSS 框架等。显然，这些是无法按照前面的方案进行管理的。但是，尽管如此，最终的使用方式还是希望像前面讲解的一样简单，而不是手动复制文件和目录。这时候可以通过 Maven 的 archetype 来解决。

  针对我们要提供的应用类型，创建不同的 archetype。对于每种 archetype，创建静态资源目录，复制相关的静态文件，如富网络应用、Web 应用、移动 Web 应用等。假如创建的是一个复合应用（如富网络应用+SOA），那该怎么定义？没关系，现在主要解决的是静态文件管理的问题，对于未包含的，完全可以在 pom.xml 中添加其对应的 starter 即可。

  当我们按照前端的分类创建了各种 archetype 后，搭建项目环境就会变得更加简化，尤其是使用 STS 等 IDE 时。我们只需要选择合适的 archetype，便可一键创建项目的工程目录，它包含了我们想要的前端静态文件、所有依赖的第三方框架以及集成代码，它已经完全是一个可以正常运行的环境，而且不包含任何多余的我们不需要的内容。

  加入 archetype 后，我们的技术框架如下图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps15.jpg)

### ***\*手脚架\****

  最后我们再谈一下手脚架，尽管很多人认为自动生成的代码维护起来比较麻烦，但是不可否认它会显著提升我们的工作效率。例如对于 Java 语言，如果稍微研究过 Eclipse JDT，那么完全可以结合公司代码规范、技术框架的 API，开发出自己的手脚架。如 Spring ROO 一样，我们可以通过各种命令以及命令选项，控制生成的内容，如 ORM、控制层、展现层。

  如前所说，手脚架只是一个辅助开发的工具，它不应包含在项目的发布包中。可以通过以下几种方式提供手脚架。

l IDE 插件：无论是 Eclipse，还是 NetBeans 等 IDE，都支持插件机制。通过开发一个独立的插件，我们可以在 IDE 中直观的选择配置并生成代码，而且这种方式不会对项目造成污染。

l 独立的手脚架目录：当创建项目工程时，单独建立一个目录用于存放手脚架代码。这种方式会对项目造成污染，尽管它不会最终包含在发布包中。而且这种方式只能通过命令行进行操作，与 IDE 的结合较差。

  至于手脚架可以包含哪些内容，只要是我们认为有助于减少开发人员工作量的工作都可以包含进来。它不像技术框架的组件，并不会影响最终的项目质量。只要项目开发人员认为自动生成的代码有问题，他完全可以基于自动生成的代码进行修改，以符合自己的需要，甚至也可以暂时不使用相应的命令，等待它们变得更加完善，而并不会阻塞项目的开发进程。

  当然，如果你正在开发一个手脚架，还需要注意手脚架生成代码与项目代码冲突的问题，避免由此导致的代码覆盖。例如对于一个自动生成 ORM 代码的手脚架，如果使用者在实体类中添加了自定义方法，那么后期 ER 变更需要同步更新实体类时，是否会直接覆盖这些自定义方法？当然，这个问题还会存在于可视化开发界面的一些工具中。你应该对于自动生成的代码进行良好设计，如预留自定义接口，以避免这种情况，使得即支持自定义代码扩展，又可以对自动化部分进行多次同步更新（***\*即自动生成的代码与自定义代码松耦合\****）。

  添加了手脚架的技术框架如图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps16.jpg)

  在图中，我们为手脚架设置了不同的背景色，表示它不作为项目的一部分。

### ***\*小结\****

  对于技术架构的松耦合，它与业务功能的松耦合出发点并不完全一样。它更多体现的是一种 API 设计方法和模块化管理方式。通过风格一致的 API，降低研发人员的学习和使用成本，使组件易于替换。而通过模块化的管理方式，则可以使得项目开发环境的搭建大大简化，使开发人员不必关注各种依赖问题。

## 第03课：开发架构松耦合

### ***\*概述\****

  “开发架构”这个称谓对于有些人来说，可能使用“开发视图”更容易理解。总之，根据前文的讲解，应用架构包含了我们通常理解的架构视图的绝大部分，除了进程、部署等视图。

  无论称谓是什么，这里专指的应用系统在开发环境中的静态组织结构，也是项目开发人员具体的工作环境。因此这部分的松耦合与项目开发人员密切相关。

  谈到开发架构的松耦合，主要包含两方面的内容：

l API 依赖的松耦合。

l 项目模块（工程目录）的松耦合。

### ***\*API 依赖的松耦合\****

  实际上，在开发阶段，绝大多数人接触到的松耦合基本属于这一类。无论我们读过的代码设计相关的书，还是实际工作经验，又或是来自一些支持 AOP 的第三方框架的约束，这些都会促使我们按照一种良好的松耦合的方法来编写代码。如面向接口、继承、多态以及各种相关的设计模式等等。对于如何编写松耦合的代码，本文不再展开过多论述，相信阅读过诸如设计原则、设计模式之类书籍的人并不难做到。本文主要侧重于探讨针对我们编写的模块，如何处理模块之间松耦合的问题。

  首先，我们开发的绝大多数应用是分层的，如常见的 Web 应用分为展现层、服务层、持久层。应用分层便会存在层与层之间依赖的问题。诸如 Spring 等框架，通过依赖注入，使得层与层之间的依赖实现了松耦合。

  层与层之间的依赖注入，可以有两种形式。

l 面向接口：也就是说层与层之间通过接口实现松耦合。上层模块根据配置在容器中查找接口的实现，下层模块需要实现接口并注册到容器中。这种方式，接口成了层与层之间的耦合点，接口的变化会同时影响上下层。

l 面向代理：也就是说层与层之间不再有接口上的耦合。上层根据需要，定义一个接口代理，这个代理会自动查找下层模块的实现。下层模块不必实现相关接口（注意：这并不代表它不需要实现任何接口，而是不需要实现与上层耦合的接口），只需要在容器中注册即可。这种方式的好处是不存在接口变化的影响（尤其对于 Java 这种编译型语言）。但是它会产生更细粒度的依赖，如方法，因为至少需要在上层的代理中指定下层的组件名、方法、参数等信息。当然，如果下层模块方法实现的足够健壮（如充分考虑方法版本的兼容性），这种问题会减少很多。除此之外，面向代理的好处还有就是透明的切换下层组件的访问方式（本地、远程）。当然，这种方式与面向接口相比实现起来会复杂一些。

  其次，即便位于同一层中的各个模块（如服务层），也存在相互依赖的问题，比如订单服务需要访问客户服务获取客户资料。这种情况的解决方式应该与层与层之间的依赖类似。

  同一层各个模块之间的依赖（尤其是服务层）相对比较复杂的地方就是，对于传输对象的处理。举个例子：订单服务需要调用客户服务获取客户资料，积分服务也需要调用客户服务获取客户资料。那么对于客户服务返回的客户资料传输对象，便会形成一种模块间的耦合关系。

  对于这个问题，有不同的解决方式，并没有绝对的对与错，随着项目的不断迭代以及新出现的依赖方面的挑战可以不断修改处理的方法。总体来讲，可以有三种。

l 将每个模块发布服务的传输对象单独打包，依赖该服务的模块只需要依赖该传输对象的发布包即可。

l 将项目中所有模块的传输对象合并打包，各模块都依赖这个传输对象包。这是第一种方案的“懒惰”版，毕竟如果模块数量非常大时，管理工作量会比较大。当然这种方式的缺陷也很明显，是与模块化方向背离的。

l 每个模块使用自己的传输对象。这种方式只适用于那种弱依赖的远程调用（像本地调用、Spring Http Invoker 这种强依赖调用是不可行的）。也就是说，当模块调用外部服务时，按照自己使用的数据，定义传输对象。这种方式是耦合性最小的方式（部分讲解微服务的书也提到了这种处理方式），因为我们不需要关注服务发布方的全部数据，而是按需获取。当然这是一种很理想的服务调用方式，但是现实却是很多数据在多个模块之间是重复的。对于上面的例子，也许无论订单还是积分，都需要获取客户的名称、地址、联系方式等信息。结果就是，在这些模块的传输对象中，你都需要重复包含这些信息。

  如果认为传输对象重复定义是不可忍受的，那么可以选择方案一，如果项目这种情况并不多，那么可以选择方案三，如果认为合并到一起不是什么大问题的话，方案二也可以使用，即便后期需要拆分，这也并不难做到。

### ***\*模块的松耦合\****

  首先承认，这个标题并不合适，因为模块的松耦合也包括“API 依赖的松耦合”，但是我始终没有想到一个合适的称谓来描述它。

  通过讲解一个实际的工作场景，可能会更好的理解这个问题。设想我们的系统相对比较庞大，从前端到后端被拆分成了许多模块，如果在开发过程中我们想测试某个模块的功能（从前端到后端）。你喜欢仅仅启动测试模块及产生 API 依赖的模块，还是说你原意将整个系统启动起来？很明显，相信绝大多数人会选择前者。如果每次测试都要启动整个系统，那么开发测试的效率将会非常低，不仅仅是因为系统启动更加耗时，还因为其他模块可能存在缺陷（因为同时处于开发过程中，出现致命缺陷的概率非常大）导致系统无法正常运行。

  再考虑一个工作场景，实际上无论是 B/S 还是 C/S 结构的系统，无论我们最终将应用系统部署到服务器还是将服务器作为一个组件嵌入到应用当中，本质上来说，它还是遵从了 Servlet 规范（当然，此处指绝大多数，而不是所有）。虽然 Servlet 规范提供了多种模块化机制，但是它的入口却只有一个，即 web.xml 描述文件。如何将 web.xml 中的配置，以注解或者 web-fragment.xml 的形式分解到各模块中，也是实现松耦合的关键。

  我们也可以将上面的两个场景作为模块松耦合目标的一部分。而且这个层面的松耦合更有助于我们将系统向更细粒度的部署架构方向演进。可以说，这种方式已经距离微服务架构一步之遥，而且由清晰的模块化架构到微服务，这种循序渐进的架构重构更易成功实现微服务化治理。不仅如此，你还会发现，这种架构极易回退，如果你认为微服务并不适合你们。

  我们至少有两种方案可以实现将模块独立运行。第一种是采用 Servlet 规范的模块化机制，第二种是采用诸如 Spring Boot 的方式。

  我们先来看第一种。

#### ***\*Servlet 规范\****

  Servlet 规范支持应用配置的模块化和可插拔，主要分为三种方式：

l 注解

l SCI

l web-fragment.xml

  这三种方式都可以用于实现模块之间配置的松耦合，尽管它们的实现方式有所区别。

  对于注解的方式，我们需要在每个模块中定义自己的 Servlet、Filter 并添加相应的注解，用于分发处理当前模块的请求，以代替原有 web.xml 中的配置。理想情况下，web.xml 中不保存任何配置（由于应用服务器都会提供默认的 web.xml，因此项目中甚至可以不需要该文件）。

  这样，每个模块都变为一个可部署的 Web 应用（暂时不考虑静态文件，接下来会单独讨论）。模块与模块之间，除了必要的 API 层面的依赖，不会存在任何配置依赖。

  当然，实际情况可能要稍微复杂一些。例如设置请求/响应编码、安全认证，这些通用 Filter 我们更希望统一配置，而不是每个模块都要配置一次。此时，可以单独保留一个通用的“门户”模块，用于保存系统的这些基础配置。这个“门户”模块与其他模块并没有任何依赖关系，只是提供了请求映射层面的基础功能，因此它是可以轻易替换的。

  如果你使用的是一个来自第三方框架的 Servlet 实现，此时使用注解并不是一个好的选择（除非你愿意实现它的一个子类或者装饰类，以便添加注解）。

  此时，可以使用 @WebListener 注解，以编码的方式添加 Servlet，或者采用 SCI。

  SCI（ServletContainerInitializer）基于 SPI 机制，以编码的方式添加 Servlet、Filter。与注解相比，它扩展性更好。

  这两种方式都能在脱离 XML 的情况下，实现 Web 应用配置的模块化。如果你不希望 Servlet API 侵入每个模块，那么可以考虑 SCI 的方式。以通用模块的方式提供 SCI 实现，并自定义扩展机制，每个模块根据自定义的扩展机制声明自己的配置。

  最后是 web-fragment.xml，作为 web.xml 的片段，它与 web.xml 格式完全相同，完全是对 web.xml 内容的拆解。尽管在规范中，它支持加载顺序，我们还是建议不要使用该特性，而是要合理的划分各模块的请求地址，因为这种加载顺序的定义，也会造成模块间的依赖。

  这三种方案，你可以进行灵活选择，甚至混合使用（尽管我们建议只采用其中一种），这都不是关键问题。这一部分内容的一个关键点是你如何合理拆分各模块的请求，最好是通过开发规范的方式进行明确，以确保各模块之间独立开发而又不会重复。尤其是原有系统请求采用集中式处理的情况下（使用一个 Servlet 作为所有请求的入口）。

#### ***\*Spring Boot\****

  对于基于 Spring Framework 的 Web 应用来说，Spring Boot 提供了一种很好的模块化方案，或者换句话说，它本身就是高度模块化的。

  Spring Boot 通过自动构造嵌入式 Web 服务器和 Spring 容器，使得应用可以独立运行，而不需要部署到 Web 服务器中。也就是说，对于采用 Spring Boot 开发的程序，它的启动方式与你通过 main 方法启动任何 Java 程序是一样的。因此，我们可以为每个模块添加一个 main 方法，即可实现模块的独立配置。

  如果所有模块的配置都是一样的，我们甚至可以只在一个通用组件里加一个 main 类，无论是独立启动一个模块，还是启动整个系统，我们都使用这个通用组件作为启动入口。

  当然，你可能会疑惑，既然使用 Spring Boot，为什么不直接按照微服务这种架构设计系统，还要考虑统一启动的场景？我们说，对于微服务这类架构，更多是一种业务层面的驱动，从技术架构上我们则要考虑系统架构的适应性和灵活性。还有就是我们的系统除了服务还有 UI，如果它们也各自以独立的方式运行，这将会使系统复杂度大大增加。

Spring Boot 这种方式使得你可以像管理普通的 Java 程序一样管理 Web 应用。但是从本质上来说，它仍是通过前面所述的 Servlet 规范的机制实现的。只是 Spring Boot 屏蔽了 Web 容器的复杂性，使你可以像开发普通 Java 程序一样开发 Web 应用，并且在此基础上定义了自己的扩展机制以及默认配置，而使你不再需要再关注与 Web 容器相关的配置。

我们之所以将 Spring Boot 单独说明，是因为它与前面讲的基于 Servlet 规范的方案稍有不同，主要体现在：

· 前者以部署包的形式部署到 Web 服务器中，而后者是一个独立启动的程序。

· 前者存在对 Servlet 配置的分解，而后者是由 Spring Boot 自动装配（每个进程一个）。

  除此之外，Spring Boot 还很好的解决了静态文件的问题，下面我们会进行说明。

  资源文件处理

  首先，我们此处所说的资源文件，是指除 Web 应用中除 Java 代码以外的所有文件。它通常包含 JSP、各种模板文件（如 FreeMarker 等）以及静态文件（如 HTML、JS、图片、CSS 等）。

  如果你开发的是一个 SOA 应用或者 C/S 系统的服务端，应该不需要考虑资源文件在模块化过程中所造成的影响。但是，如果你开发的是一个 Web 应用，这却是需要加以考虑的一个问题。

  既然我们的代码按照业务耦合程度拆分成不同的模块，那么我们自然希望与之相关的资源文件也应该被拆分到相应的模块，而不是被放置到一起。

  当我们基于 Servlet 规范进行模块分解时，每个模块是一个可以独立发布到 Web 服务器的应用，因此它自然可以维护只与自己相关的资源文件。只不过这里需要考虑两个问题：

  （1）共用的文件，如 CSS 以及第三方 JS 库如何处理。

  （2）多个模块一起启动的问题。

  对于问题（1），建议将共用文件放置在一个单独的服务器上，各模块直接引用远程链接，而不是放置在本地。系统最终构建时，将这些文件包含进来即可。

  对于问题（2），在集成测试阶段还是比较常见，毕竟独立启动多个模块要更复杂一些，效率相对较低。

  但是部分 IDE（如 Eclipse）只支持将依赖项目以 JAR 的形式部署到当前的应用，而不支持对资源文件的处理。例如，有两个模块 A 和 B，当启动 B 时将 A 添加为依赖项目，此时，A 会作为 JAR 添加到应用 B，但是 A 中包含的资源文件却无法一并包含到应用 B 中，因此你是无法同时测试两个模块的页面的。

  当然，笔者并未尝试过其他 IDE，如果你正在使用的 IDE 支持对资源文件的归集，那么恭喜你。

  对于这个问题，解决起来也并不复杂，可以尝试以下方案：

l 将资源文件改由通过类路径加载，而不是存储目录。这是 Spring Boot 采用的方式。由于应用服务器（如 Tomcat）默认通过存储目录查找资源文件，因此需要实现自己的 Servlet 用于处理 JSP 以及静态文件。在 Spring Boot 中，所有请求均通过 DispatcherServlet 处理，通过为资源文件注册单独的 HandlerMapping，以支持通过类路径加载资源文件。在这种方式下，资源文件与 Java 类文件都会被包含到 JAR 包中，并无二致。

l 不使用 IDE 的自动部署功能，通过 Maven 等工具进行构建测试。在这种方式下，对于资源文件的修改，不能做到实时刷新，便利性大打折扣。

l 如果你熟悉 JDT（仅针对基于 Eclipse 的 IDE），可以扩展 IDE 的自动部署插件，使其支持合并部署。该方案具有一定的技术门槛，实践起来并不划算。

  比较之下，方案一实现起来最简单，同时也更便捷。当然，出于优化系统访问性能的考虑，静态文件更倾向于单独部署到前置 Web 服务器（如 Nginx）上。此时，只需考虑 JSP 以及各种模板文件的处理即可。

### ***\*小结\****

  对于开发架构的松耦合，主要体现在如何解决 API 依赖以及模块产出物（代码、配置、资源文件）的分解上。这种分解便于模块以更轻量级的方式运行，有利于系统整体架构向轻量级架构转型。

  如果你正在尝试将当前系统重构为微服务架构，不妨先尝试如何做类似拆分，这种拆分一定是由业务进行驱动。当你的系统以松耦合的模块化架构运行无碍后，微服务架构便已是一步之遥。

## 第04课：部署架构松耦合

### ***\*概述\****

  当下微服务架构风头正劲，它对系统服务按照业务进行细粒度拆分，每个服务以独立进程的形式启动，以便在架构上提供更好的伸缩性和有效性。

  微服务架构使得我们可以轻易对某个服务进行版本升级、扩容，一个服务的崩溃不会影响其他服务正常运行。这些都是微服务架构的优势，但是在获得这些优势的同时，我们需要付出更多的管控成本，因为你部署、维护及监控的应用程序已变为原来的数十倍甚至上百倍。当然，借助现代化的运维工具，这部分工作已不再令人望而却步。

  我们不止一次的说，微服务架构的演进更多是由业务进行驱动。若业务过程不能进行合理拆分，那么它的这些优势便不复存在。业务耦合会使它的伸缩性和有效性形同虚设。

  抛开微服务架构实施的难度，单从部署架构考虑，微服务可谓将松耦合做到了极致。正所谓：“道可为则，各从其宜”，在具体实践中，受限于客观条件（业务过程还不清晰、团队能力跟不上、运维水平达不到等等），我们很难将系统按照理论模型进行构建。这也使得我们探讨如何进行部署架构松耦合变得有意义。

  通过部署架构松耦合的渐进式重构，会在一定程度上提高系统部署的灵活性，使架构在团队可承受的范围内，逐步向理想状态迈进。

### ***\*几种参考\****

#### ***\*PHP内容管理系统\****

  很多人看到这个标题，可能会产生疑惑，但是我一直深信在架构理念上各种系统是可以相互借鉴的，即便是跨语言。

  如果你稍微了解当下流行的几款开源 PHP 内容管理系统，如 Joomla，就会发现它们都会提供内置的模块框架。每个模块通过系统可识别的描述文件进行自我描述。系统自动解析描述文件，加载模块，并对外提供服务。

  这种模块化框架不仅使系统变得极易扩展（你可以自行开发各种模块以丰富系统功能），也在部署运行期间为系统带来了更好的灵活性。

  在系统运行期间，我们可以灵活安装、卸载、升级模块，而不会影响系统中其它模块的运行。

  从架构层面进行概括的话，首先系统提供了统一的应用模块运行环境，并定义了模块的发布规范，其次，系统根据定义的规范识别并加载模块，对模块进行生命周期管理。从这个角度讲，它与 Java 应用服务器有很大的相似性，只是它更面向业务功能而已。

#### ***\*Java应用服务器\****

  我们通常习惯性的认为 Web 应用是一个应用程序，但是从操作系统层面看，它却不是。它只是可以部署到应用服务器中的一种组件而已，它需要在应用服务器的管控之下提供服务。因此，我们可以将应用服务器和部署到它里面的 Web 应用一起视作一个可执行的应用程序。

  如此审视应用服务器的架构，我们就会发现它是一个健壮的、高度组件化的、易于扩展、易于维护的应用程序。

  我们将部署在应用服务器中的 Web 应用视为其提供业务功能的组件，就会发现这个平台有以下优秀的特性：

l 平台提供基础的、业务无关的远程访问服务（HTTP/AJP）。

l 平台自动加载业务组件（Web 应用），并根据其描述文件（web.xml）对远程请求进行分发处理。

l 业务组件之间是完全松耦合的（类加载器的隔离机制），彼此互不干扰。

l 平台为业务组件提供生命周期管理。通过 JMX，我们可以添加、升级、卸载组件，以及对组件配置进行修改。

l 业务组件是可以任意组合的。我们可以将多个 Web 应用部署到一个应用服务器实例下，也可以将其分开部署。

  通过这种架构，我们很容易基于平台和业务组件对运行实例进行定制，对可选择的业务组件进行升级、扩容。

#### ***\*Jetty\****

  我们将 Jetty 这款轻量级 Java 应用服务器单独介绍，是因为抛开服务器对 Web 应用的松耦合管理不谈，它自身的模块化架构也是非常有借鉴意义的。

  在 Jetty 中，各种基础功能（如 http、session、jmx、gzip、jsp 等等）都是以模块的形式提供的。在我们创建 Jetty 部署目录（jetty-base）时，指定需要包含的模块。那么在这个 Jetty 实例运行时，便只包含这几个模块的功能。这种机制使我们对 Jetty 实例的定制变得非常容易，而这与 Jetty 的高度模块化是分不开的。

  Jetty 的模块包含的内容如下图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps17.jpg)

l .mod 文件用于声明模块的依赖模块、包含 JAR。

l .xml 文件用于向 Server 注册本模块的组件。

l .ini 文件用于设置模块工作需要的系统参数。

  当我们使用 Jetty 提供的命令初始化一个 jetty-base 目录时，它会根据 *.mod 文件中的内容，分析模块依赖树，生成模块的 *.ini 配置文件。

  当我们基于这个 jetty-base 目录运行 Jetty 实例时，Jetty 会根据 *.ini 文件确定加载的模块，再依据模块对应的 *.xml 文件创建组件并注册到 Server 上。

#### ***\*OSGi\****

  与 PHP 这一类脚本语言开发的框架不同，Java 语言很难实现模块的动态化管理，或者说成本比较大。

  这主要因为 Java 语言是基于类加载器机制的。我们要在一个类加载器中实现模块的启动、卸载、升级以及依赖管理是不可能的。首先，一个类加载器不允许存在两个限定名完全一样的类，因此无法实现多版本管理，其次，类加载器中的类不是分模块管理的，当卸载或者升级模块时，你无法实时替换类或者移除类（除非销毁整个类加载器并重新创建）。但是，类加载器之间具有天然的隔离性，应用服务器也采用类加载器机制确保Web应用的隔离。

  但实现复杂并不代表不可能实现。OSGi 便是利用类加载器的隔离性，实现的一套动态模块化框架（更准确的说它只是一套规范，具体实现有 Equinox 和 Felix）。本文不打算详细展开介绍 OSGi 规范，感兴趣的可以[参考这里](https://www.osgi.org/)。

  简而言之，OSGi 框架是充分模块化的，体现在几点：

l 每个模块一个类加载器。

l 每个模块可以选择依赖的模块及版本，也可以选择自己对外公开的包路径（不公开的包路径外部无法访问）。

l 每个模块可以独立安装、升级、卸载，不影响程序运行。

l 支持多版本并存，透明实现升/降级。

  当然，OSGi 还有很多优秀的特性，不再一一赘述。

  你可以发现，OSGi 是一个最完善的模块化方案，但是不得不说，在大多数情况下它显得过重。换句话说就是，你没有享受到它的好处，却承受了它的复杂度。

### ***\*我们该怎么办\****

#### ***\*需要考虑的几个方面\****

  通过分析上面的几个参考，我们大概总结一下模块化需要考虑的几个方面：

l 自我描述文件。模块需要一个描述文件以告知运行环境（容器）它提供了哪些功能（包）、版本、依赖哪些模块以及相关的参数配置。运行环境（容器）在启动时，可以根据自我描述文件完成模块的加载。简而言之，需要至少做两件事，告知容器如何加载“我”，告知容器“我”能做什么（需要容器提供相应的机制，便于模块进行服务/功能注册）。

l 支持模块对容器生命周期事件的监听及处理。模块可以根据这些生命周期事件完成一些初始化、注册以及销毁的处理。

l 在系统运行状态下，实现对模块的安装、升级、卸载。这是最灵活也是要求最高的一个特征，当前只有 OSGi 和应用服务器（Web 应用管理）可以做得到。

l 模块之间要有适当的隔离性，避免产生耦合。这个不难理解，大多数情况下我们在开发架构层面已经做了充分的工作。

l 容器负责对模块生命周期进行管理及监控。通过容器监控，我们可以实时获取模块的运行状态，可以在运行状态下修改模块配置。

#### ***\*方案选择\****

  从前面的讲解，我们可以知道，基于 Java 的模块化方案，动态的安装、升级、卸载复杂度是最高的，而这些都需要底层的基础容器完成。因此，我们需要仔细考虑引入这种复杂度是否划算，其带来的收益是否值得。

  对于一些需要持续运行的非集群环境（如车载系统）就必须要考虑动态模块管理的问题，因为你不可能将系统停止进行升级。而对于可集群部署的环境（如常见的 Web 应用），那么我们完全可以将应用停止来进行升级，因此对于动态管理的需求并不突出。而引入诸如 OSGi 这种动态模块化框架所带来的成本则非常大，包括开发、测试、管理及运维监控。它对整体架构的影响甚至比你直接拆分为微服务都要大。

  笔者几年前曾经尝试一种更粗粒度的基于 OSGi 的模块化方案，在这个方案中，数个 OSGi 组件合并为一个模块，系统以模块为单位确定依赖关系，进行生命周期管理。通过监控平台，支持对模块进行动态维护。后来发现在 OSGi 环境下开发系统所带来的成本远远超过了它带来的收益。

  更多的情况下，我们并不是希望动态管理模块，而是只需要做到灵活部署就行了。因此，像 Jetty 这种，通过简单的命令便可以确定当前实例包含的模块，是一种更好的选择。至于模块之间的隔离性，多数情况下并不需要做到类加载器级别。

  对于一款 Web 应用，模块化架构如图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps18.jpg)

  每个模块提供一个描述文件，告知容器它依赖的模块、包含的 JAR 包、支持的属性参数等。

  应用容器在初始化时，根据“配置文件”确定要加载的模块及其依赖模块。如果你的开发架构松耦合做的足够好，已经将 web.xml 去掉，那么可以在应用中添加一个自定义文件，否则，你可以将配置放到 web.xml 中。容器分析依赖路径，得到当前实例需要加载的模块。

  对于模块的加载，则有两种方式：

l 得到加载模块的 JAR 包合集并进行加载。你会发现这种情况下，类加载器是自己维护的，作为 Web 应用类加载器的子加载器（如果你的应用服务器为嵌入式，如 Spring Boot 应用，那么你完全可以避免这一点）。这相当于是你自己实现了一套类加载机制，因此我们并不推荐这种方案。

l 如果你仍希望使用 Web 应用类加载器，那么可以只模块化加载配置文件，对于 JAR 包则全集加载。这种情况，不需要改变 Web 应用的类加载器，但是仍需要平台提供模块解析及加载的功能，会对开发架构的松耦合带来影响。

  除此之外，还有一种方式，就是将模块配置分析的过程放置到部署脚本中，部署脚本根据分析结果创建定制的部署包进行部署。这种方式不需要对应用程序的类加载机制进行改造，实现起来相对比较简单，对开发架构的影响也最小（还有就是它的产出物没有任何多余的内容，无论是配置文件还是 JAR 包）。

### ***\*小结\****

  本文探讨的部署架构的松耦合是在将应用拆分成独立的进程之前的一种中间状态，它比管理多个进程要容易一些，适合对应用按模块灵活组合并以独立实例的方式运行。

  它需要结合前期的开发架构松耦合同步进行，尽可能不改造原有 Web 应用的构架（否则会带来不可预知的管理成本），在符合 Servlet 规范的前提下实现。

  经过这种改造，在没有实现微服务架构的情况下，也可以对系统进行按模块运行以及扩容。

## 第05课：总结

  本文作为该课程的最后一部分，对该课程涉及的知识点作一个简单回顾和梳理。

### ***\*系统架构分解\****

  在系统架构分解这一部分大概讲解了系统架构所包含的内容。当我们审视一个系统时，我们需要知道它的“重要决策”包含哪些方面，每个方面涉及哪些内容，需要以什么样的形式去描述。

  详细介绍每种架构的内容及方法显然已经超出本文的范围，你如果感兴趣可以去了解一下 TOGAF、eTOM，当然还有应用架构的 4+1 视图等，都是我们用来做架构的有效的方法论。

  我们在本教程中一直强调方法论和架构的治理。因为只有做到有效的治理，你的架构才能进行持续的可控的演进，确保在架构演进的同时，系统的健壮性和有效性不受影响。

  还有，你也应该注意到，部分架构知识本教程并未涉及到，如基础设施层，它同样非常重要，也有很多需要关注的问题，只是与本教程主要谈论的松耦合关系不大，因而没有提及。

  还有就是对松耦合的定义，我们一定要从广义上来认识它，在架构的各个方面，都会或多或少涉及到松耦合，有业务上的耦合、数据上的耦合、系统/模块上的耦合、部署上的耦合等等。而我们需要做的就是发现各层面的耦合点，找到合适的解决方案。当然，实际工作中，可能不是由一个人去承担这所有工作，这又需要各个岗位的协调和沟通。

### ***\*业务架构及数据架构松耦合\****

  在业务架构和数据架构部分，我们主要讲了如何分层去划分业务过程。通过对业务过程的分层管理，可以实现以下目标：

l 满足不同利益相关者的需求，如 CxO（诸如 CEO、CIO、CTO 等等），他们并不关注每个服务的详细实现，他们只需要知道核心业务过程的高层分解即可。而对于设计人员和开发人员，他们则需要知道详细的业务流程，通过提供不同层级的视图，可以满足他们各自的需要。

l 使得业务过程变更可控，通过业务过程的分层，我们很容易知道业务过程概貌。当业务过程发生变更时（尤其是核心业务过程），它会影响到不同层级分解视图的变更。通过先在高层视图进行变更评估，然后逐步分解传导到低层视图，这种方式使得变更的影响范围可控。

l 这种逐层分解的过程，有利于你以参与角色、核心过程作为基础，逐步延伸业务过程和数据模型，以提供更完善的功能支撑。因为只有当你对业务过程有一个正确的全局观时，才会做到业务架构的逐步演进。

l 良好的业务分层和管控，会给应用架构以正确的指导。通过正确的业务过程分解，我们会提早发现一些对业务处理和数据的技术性要求。应用架构以此作为目标进行构建，避免后期出现应用架构无法满足（或者通过不断调整才能满足）业务需求的情况。例如，业务分层明确了系统和模块的边界，那么在业务过程中，系统间如何通讯？实时性要求如何？需要哪些数据？这些都可以作为应用架构的参考（通过分析“业务流程”部分的输出结果，我们不难发现各系统都需要哪些接口通讯。）。

l 通过业务过程的分解，我们可以以参与角色、核心模型、核心模型附属模型、边缘模型的顺序推演出我们的数据架构，确保数据架构可以有效支撑业务场景。尤其是在产品初创阶段，这种方式可以有效避免开发过程中频繁变更数据模型。后期的变更不仅极易使得数据模型失控，而且也导致数据架构和逻辑/物理实现不一致。

### ***\*技术架构松耦合\****

  技术架构松耦合主要解决技术架构日益臃肿的问题。尤其在 Java 平台，随着依赖的第三方框架的增多，由第三方框架导致的传递性依赖会使得各种库的版本极易出现冲突。因此看似可以随意组合的主流中间件框架，由于一些通用工具库（如日志、XML、JSON 等）的版本问题，会使得你不断调整各个框架的版本，以期达到一种脆弱的有效性。

  除此之外，我们应该致力于使得产品中的第三方框架尽量精简，去除那些不必要依赖库。这样不仅会大大降低发布包的大小（一个功能很少的产品的发布包都需要几十兆，这是不合理的），也会减少由于不必要的配置而引入系统运行问题的风险。

  本教程主要从两个层面出发：

l 第三方库及集成代码的松耦合管理。通过 Maven 等管理工具，我们可以将经过验证的第三方库和模块化的集成代码划分为不同的应用类型。当构建产品时，根据应用类型，自动完成技术架构的搭建工作。

l 静态文件的管理。主要是如何管理依赖的第三方 JS 库、CSS 等资源。

l 手脚架的管理。严格的说，手脚架不属于产品发布包中的一部分，但是它可以包含在技术架构中简化我们的开发工作，将开发人员从重复、单调的工作中解放出来。

### ***\*开发架构松耦合\****

  开发架构的松耦合主要包含两部分。一部分是我们常见的 API 松耦合，你可以根据自己的具体情况，选择适合自己的方案。

  另一部分是模块的松耦合，主要指如何将各个模块的配置、资源文件进行分解，避免其相互依赖。 这样做有几点好处：

l API 松耦合可以降低模块之间功能的相互影响，这也是“松耦合”带给我们的最直接的好处，不仅缩小了变更范围，也减少了变更导致的意外缺陷。

l 模块的松耦合可以使得模块做到独立的启动。这样做的好处是，使得模块更易于测试和部署。若要实现部署架构的松耦合，这部分是必须要做的。

  对于模块的松耦合，大多还是利用了嵌入式服务器和 Servlet 规范的模块化支持。这也是成本最低的一种方案，因为相对于你自行设计的方案，Servlet 规范更健壮而且天然的适用于各种应用服务器（而且既然已经有了现成的方案，我们又何必重新发明轮子呢！）。

### ***\*部署架构松耦合\****

  在部署架构松耦合部分，我们只是简单的列举了几个场景。但是借鉴这几个场景，可以使得我们的应用系统实现模块任意组合打包和部署。

  本部分讨论的部署架构并非最先进的，但也不能说是已过时的，主要还是要看你的应用场景，并不是所有场景都适合诸如微服务、无服务等架构，甚至很多场景都不适合，毕竟软件涵盖的行业和应用类型数不胜数，而我们看到的代表先进架构理念的产品只占了这些行业和应用类型的很少一部分。不要为了技术而技术，否则你的应用的可用性会受到极大的影响。

  对于绝大多数应用，如果你做到了模块的任意组合打包及部署，那么往更高级架构升级时，相信也不会很困难。

### ***\*小结\****

  至此，本课程的所有内容已经结束，如果它能为你的应用系统架构工作带来些许帮助，那么对我们来说将会是非常欣慰的事情。限于文章的篇幅，有些方面我们只是概要讲述，并未详细展开，如果你原意就架构的某个方面与我们进一步探讨，也可以在本课程的读者圈给我们。由于文章编写较为仓促，如果内容有何纰漏，还请及时告诉我们，在此表示万分的歉意。

 

# ***\*架构基础\****

 

## ***\*架构到底是指什么？\****

 

 

## ***\*架构设计的历史背景\****

 

## ***\*架构设计的目的\****

 

## ***\*复杂度来源\****

 

### ***\*高性能\****

 

### ***\*高可用\****

 

### ***\*可扩展性\****

 

### ***\*低成本、安全、规模\****

 

### ***\*架构设计三原则\****

 